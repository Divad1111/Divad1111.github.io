<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="后处理是指，在正常渲染管线结束后，对渲染出来的结果进行加工，以此来模拟各种效果。 颜色 颜色(color) 对应电磁波的可见光波段，是被后期处理的波长信息。颜色既是物体的客观属性——确定的波长，又带有大脑的主观属性——不同的个体对特定波长的电磁波敏感程度不同，感受的颜色也有差异。 为了表示色彩，人们建立了一维、二维、三维甚至四维空间坐标模型，这些色彩模型称为颜色空间。颜色空间多达百种，常见的有如下">
<meta property="og:type" content="article">
<meta property="og:title" content="游戏后处理效果">
<meta property="og:url" content="http://yoursite.com/2024/04/21/Unity/Graphics/%E6%B8%B8%E6%88%8F%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/index.html">
<meta property="og:site_name" content="张卫的博客">
<meta property="og:description" content="后处理是指，在正常渲染管线结束后，对渲染出来的结果进行加工，以此来模拟各种效果。 颜色 颜色(color) 对应电磁波的可见光波段，是被后期处理的波长信息。颜色既是物体的客观属性——确定的波长，又带有大脑的主观属性——不同的个体对特定波长的电磁波敏感程度不同，感受的颜色也有差异。 为了表示色彩，人们建立了一维、二维、三维甚至四维空间坐标模型，这些色彩模型称为颜色空间。颜色空间多达百种，常见的有如下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/xy_blank.png">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/rgb_space.png">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/lab_space.png">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/hsv_space.png">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/hsi_space.png">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/hsv_hsi.png">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/hsv_hsi_col.png">
<meta property="og:image" content="http://yoursite.com/images/unity/graphics/se_wu.png">
<meta property="article:published_time" content="2024-04-21T01:46:04.000Z">
<meta property="article:modified_time" content="2025-04-26T11:06:24.130Z">
<meta property="article:author" content="张卫">
<meta property="article:tag" content="后处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/unity/graphics/xy_blank.png">

<link rel="canonical" href="http://yoursite.com/2024/04/21/Unity/Graphics/%E6%B8%B8%E6%88%8F%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>游戏后处理效果 | 张卫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张卫的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Done is better than perfect</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/04/21/Unity/Graphics/%E6%B8%B8%E6%88%8F%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="张卫">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张卫的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          游戏后处理效果
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-21 09:46:04" itemprop="dateCreated datePublished" datetime="2024-04-21T09:46:04+08:00">2024-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-26 19:06:24" itemprop="dateModified" datetime="2025-04-26T19:06:24+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index">
                    <span itemprop="name">Unity</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>后处理是指，在正常渲染管线结束后，对渲染出来的结果进行加工，以此来模拟各种效果。</p>
<h1 id="颜色">颜色</h1>
<p>颜色(color)
对应电磁波的可见光波段，是被后期处理的波长信息。颜色既是物体的客观属性——确定的波长，又带有大脑的主观属性——不同的个体对特定波长的电磁波敏感程度不同，感受的颜色也有差异。
为了表示色彩，人们建立了一维、二维、三维甚至四维空间坐标模型，这些色彩模型称为<strong>颜色空间</strong>。颜色空间多达百种，常见的有如下5种。</p>
<h2 id="颜色数据表示linearlogc">颜色数据表示（Linear，LogC）</h2>
<p>在影像制作和后期处理中，Linear、LogC和Gamma是三种关键的概念，它们描述了不同的图像数据处理和表示方法。理解它们之间的区别对于正确处理图像和视频数据非常重要。</p>
<p><strong>Linear（线性）:</strong>
Linear指的是一种线性响应的色彩空间，其中记录的图像亮度值直接对应于场景中的实际光照强度。在线性色彩空间中，如果场景中一个区域的光照强度是另一个区域的两倍，那么记录的数值也会是两倍。这种表示方式使得图像的色彩混合和处理在数学上更加直接和简单，但由于人眼对亮度的感知是非线性的，线性空间通常不适用于最终图像的显示。</p>
<p><strong>LogC（对数）</strong>
LogC是ARRI摄影机特有的一种对数色彩空间，它旨在通过对数曲线来模拟人眼对亮度的非线性感知，使得在有限的比特深度下能够捕获更宽的动态范围。LogC色彩空间特别适合于记录高动态范围的场景，因为它能够有效地保留高光和阴影中的细节。然而，LogC图像在没有经过适当的色彩校正或应用LUT（查找表）之前，看起来会显得非常低饱和和低对比度。</p>
<p><strong>Gamma</strong>
Gamma校正是一种用于调整图像亮度的非线性操作，旨在使图像在特定显示设备上的显示更符合人眼的感知特性。Gamma校正可以被视为在图像数据和最终显示之间的一个桥梁，用于调整图像的整体亮度和对比度。不同的显示设备和媒体标准可能会使用不同的Gamma值，如sRGB标准使用大约2.2的Gamma值。</p>
<p><strong>总结</strong></p>
<p><strong>Linear色彩空间：</strong>
最适合图像的处理和合成，需要在最终输出前转换到适合观看的色彩空间。</p>
<p><strong>LogC色彩空间：</strong>
用于捕获和记录高动态范围的图像，需要在后期处理中进行色彩校正。</p>
<p><strong>Gamma校正：</strong>
用于调整图像的显示，以符合人眼对亮度的非线性感知和特定显示设备的要求。</p>
<a id="more"></a>
<h2 id="颜色空间">颜色空间</h2>
<h3 id="xyz颜色空间">XYZ颜色空间</h3>
<p>CIE
XYZ色彩空间是一种基于人类视觉响应的色彩模型，于1931年由国际照明委员会（CIE，Commission
Internationale de
l'Éclairage）提出。它是第一个基于人类视觉实验数据的数学定义色彩空间，旨在提供一种不依赖于特定设备的色彩表示方法，从而允许在不同设备和媒介之间准确地转换和比较颜色。</p>
<p><strong>三色刺激值</strong></p>
<p>三色刺激值并不是指人类眼睛对短、中和长波（S、M和L）的反应，而是一组称为X、Y和Z的值，约略对应于红色、绿色和蓝色（但要留意X、Y和Z值并不是真的看起来是红、绿和蓝色，而是从红色、绿色和蓝色导出来的参数），并使用CIE
1931
XYZ颜色匹配函数来计算。两个由多种不同波长的光混合而成的光源可以表现出同样的颜色，这叫做“同色异谱”（metamerism）。当两个光源对标准观察者（CIE
1931标准色度观察者）有相同的视现颜色的时候，它们即有同样的三色刺激值，而不管生成它们的光的光谱分布如何。</p>
<p><strong>xy色度图</strong></p>
<p>因为人类眼睛有响应不同波长范围的三种类型的颜色传感器，所有可视颜色的完整绘图是三维的。但是颜色的概念可以分为两部分：明度和色度。例如，白色是明亮的颜色，而灰色被认为是不太亮的白色。换句话说，白色和灰色的色度是一样的，而明度不同。
CIE
Yxy色彩空间故意设计得Y参数是颜色的明度或亮度的测量。颜色的色度接着通过两个导出参数x和y来指定，它们是所有三色刺激值X、Y和Z的函数,规范化下的三个值中的两个：</p>
<p><span class="math display">\[
x = \frac{X}{X+Y+Z} \\
y = \frac{Y}{X+Y+Z} \\
z = \frac{Z}{X+Y+Z} = 1-x-y
\]</span></p>
<p>导出的色彩空间用x, y, Y来指定，它叫做CIE
xyY色彩空间并在实践中广泛用于指定颜色。</p>
<p>X和Z三色刺激值可以从色度值x和y与Y三色刺激值计算回来：</p>
<p><span class="math display">\[
X = \frac{Y}{y} x \\
Z = \frac{Y}{y}(1-x-y)
\]</span></p>
<figure>
<img src="/images/unity/graphics/xy_blank.png" alt="xy色度图" />
<figcaption aria-hidden="true">xy色度图</figcaption>
</figure>
<p>具体公式，参见：<a
href="https://zh.wikipedia.org/wiki/CIE_1931%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">CIE
1931 XYZ色彩空间</a></p>
<h3 id="lms颜色空间">LMS颜色空间</h3>
<p>LMS颜色空间基于人眼对光的生理响应，其中L、M、S分别代表长波长（红色）、中波长（绿色）和短波长（蓝色）的锥状细胞。这三种类型的锥细胞是人眼感知颜色的基础。LMS颜色空间尝试模拟这种生理机制，以便在图像处理、色彩校正和视觉研究中更准确地反映和操作色彩。
- L（Long wavelengths）：长波锥细胞，主要对红色光敏感。 - M（Medium
wavelengths）：中波锥细胞，主要对绿色光敏感。 - S（Short
wavelengths）：短波锥细胞，主要对蓝色光敏感。</p>
<p>在图像处理和色彩管理中，将RGB或其他色彩空间转换到LMS色彩空间可以帮助模拟和理解人类的色彩感知过程，进而进行更精确的色彩校正和调整。</p>
<h3 id="rgb颜色空间">RGB颜色空间</h3>
<p>RGB色彩空间基于三原色学说：视网膜存在三种视锥细胞，分别含有对红、绿、蓝三种光线敏感的视色素，当一定波长的光线作用于视网膜时，以一定的比例使三种视锥细胞分别产生不同程度的兴奋，这样的信息传至大脑中枢就产生某一种颜色的感觉。</p>
<figure>
<img src="/images/unity/graphics/rgb_space.png" alt="RGB颜色空间" />
<figcaption aria-hidden="true">RGB颜色空间</figcaption>
</figure>
<p>RGB颜色模型的优点是：</p>
<ul>
<li>易于理解；</li>
<li>便于硬件实现，现代显示屏一般基于RGB模型；</li>
<li>引入位分辨率(颜色深度)
，指一个像素中，每个颜色分量的比特数。位分辨率决定了色彩等级，例如8位颜色深度，每个颜色分量就有256种可能。</li>
</ul>
<p>RGB颜色模型的缺点是：</p>
<ul>
<li>三个分量均用于表示色调，即如果改变某一个分量的数值，这个像素的颜色就发生了改变。在颜色定位等工程中，使用RGB模型就要同时考虑、、三个变量，较为复杂。</li>
</ul>
<h3 id="cmycmyk颜色空间">CMY/CMYK颜色空间</h3>
<p>CMY是工业印刷采用的颜色空间。它与RGB对应。简单的类比RGB来源于是物体发光，而CMY是依据反射光得到的。具体应用如打印机：一般采用四色墨盒，即CMY加黑色墨盒
CMY是青（Cyan）、洋红或品红（Magenta）和黄（Yellow）三种颜色，由于三原色得不到纯黑色，CMYK则是打印时加上墨色(black
ink)，例如青色可以通过蓝色和绿色光相加得到，则白色通过青色时，没有红色分量。底色为白色进行色彩减法可以得到各种颜色。</p>
<h3 id="lab颜色空间">Lab颜色空间</h3>
<p>Lab色彩空间基于人对颜色的感觉设计，具有感知均匀性(Perceptual Uniform)
，即如果参数L、a、b变化幅度一样，则人视觉上的变化幅度也差不多。</p>
<figure>
<img src="/images/unity/graphics/lab_space.png" alt="Lab颜色空间" />
<figcaption aria-hidden="true">Lab颜色空间</figcaption>
</figure>
<p>在Lab模式下，通道向量由三个部分组成：</p>
<ul>
<li>亮度(Lightness)</li>
<li>a颜色分量：代表从绿色到红色的分量</li>
<li>b颜色分量：代表从蓝色到黄色的分量</li>
</ul>
<p>Lab同样容易调整——调节亮度仅需关注L通道，调节色彩平衡仅需关注a和b通道。此外，Lab还具有色域广阔、设备无关等性质。</p>
<h3 id="hsvhsb颜色空间">HSV/HSB颜色空间</h3>
<p>HSV颜色空间比RGB更接近人们对彩色的感知经验，非常直观地表达颜色的色调、饱和度和明暗程度。</p>
<p>在HSV模式下，通道向量由三个部分组成：</p>
<ul>
<li>色调、色相(Hue)
：与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。</li>
<li>饱和度(Saturation)
：表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。</li>
<li>明度(Value, Brightness) ：指某种颜色的透光量。与亮度(Lightness)
不同，亮度特指被白光稀释的浓度，任何颜色的高亮都趋于白色，但每种高明度颜色都不同。</li>
</ul>
<figure>
<img src="/images/unity/graphics/hsv_space.png" alt="HSV/HSB颜色空间" />
<figcaption aria-hidden="true">HSV/HSB颜色空间</figcaption>
</figure>
<p>由于HSV可以单独处理色调值，而不会影响到明度和饱和度；或者单独改变明度、饱和度而不影响颜色本身，因此在图像处理中，HSV常用于颜色定位追踪、提取色彩直方图等。</p>
<p>HSV模型的缺点是目前很少有硬件支持，需要从RGB或其他色彩空间进行转换。</p>
<h3 id="hsihsl颜色空间">HSI/HSL颜色空间</h3>
<p>HSV颜色空间比RGB更接近人们对彩色的感知经验，非常直观地表达颜色的色调、饱和度和明暗程度。</p>
<p>在HSI模式下，通道向量由三个部分组成：</p>
<ul>
<li>色调H(Hue)：
与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。</li>
<li>饱和度S(Saturation)：
表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。</li>
<li>亮度I(Intensity, Lightness)：
对应成像亮度和图像灰度，是颜色的明亮程度。</li>
</ul>
<figure>
<img src="/images/unity/graphics/hsi_space.png" alt="HSI/HSL颜色空间" />
<figcaption aria-hidden="true">HSI/HSL颜色空间</figcaption>
</figure>
<p>由于HSV可以单独处理色调值，而不会影响到明度和饱和度；或者单独改变明度、饱和度而不影响颜色本身，因此在图像处理中，HSV常用于颜色定位追踪、提取色彩直方图等。</p>
<p>HSV模型的缺点是目前很少有硬件支持，需要从RGB或其他色彩空间进行转换。</p>
<h4 id="hsvhsb与hsihsl颜色空间对比">HSV/HSB与HSI/HSL颜色空间对比</h4>
<p>HSV和HSL二者都把颜色描述为在圆柱坐标系内的点，这个圆柱的中心轴底部为黑色，顶部为白色，而它们中间是灰色渐变，绕这个轴的角度对应于“色相”，到这个轴的距离对应于“饱和度”，而沿着这个轴的高度对应于“明度”或“亮度”。</p>
<p>这两种表示在目的上类似，但在方法上有区别。二者在数学上都是圆柱，但HSV（色相、饱和度、明度）在概念上可以被认为是颜色的倒圆锥体（黑点在下顶点，白色在上底面圆心），HSL在概念上表示了一个双圆锥体和圆球体（白色在上顶点，黑色在下顶点，最大横切面的圆心是半程灰色）。注意尽管在HSL和HSV中“色相”指称相同的性质，它们的“饱和度”的定义是明显不同的。</p>
<p>因为HSL和HSV是设备依赖的RGB的简单变换，(h, s, l)或 (h, s,
v)三元组定义的颜色依赖于所使用的特定红色、绿色和蓝色“加法原色”。每个独特的RGB设备都伴随着一个独特的HSL和HSV空间。但是
(h, s, l)或 (h, s,
v)三元组在被约束于特定RGB空间比如sRGB的时候就更明确了。</p>
<p>HSV模型在1978年由埃尔维·雷·史密斯创立，它是三原色光模式的一种非线性变换，如果说RGB加色法是三维直角座标系，那么HSV模型就是球面座标系。</p>
<figure>
<img src="/images/unity/graphics/hsv_hsi.png" alt="HSV和HSI对比" />
<figcaption aria-hidden="true">HSV和HSI对比</figcaption>
</figure>
<figure>
<img src="/images/unity/graphics/hsv_hsi_col.png" alt="HSV和HSI对比" />
<figcaption aria-hidden="true">HSV和HSI对比</figcaption>
</figure>
<h4 id="hsv出现的动机">HSV出现的动机</h4>
<p>大多数电视机、显示器、投影仪通过将不同强度的红、绿、蓝色光混合来生成不同的颜色，这就是RGB三原色的加色法。通过这种方法可以在RGB色彩空间生成大量不同的颜色，然而，这三种颜色分量的取值与所生成的颜色之间的联系并不直观。
艺术家有时偏好使用HSV或HSL而不选择三原色光模式（即RGB模型）或
印刷四分色模式（即CMYK模型），因为它类似于人类感觉颜色的方式，具有较强的感知度。RGB和CMYK分别是加法原色和减法原色模型，以原色组合的方式定义颜色，而HSV以人类更熟悉的方式封装了关于颜色的信息：“这是什么颜色？深浅如何？明暗如何？”。
但是色彩属性和物理学中的光谱并不是完全对应的，物理学的人类可见光谱是有两个端点的直线形，并不能形成一个环。当然每种颜色都可以找到相应的光波长，但都有一个范围，并不是单一的波长。明度一般和具体某种颜色的光波能量相当，但和整个光谱的能量无关（因为每种波长的光的能量都不相同）。HSV颜色空间在技术上不支持到辐射测定中测量的物理能量谱密度的一一映射。所以一般不建议做在HSV坐标和物理光性质如波长和振幅之间的直接比较。</p>
<h1 id="抗锯齿anti-aliasing-aa">抗锯齿（Anti-aliasing, AA）</h1>
<p>有很多抗锯齿技术，都是在后处理阶段进行的，在分析URP后处理源码前，先了解一下抗锯齿相关的技术。
抗锯齿（Anti-aliasing,
AA）技术是用来减少和消除图形渲染中的锯齿现象，即在边缘和细节部分出现的不平滑、断续的像素效果。锯齿通常发生在边缘的像素没有完全覆盖物体的情况下，导致视觉上的不连续性。以下是一些常见的抗锯齿技术及其原理：</p>
<h2 id="全屏抗锯齿fsaafull-screen-anti-aliasing">全屏抗锯齿（FSAA，Full
Screen Anti-Aliasing）</h2>
<p>增加渲染分辨率，然后将图像缩小到目标分辨率。通过这种方式，每个最终像素中包含了更多的信息，从而平滑了边缘。FSAA是一种简单直接的方法，但对性能的影响较大，因为它需要渲染更多的像素。
全屏抗锯齿（FSAA，Full Screen
Anti-Aliasing）是一种较早的抗锯齿技术，其基本思想是在比最终输出分辨率更高的分辨率上渲染场景，然后将这个高分辨率的图像缩小（下采样）到目标分辨率，以此来减少锯齿效果。虽然FSAA概念简单，但直接实现（如超采样抗锯齿，SSAA）在性能上可能非常昂贵，因为它要求渲染更多的像素。以下是FSAA在图形管线和GPU中的一般实现原理：</p>
<p><strong>图形管线中的FSAA实现</strong></p>
<ol type="1">
<li><strong>渲染分辨率调整：</strong>首先，渲染目标（RenderTarget）的分辨率被设置为目标显示分辨率的倍数。例如，如果目标是1080p（1920x1080），则可能在4K（3840x2160）分辨率上进行渲染，这实质上是对每个维度进行了2倍的超采样。</li>
<li><strong>场景渲染：</strong>图形管线按照这个高分辨率渲染整个场景，包括3D模型、纹理、光照等。这个过程涉及标准的渲染步骤，如几何处理、栅格化、片段着色等，但每个步骤处理的像素数量明显增加。</li>
<li><strong>下采样：</strong>渲染完成后，图形管线执行一个下采样（或称为图像缩放）步骤，将高分辨率的渲染结果缩减到目标分辨率。这个过程通常使用滤波算法（如双线性或双三次滤波）来合并像素，以保留细节的同时减少锯齿。</li>
</ol>
<p><strong>GPU硬件中的FSAA支持</strong></p>
<ul>
<li><strong>硬件加速的下采样：</strong>现代GPU提供了硬件加速的图像缩放功能，可以高效地执行高到低分辨率的图像下采样。这有助于减轻FSAA对性能的影响，尤其是在下采样步骤。</li>
<li><strong>专用的渲染缓冲区：</strong>为了支持高分辨率渲染，GPU可能提供专用的高容量渲染缓冲区。这些缓冲区设计用来存储更多的像素数据，并且能够快速进行图像处理操作。</li>
</ul>
<p><strong>实现细节与考虑</strong></p>
<ul>
<li><strong>性能考量：</strong>FSAA（特别是当直接以超采样的形式实现时）对GPU的计算能力和内存带宽要求较高。由于需要渲染更多的像素，这可能导致帧率下降，尤其是在复杂场景和高分辨率设置下。</li>
<li><strong>图像质量：</strong>FSAA可以提供非常高质量的抗锯齿效果，因为它不仅影响场景的边缘，也影响场景内部的细节，如纹理的平滑度。</li>
<li><strong>应用场景：</strong>由于其性能成本，FSAA（特别是SSAA）可能不适合所有应用。在性能敏感的应用中（如VR或某些游戏），可能会考虑使用其他抗锯齿技术，如MSAA或FXAA。</li>
</ul>
<h2
id="超采样抗锯齿ssaasuper-sample-anti-aliasing">超采样抗锯齿（SSAA，Super-Sample
Anti-Aliasing）</h2>
<p>类似于FSAA，SSAA通过在较高分辨率下渲染图像，然后缩小到目标分辨率来实现抗锯齿。与FSAA不同的是，SSAA通常采用更高级的采样算法和滤波技术，以获得更好的图像质量。SSAA对性能的影响非常大，通常只在对图像质量有极高要求的情况下使用。</p>
<h2
id="多重采样抗锯齿msaamulti-sample-anti-aliasing">多重采样抗锯齿（MSAA，Multi-Sample
Anti-Aliasing）</h2>
<p>在边缘区域采样多个像素，然后将这些采样的颜色值平均化以确定最终像素的颜色。MSAA专注于边缘，不会对整个场景的每个像素进行多重采样，因此相比FSAA，它对性能的影响较小。
多重采样抗锯齿（MSAA）是一种在图形管线和GPU硬件层面实现的抗锯齿技术，旨在减少边缘的锯齿现象而对性能影响尽可能小。MSAA的工作原理涉及多个阶段，从几何处理到像素着色，最后到像素写入帧缓冲区。下面是MSAA在图形管线和GPU中的实现细节：</p>
<p><strong>几何处理阶段</strong></p>
<ol type="1">
<li><strong>多重采样缓冲区准备：</strong>在GPU中，为实现MSAA，首先需要创建一个多重采样缓冲区。这个缓冲区相比常规的颜色缓冲区有更多的样本点，用于存储每个像素的多个颜色值和深度信息。例如，4x
MSAA意味着每个像素将包含4个独立的样本点。</li>
<li><strong>几何图元的栅格化：</strong>当几何图元（如三角形）被栅格化（转换为像素网格）时，图形管线会为每个像素生成多个覆盖该像素的图元片段（片段是像素在渲染过程中的中间表示）。每个片段对应于像素内的一个样本点。</li>
</ol>
<p><strong>像素着色阶段</strong></p>
<ol type="1">
<li><strong>片段着色器执行：</strong>对于MSAA，片段着色器可能会被执行多次，每个样本点一次，或者根据具体实现，可能只执行一次并共享结果。不过，通常情况下，片段着色器的执行结果会存储在每个样本点中，允许细节丰富和光滑的边缘渲染。</li>
</ol>
<p><strong>最终像素写入</strong></p>
<ol type="1">
<li><strong>样本点合并（Resolve）：</strong>在所有相关的几何图元被处理，且每个像素的样本点都被着色后，图形管线会执行一个合并（resolve）步骤，这一步骤将每个像素内的样本点的颜色值合并成一个单一的颜色值。这通常通过简单的平均值计算完成，但也可以包括更复杂的滤波算法。</li>
<li><strong>写入帧缓冲区：</strong>合并后的像素值最终被写入到帧缓冲区中，完成整个渲染过程。</li>
</ol>
<p><strong>GPU支持和优化</strong></p>
<ul>
<li><strong>硬件级支持：</strong>现代GPU设计有专门的硬件支持MSAA，包括专用的多重采样缓冲区和高效的样本点处理机制。这种硬件级支持使得MSAA能够在保持较高渲染质量的同时，最小化对性能的影响。</li>
<li><strong>内存和带宽优化：</strong>虽然MSAA增加了内存使用和带宽需求（因为需要为每个像素存储多个样本点的数据），但GPU厂商实现了多种优化技术，如压缩技术和智能缓冲区管理，以减少这些开销。</li>
</ul>
<h2
id="快速近似抗锯齿fxaafast-approximate-anti-aliasing">快速近似抗锯齿（FXAA，Fast
Approximate Anti-Aliasing）</h2>
<p>FXAA是一种屏幕空间算法，它在图像的最终阶段处理，通过分析像素的亮度变化来识别边缘，并对边缘进行平滑处理。FXAA对性能的影响较小，实现简单，但可能会导致图像细节的轻微模糊。
快速近似抗锯齿（Fast Approximate Anti-Aliasing,
FXAA）是一种屏幕空间的抗锯齿技术，旨在以较低的性能成本减少图像中的锯齿现象。与传统的多重采样抗锯齿（MSAA）相比，FXAA在图形管线的后期处理阶段实施，不需要对每个几何图元进行多次采样，因而对性能的影响较小。以下是FXAA在图形管线和GPU中的实现概览：</p>
<p><strong>图形管线中的FXAA实现</strong></p>
<ol type="1">
<li><strong>渲染场景：</strong>
首先，场景被正常渲染到一个帧缓冲区中，不应用任何抗锯齿技术。</li>
<li><strong>后期处理阶段：</strong>
场景渲染完成后，FXAA作为后期处理效果应用。这意味着FXAA操作是在图像已经渲染完成的基础上进行的，利用片段着色器对已经渲染好的图像进行处理。</li>
<li><strong>边缘检测：</strong>
FXAA首先通过分析像素颜色的局部梯度来识别图像中的边缘。这一步通常涉及比较当前像素与其邻近像素的颜色差异。</li>
<li><strong>锯齿平滑：</strong>
一旦边缘被识别，FXAA算法会沿着边缘方向平滑锯齿，方法是对边缘附近的像素进行混合。这种方式旨在减少锐利边缘处的颜色梯度，从而减少视觉上的锯齿现象。</li>
<li><strong>色彩校正：</strong>
在某些实现中，FXAA还可能包括对处理后图像的色彩进行微调，以保持图像的色彩真实性。</li>
</ol>
<p><strong>在GPU上的实现</strong></p>
<p>FXAA是通过片段着色器在GPU上实现的。由于其算法主要基于像素操作，FXAA非常适合在GPU上执行，能够充分利用GPU并行处理像素的能力。实现FXAA通常涉及以下步骤：</p>
<ul>
<li><strong>编写FXAA着色器：</strong>
开发者会编写一个片段着色器，该着色器包含FXAA算法的实现逻辑。这个着色器会对每个像素应用FXAA算法，包括边缘检测和锯齿平滑。</li>
<li><strong>应用着色器：</strong>
在渲染流程的后期处理阶段，将FXAA着色器应用于已渲染的图像。这通常通过将渲染好的场景作为纹理输入到后期处理管线，并执行FXAA着色器。</li>
<li><strong>输出结果：</strong>
FXAA处理后的图像被输出到屏幕或下一阶段的渲染目标。</li>
</ul>
<p><strong>性能优化</strong></p>
<p>FXAA的设计考虑到了性能优化，通过减少算法复杂度和精心设计的着色器代码来降低对性能的影响。相比于MSAA等传统抗锯齿技术，FXAA提供了一个性能成本较低的抗锯齿解决方案，特别适用于性能敏感的应用场景。</p>
<h2
id="子像素抗锯齿smaasubpixel-morphological-anti-aliasing">子像素抗锯齿（SMAA，Subpixel
Morphological Anti-Aliasing）</h2>
<p>SMAA是一种高级的屏幕空间抗锯齿技术，结合了MSAA、FXAA和其他技术的优点。它使用局部对比度检测来识别边缘，并使用多种策略（包括子像素级处理）来平滑边缘。SMAA旨在在保持高性能的同时提供较高的图像质量。
每种抗锯齿技术都有其优势和局限性，选择哪一种取决于特定的应用场。
子像素抗锯齿（Subpixel Morphological Antialiasing,
SMAA）是一种高效且灵活的抗锯齿技术，它结合了多种抗锯齿技术的优点，如MSAA（多重采样抗锯齿）和FXAA（快速近似抗锯齿），但旨在提供更高的图像质量和更低的性能成本。SMAA通过分析图像来识别锯齿边缘，并采用各种策略对这些边缘进行平滑处理。以下是SMAA在图形管线和GPU上的一般实现流程：</p>
<p><strong>SMAA的实现步骤</strong></p>
<ol type="1">
<li><strong>边缘检测：</strong>
SMAA首先在图像中识别出锯齿边缘。这通常通过分析颜色、亮度或深度差异来实现，以找到可能产生锯齿的像素边界。边缘检测可以使用多种算法，包括基于梯度、Sobel算子或自定义滤波器。</li>
<li><strong>模式识别：</strong>
识别出边缘后，SMAA通过比较这些边缘与一系列预定义的模式（或模板）来进行分类。这些模式对应于常见的锯齿形状和分布，使SMAA能够更精确地确定如何对特定的锯齿边缘进行处理。</li>
<li><strong>子像素处理：</strong>
SMAA利用子像素级的信息来改善锯齿边缘的渲染质量。这涉及到对锯齿边缘附近的像素进行细微调整，以模拟更高分辨率下的图像细节和边缘平滑效果。</li>
<li><strong>形态学合并：</strong>
最后，SMAA应用形态学操作来平滑边缘和合并处理过的像素，最终产生抗锯齿效果。这一步骤利用了先前的模式识别结果，以确保边缘处理既平滑又自然，减少了过度模糊或其他视觉伪像。</li>
</ol>
<p><strong>在GPU和图形管线中的实现</strong></p>
<ul>
<li><strong>Shader实现：</strong>
SMAA主要在GPU的Shader阶段实现，通常作为一系列的后处理步骤。这包括顶点Shader用于设置屏幕空间的四边形，以及片元Shader来执行边缘检测、模式识别、子像素处理和形态学合并。</li>
<li><strong>后处理管线：</strong> 在现代图形API（如DirectX
11/12、Vulkan、OpenGL）中，SMAA通常作为渲染管线的后处理阶段进行，处理完所有的3D渲染和其他视觉效果后，再应用SMAA来改善最终的图像质量。</li>
<li><strong>性能优化：</strong>
SMAA的实现通常涉及对性能的优化，以最小化对帧率的影响。这可能包括优化Shader代码、减少不必要的纹理采样、使用高效的数据结构和算法等。此外，SMAA允许不同级别的质量设置，开发者可以根据性能需求选择合适的级别。</li>
</ul>
<p><strong>兼容性和灵活性</strong></p>
<p>SMAA的设计允许它在各种硬件和平台上有效运行，从高端PC显卡到移动设备。这得益于它对资源的有效管理和对性能的细致优化，使其成为当前广泛使用的</p>
<h2 id="时间抗锯齿taatemporal-anti-aliasing">时间抗锯齿（TAA，Temporal
Anti-Aliasing）</h2>
<p>TAA利用连续帧之间的信息来平滑边缘和去除闪烁。它结合了当前帧和之前帧的数据，通过时间上的信息融合来减少锯齿。TAA能够提供非常平滑的图像质量，但可能引入一些运动模糊，特别是在快速移动的场景中。
时间抗锯齿（Temporal Anti-Aliasing,
TAA）是一种先进的抗锯齿技术，通过结合多个帧的数据来减少锯齿，同时尽量保持图像细节。与传统的抗锯齿技术如MSAA（多重采样抗锯齿）或FSAA（全屏抗锯齿）不同，TAA不仅仅关注单一帧内的像素处理，而是利用时间维度上的信息来改善图像质量。这种方法在现代游戏和应用中越来越受欢迎，尤其是对于动态场景。</p>
<p><strong>TAA的工作原理</strong></p>
<ol type="1">
<li><strong>运动矢量：</strong>TAA技术首先需要捕捉场景中对象的运动。这通过使用运动矢量图（Motion
Vector
Pass）来实现，运动矢量图记录了场景中每个像素点从前一帧到当前帧的移动情况。运动矢量通常由GPU的顶点着色器计算，并在渲染管线的早期阶段生成。</li>
<li><strong>历史帧混合：</strong>TAA将当前帧的图像与之前帧的图像进行混合。通过对运动矢量的分析，TAA能够确定如何将当前帧的像素与历史帧的像素相结合，以减少锯齿并平滑边缘。这一步骤需要精确的运动跟踪和合适的权重分配，以确保图像的连贯性和减少运动模糊。</li>
<li><strong>锐化和噪声处理：</strong>由于TAA在混合过程中可能引入模糊，因此在处理完混合后，通常会应用一定程度的锐化来保持图像的清晰度。同时，TAA也可能引入一些图案噪声，特别是在场景快速变化时，因此可能需要额外的噪声抑制步骤。</li>
</ol>
<p><strong>GPU和图形管线中的实现</strong></p>
<ul>
<li><strong>运动矢量的生成：</strong>现代GPU提供了高效的方式来计算和存储运动矢量。这通常在顶点着色器或几何着色器中实现，通过比较当前帧和前一帧的顶点位置来生成。</li>
<li><strong>图像处理和混合：</strong>TAA的混合处理主要在片段着色器和后处理阶段进行。GPU需要处理大量的纹理读取操作，包括访问当前帧的像素数据和历史帧的像素数据，然后基于运动矢量进行适当的混合。</li>
<li><strong>后处理效果：</strong>TAA通常作为一系列后处理效果的一部分实现，在最终图像输出前应用。这意味着TAA可以与其他图像处理效果（如色彩校正、HDR渲染等）一起在GPU的后处理管线中执行。</li>
</ul>
<p><strong>考虑因素</strong></p>
<ul>
<li><strong>运动估计的准确性：</strong>TAA的效果很大程度上依赖于运动矢量的准确性。不准确的运动跟踪可能导致图像拖影或其他视觉伪像。</li>
<li><strong>性能和质量平衡：</strong>TAA在提升图像质量的同时，相对于其他抗锯齿技术，对性能的影响较小。但是，它需要合理的资源分配和优化，特别是在高分辨率渲染或要求高帧率的应用中。</li>
</ul>
<h1 id="urp后处理源码分析">URP后处理源码分析</h1>
<p>在URP中后处理源码主要由三个部分组成：</p>
<ol type="1">
<li>Volume系统, 用于管理后处理组件参数，以及参数的混合。</li>
<li>URP的PostProcessPasses，用于管理后处理的相关Pass(ColorGradingLutPass和PostProcessPass)，Pass会将Volume系统提供的参数设置给Shader中使用。</li>
<li>各种后处理Shader(PostProcessData持久化对象存储了后处理中使用的各种Shader和纹理)</li>
</ol>
<h2 id="volume系统">Volume系统</h2>
<p>Volume系统由两个部分组成:</p>
<ol type="1">
<li>持久化类,
用于存储各种后处理组件的参数，核心类:VolumeProfile，VolumeComponent和VolumeParameter</li>
<li>运行时类,
Volume表示一个后处理对象；VolumeStack记录所有Volume对象中，所有后处理组件根据权重混合后的最终结果；VolumeManager管理所有的Volume对象并在Update中，根据优先级，权重和混合距离对每个Volume中相同后处理组件的参数进行插值混合，具体的插值方式由对应的参数VolumeParameter类提供。</li>
</ol>
<h3 id="持久化类">持久化类</h3>
<h4 id="volumeprofile">VolumeProfile</h4>
<p>VolumeProfile用于管理VolumeComponent列表，标准的一些Add,Remove,TryGet等函数。</p>
<h4 id="volumecomponent">VolumeComponent</h4>
<p>VolumeComponent中包含了后处理组件中的参数(VolumeParameter对象列表)。核心函数就是Override，其作用的是同一个后处理组件中的参数进行插值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Override</span>(<span class="params">VolumeComponent state, <span class="keyword">float</span> interpFactor</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = parameters.Count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> stateParam = state.parameters[i];</span><br><span class="line">        <span class="keyword">var</span> toParam = parameters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toParam.overrideState)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Keep track of the override state for debugging purpose</span></span><br><span class="line">            stateParam.overrideState = toParam.overrideState;</span><br><span class="line">            stateParam.Interp(stateParam, toParam, interpFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="volumeparameter">VolumeParameter</h4>
<p>后处理组件的参数，有各种类型的派生类(int， float,
vector等类型，也可以根据自己需求新增派生类)，核心函数就是Interp，每种类型都有自己的Interp。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float的插值函数，线性插值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Interp</span>(<span class="params"><span class="keyword">float</span> <span class="keyword">from</span>, <span class="keyword">float</span> to, <span class="keyword">float</span> t</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_Value = <span class="keyword">from</span> + (to - <span class="keyword">from</span>) * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时类">运行时类</h3>
<h4 id="volumestack">VolumeStack</h4>
<p>VolumeStack类记录了所有的后处理组件，也是保存最终参数插值结果的。此类的组件参数值也是最终要被设置到Shader中去的参数值。</p>
<h4 id="volumemanager">VolumeManager</h4>
<p>VolumeManager管理了所有Volume组件和当前使用的VolumeStack对象，VolumeManager的目的就是为了将所有的Volume对象中的后处理组件的参数进行插值，并保存在VolumeStack对象中，其核心函数就是Update。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack ： 保存插值混合后的结果</span></span><br><span class="line"><span class="comment">// trigger：计算混合时使用的位置（Volume对象到此位置来计算混合），默认使用相机位置，也可以在相机组件中拖拽一个对象作为计算混的位置。</span></span><br><span class="line"><span class="comment">// layerMask: 对此相机有效的Volume对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">VolumeStack stack, Transform trigger, LayerMask layerMask</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assert.IsNotNull(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证所有的后处理组件已创建</span></span><br><span class="line">    CheckBaseTypes();</span><br><span class="line">    <span class="comment">// 检查记录最终结果的后处理栈是否创建</span></span><br><span class="line">    CheckStack(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用后处理组件的默认值初始化后处理栈</span></span><br><span class="line">    ReplaceData(stack, m_ComponentsDefaultState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算混合的触发位置，全局的Volume对象是不会跟触发位置与Volume对象之间的距离进行插值的</span></span><br><span class="line">    <span class="keyword">bool</span> onlyGlobal = trigger == <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> triggerPos = onlyGlobal ? Vector3.zero : trigger.position;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应层级排序后的Volume对象列表</span></span><br><span class="line">    <span class="keyword">var</span> volumes = GrabVolumes(layerMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Trigger对应的相机，当然也可以能没有相机（直接拖拽的一个Trigger对象）</span></span><br><span class="line">    Camera camera = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!onlyGlobal)</span><br><span class="line">        trigger.TryGetComponent&lt;Camera&gt;(<span class="keyword">out</span> camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的Volume，并对他们进行插值，全局的Volume是没有距离插值的</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> volume <span class="keyword">in</span> volumes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (volume == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="comment">// 跳过场景视图中当前显示的场景中不存在的Volume</span></span><br><span class="line">        <span class="keyword">if</span> (!IsVolumeRenderedByCamera(volume, camera))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过哪些被禁用，没有关连VolumeProfile或者权重为0的Volume对象</span></span><br><span class="line">        <span class="keyword">if</span> (!volume.enabled || volume.profileRef == <span class="literal">null</span> || volume.weight &lt;= <span class="number">0f</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局Volume没有距离的显示，都生效，本地的则需要根据它与trigger的距离来计算插值，全局Volume只需要权重插值即可</span></span><br><span class="line">        <span class="keyword">if</span> (volume.isGlobal)</span><br><span class="line">        &#123;</span><br><span class="line">            OverrideData(stack, volume.profileRef.components, Mathf.Clamp01(volume.weight));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局的就继续下一个Volume对象</span></span><br><span class="line">        <span class="keyword">if</span> (onlyGlobal)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是全局的，又没有Collider对象，则不能根据Trigger与Volume对象是否相交，来计算插值权重，Trigger越靠近Volume对象上Collider的范围影响越大，权重也就越大。没有Collider则无法计算，所以也排除</span></span><br><span class="line">        <span class="keyword">var</span> colliders = m_TempColliders;</span><br><span class="line">        volume.GetComponents(colliders);</span><br><span class="line">        <span class="keyword">if</span> (colliders.Count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最新的Collider对象</span></span><br><span class="line">        <span class="keyword">float</span> closestDistanceSqr = <span class="keyword">float</span>.PositiveInfinity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> collider <span class="keyword">in</span> colliders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!collider.enabled)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> closestPoint = collider.ClosestPoint(triggerPos);</span><br><span class="line">            <span class="keyword">var</span> d = (closestPoint - triggerPos).sqrMagnitude;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d &lt; closestDistanceSqr)</span><br><span class="line">                closestDistanceSqr = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        colliders.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算Volume的混合计算的平方</span></span><br><span class="line">        <span class="keyword">float</span> blendDistSqr = volume.blendDistance * volume.blendDistance;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果最近的距离都大于混合距离，则说明，Trigger位置和Volume对象的Collider不相交，则此Volume对于Trigger来所不生效，所有排除</span></span><br><span class="line">        <span class="keyword">if</span> (closestDistanceSqr &gt; blendDistSqr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算相交程度</span></span><br><span class="line">        <span class="keyword">float</span> interpFactor = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">if</span> (blendDistSqr &gt; <span class="number">0f</span>)</span><br><span class="line">            interpFactor = <span class="number">1f</span> - (closestDistanceSqr / blendDistSqr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据相交程度和Volume的权重值，确定最终的权重值（相交程度因子 x Volume的权重值）</span></span><br><span class="line">        OverrideData(stack, volume.profileRef.components, interpFactor * Mathf.Clamp01(volume.weight));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="volume">Volume</h4>
<p>Volume代表一个后处理对象，此对象引用了VolumeProfile，VolumeProfile对象则记录了使用的后处理组件。Volume处理提供了VolumeProfile字段，还有isGlobal表示是全局还是本地Volume，weight表示权重，priority表示优先级（进行插值的先后顺序），blendDistance混合距离此字段仅用于本地Volume对象。</p>
<h2
id="postprocesspasses和postprocesspass">PostProcessPasses和PostProcessPass</h2>
<p>PostProcessPasses是PostProcessPass的一个包装类，主要包含三个Pass:</p>
<ul>
<li>ColorGradingLutPass colorGradingLutPass
在后处理之前，渲染LUT纹理。</li>
<li>PostProcessPass postProcessPass
对启用的后处理组件，设置参数并根据参数处理图片。</li>
<li>PostProcessPass finalPostProcessPass
所有后处理效果处理完后，对最后的图像再进行一次缩放，抗锯齿（FXAA）和颜色转换等。</li>
</ul>
<h3 id="colorgradinglutpass">ColorGradingLutPass</h3>
<p>ColorGradingLutPass用于生成LUT纹理。核心函数：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExecutePass</span>(<span class="params">ScriptableRenderContext context, PassData passData, <span class="keyword">ref</span> RenderingData renderingData, RTHandle internalLutTarget</span>)</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 生LDR和HDR的LUT纹理的材质(LutBuilderLdr.shader和LutBuilderHdr.shader)</span></span><br><span class="line">    <span class="keyword">var</span> cmd = renderingData.commandBuffer;</span><br><span class="line">    <span class="keyword">var</span> lutBuilderLdr = passData.lutBuilderLdr;</span><br><span class="line">    <span class="keyword">var</span> lutBuilderHdr = passData.lutBuilderHdr;</span><br><span class="line">    <span class="keyword">var</span> allowColorGradingACESHDR = passData.allowColorGradingACESHDR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.ColorGradingLUT)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取所有调色组件参数</span></span><br><span class="line">        <span class="keyword">var</span> stack = VolumeManager.instance.stack;</span><br><span class="line">        <span class="keyword">var</span> channelMixer = stack.GetComponent&lt;ChannelMixer&gt;();</span><br><span class="line">        <span class="keyword">var</span> colorAdjustments = stack.GetComponent&lt;ColorAdjustments&gt;();</span><br><span class="line">        <span class="keyword">var</span> curves = stack.GetComponent&lt;ColorCurves&gt;();</span><br><span class="line">        <span class="keyword">var</span> liftGammaGain = stack.GetComponent&lt;LiftGammaGain&gt;();</span><br><span class="line">        <span class="keyword">var</span> shadowsMidtonesHighlights = stack.GetComponent&lt;ShadowsMidtonesHighlights&gt;();</span><br><span class="line">        <span class="keyword">var</span> splitToning = stack.GetComponent&lt;SplitToning&gt;();</span><br><span class="line">        <span class="keyword">var</span> tonemapping = stack.GetComponent&lt;Tonemapping&gt;();</span><br><span class="line">        <span class="keyword">var</span> whiteBalance = stack.GetComponent&lt;WhiteBalance&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">var</span> postProcessingData = <span class="keyword">ref</span> renderingData.postProcessingData;</span><br><span class="line">        <span class="keyword">bool</span> hdr = postProcessingData.gradingMode == ColorGradingMode.HighDynamicRange;</span><br><span class="line">        <span class="keyword">ref</span> CameraData cameraData = <span class="keyword">ref</span> renderingData.cameraData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择材质</span></span><br><span class="line">        <span class="keyword">var</span> material = hdr ? lutBuilderHdr : lutBuilderLdr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备Shader中使用的参数</span></span><br><span class="line">        <span class="keyword">var</span> lmsColorBalance = ColorUtils.ColorBalanceToLMSCoeffs(whiteBalance.temperature.<span class="keyword">value</span>, whiteBalance.tint.<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">var</span> hueSatCon = <span class="keyword">new</span> Vector4(colorAdjustments.hueShift.<span class="keyword">value</span> / <span class="number">360f</span>, colorAdjustments.saturation.<span class="keyword">value</span> / <span class="number">100f</span> + <span class="number">1f</span>, colorAdjustments.contrast.<span class="keyword">value</span> / <span class="number">100f</span> + <span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">        <span class="keyword">var</span> channelMixerR = <span class="keyword">new</span> Vector4(channelMixer.redOutRedIn.<span class="keyword">value</span> / <span class="number">100f</span>, channelMixer.redOutGreenIn.<span class="keyword">value</span> / <span class="number">100f</span>, channelMixer.redOutBlueIn.<span class="keyword">value</span> / <span class="number">100f</span>, <span class="number">0f</span>);</span><br><span class="line">        <span class="keyword">var</span> channelMixerG = <span class="keyword">new</span> Vector4(channelMixer.greenOutRedIn.<span class="keyword">value</span> / <span class="number">100f</span>, channelMixer.greenOutGreenIn.<span class="keyword">value</span> / <span class="number">100f</span>, channelMixer.greenOutBlueIn.<span class="keyword">value</span> / <span class="number">100f</span>, <span class="number">0f</span>);</span><br><span class="line">        <span class="keyword">var</span> channelMixerB = <span class="keyword">new</span> Vector4(channelMixer.blueOutRedIn.<span class="keyword">value</span> / <span class="number">100f</span>, channelMixer.blueOutGreenIn.<span class="keyword">value</span> / <span class="number">100f</span>, channelMixer.blueOutBlueIn.<span class="keyword">value</span> / <span class="number">100f</span>, <span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> shadowsHighlightsLimits = <span class="keyword">new</span> Vector4(</span><br><span class="line">            shadowsMidtonesHighlights.shadowsStart.<span class="keyword">value</span>,</span><br><span class="line">            shadowsMidtonesHighlights.shadowsEnd.<span class="keyword">value</span>,</span><br><span class="line">            shadowsMidtonesHighlights.highlightsStart.<span class="keyword">value</span>,</span><br><span class="line">            shadowsMidtonesHighlights.highlightsEnd.<span class="keyword">value</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> (shadows, midtones, highlights) = ColorUtils.PrepareShadowsMidtonesHighlights(</span><br><span class="line">            shadowsMidtonesHighlights.shadows.<span class="keyword">value</span>,</span><br><span class="line">            shadowsMidtonesHighlights.midtones.<span class="keyword">value</span>,</span><br><span class="line">            shadowsMidtonesHighlights.highlights.<span class="keyword">value</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> (lift, gamma, gain) = ColorUtils.PrepareLiftGammaGain(</span><br><span class="line">            liftGammaGain.lift.<span class="keyword">value</span>,</span><br><span class="line">            liftGammaGain.gamma.<span class="keyword">value</span>,</span><br><span class="line">            liftGammaGain.gain.<span class="keyword">value</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> (splitShadows, splitHighlights) = ColorUtils.PrepareSplitToning(</span><br><span class="line">            splitToning.shadows.<span class="keyword">value</span>,</span><br><span class="line">            splitToning.highlights.<span class="keyword">value</span>,</span><br><span class="line">            splitToning.balance.<span class="keyword">value</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lutHeight = postProcessingData.lutSize;</span><br><span class="line">        <span class="keyword">int</span> lutWidth = lutHeight * lutHeight;</span><br><span class="line">        <span class="keyword">var</span> lutParameters = <span class="keyword">new</span> Vector4(lutHeight, <span class="number">0.5f</span> / lutWidth, <span class="number">0.5f</span> / lutHeight,</span><br><span class="line">            lutHeight / (lutHeight - <span class="number">1f</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置Shader参数</span></span><br><span class="line">        material.SetVector(ShaderConstants._Lut_Params, lutParameters);</span><br><span class="line">        material.SetVector(ShaderConstants._ColorBalance, lmsColorBalance);</span><br><span class="line">        material.SetVector(ShaderConstants._ColorFilter, colorAdjustments.colorFilter.<span class="keyword">value</span>.linear);</span><br><span class="line">        material.SetVector(ShaderConstants._ChannelMixerRed, channelMixerR);</span><br><span class="line">        material.SetVector(ShaderConstants._ChannelMixerGreen, channelMixerG);</span><br><span class="line">        material.SetVector(ShaderConstants._ChannelMixerBlue, channelMixerB);</span><br><span class="line">        material.SetVector(ShaderConstants._HueSatCon, hueSatCon);</span><br><span class="line">        material.SetVector(ShaderConstants._Lift, lift);</span><br><span class="line">        material.SetVector(ShaderConstants._Gamma, gamma);</span><br><span class="line">        material.SetVector(ShaderConstants._Gain, gain);</span><br><span class="line">        material.SetVector(ShaderConstants._Shadows, shadows);</span><br><span class="line">        material.SetVector(ShaderConstants._Midtones, midtones);</span><br><span class="line">        material.SetVector(ShaderConstants._Highlights, highlights);</span><br><span class="line">        material.SetVector(ShaderConstants._ShaHiLimits, shadowsHighlightsLimits);</span><br><span class="line">        material.SetVector(ShaderConstants._SplitShadows, splitShadows);</span><br><span class="line">        material.SetVector(ShaderConstants._SplitHighlights, splitHighlights);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// YRGB curves</span></span><br><span class="line">        material.SetTexture(ShaderConstants._CurveMaster, curves.master.<span class="keyword">value</span>.GetTexture());</span><br><span class="line">        material.SetTexture(ShaderConstants._CurveRed, curves.red.<span class="keyword">value</span>.GetTexture());</span><br><span class="line">        material.SetTexture(ShaderConstants._CurveGreen, curves.green.<span class="keyword">value</span>.GetTexture());</span><br><span class="line">        material.SetTexture(ShaderConstants._CurveBlue, curves.blue.<span class="keyword">value</span>.GetTexture());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Secondary curves</span></span><br><span class="line">        material.SetTexture(ShaderConstants._CurveHueVsHue, curves.hueVsHue.<span class="keyword">value</span>.GetTexture());</span><br><span class="line">        material.SetTexture(ShaderConstants._CurveHueVsSat, curves.hueVsSat.<span class="keyword">value</span>.GetTexture());</span><br><span class="line">        material.SetTexture(ShaderConstants._CurveLumVsSat, curves.lumVsSat.<span class="keyword">value</span>.GetTexture());</span><br><span class="line">        material.SetTexture(ShaderConstants._CurveSatVsSat, curves.satVsSat.<span class="keyword">value</span>.GetTexture());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tonemapping (baked into the lut for HDR)</span></span><br><span class="line">        <span class="keyword">if</span> (hdr)</span><br><span class="line">        &#123;</span><br><span class="line">            material.shaderKeywords = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (tonemapping.mode.<span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> TonemappingMode.Neutral: material.EnableKeyword(ShaderKeywordStrings.TonemapNeutral); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TonemappingMode.ACES: material.EnableKeyword(allowColorGradingACESHDR ? ShaderKeywordStrings.TonemapACES : ShaderKeywordStrings.TonemapNeutral); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>; <span class="comment">// None</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// HDR output is active</span></span><br><span class="line">            <span class="keyword">if</span> (cameraData.isHDROutputActive)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector4 hdrOutputLuminanceParams;</span><br><span class="line">                Vector4 hdrOutputGradingParams;</span><br><span class="line"></span><br><span class="line">                UniversalRenderPipeline.GetHDROutputLuminanceParameters(cameraData.hdrDisplayInformation, cameraData.hdrDisplayColorGamut, tonemapping, <span class="keyword">out</span> hdrOutputLuminanceParams);</span><br><span class="line">                UniversalRenderPipeline.GetHDROutputGradingParameters(tonemapping, <span class="keyword">out</span> hdrOutputGradingParams);</span><br><span class="line"></span><br><span class="line">                material.SetVector(ShaderPropertyId.hdrOutputLuminanceParams, hdrOutputLuminanceParams);</span><br><span class="line">                material.SetVector(ShaderPropertyId.hdrOutputGradingParams, hdrOutputGradingParams);</span><br><span class="line"></span><br><span class="line">                HDROutputUtils.ConfigureHDROutput(material, cameraData.hdrDisplayColorGamut, HDROutputUtils.Operation.ColorConversion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cameraData.xr.StopSinglePass(cmd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cameraData.xr.supportsFoveatedRendering)</span><br><span class="line">            cmd.SetFoveatedRenderingMode(FoveatedRenderingMode.Disabled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染LUT纹理</span></span><br><span class="line">        Blitter.BlitCameraTexture(cmd, internalLutTarget, internalLutTarget, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        cameraData.xr.StartSinglePass(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="postprocesspass">PostProcessPass</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass执行时调用的参数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 内置后处理组件，用于获取用户设置的后处理参数</span></span><br><span class="line">    <span class="keyword">var</span> stack = VolumeManager.instance.stack;</span><br><span class="line">    m_DepthOfField = stack.GetComponent&lt;DepthOfField&gt;();</span><br><span class="line">    m_MotionBlur = stack.GetComponent&lt;MotionBlur&gt;();</span><br><span class="line">    m_PaniniProjection = stack.GetComponent&lt;PaniniProjection&gt;();</span><br><span class="line">    m_Bloom = stack.GetComponent&lt;Bloom&gt;();</span><br><span class="line">    m_LensDistortion = stack.GetComponent&lt;LensDistortion&gt;();</span><br><span class="line">    m_ChromaticAberration = stack.GetComponent&lt;ChromaticAberration&gt;();</span><br><span class="line">    m_Vignette = stack.GetComponent&lt;Vignette&gt;();</span><br><span class="line">    m_ColorLookup = stack.GetComponent&lt;ColorLookup&gt;();</span><br><span class="line">    m_ColorAdjustments = stack.GetComponent&lt;ColorAdjustments&gt;();</span><br><span class="line">    m_Tonemapping = stack.GetComponent&lt;Tonemapping&gt;();</span><br><span class="line">    m_FilmGrain = stack.GetComponent&lt;FilmGrain&gt;();</span><br><span class="line">    m_UseFastSRGBLinearConversion = renderingData.postProcessingData.useFastSRGBLinearConversion;</span><br><span class="line">    m_SupportDataDrivenLensFlare = renderingData.postProcessingData.supportDataDrivenLensFlare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是最后一个Pass?</span></span><br><span class="line">    <span class="keyword">var</span> cmd = renderingData.commandBuffer;</span><br><span class="line">    <span class="keyword">if</span> (m_IsFinalPass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, m_ProfilingRenderFinalPostProcessing))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 渲染最后一个Pass</span></span><br><span class="line">            RenderFinalPass(cmd, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, m_ProfilingRenderPostProcessing))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 渲染后处理（各种后处理组件）效果</span></span><br><span class="line">            Render(cmd, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染各种后处理效果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Render</span>(<span class="params">CommandBuffer cmd, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ref</span> CameraData cameraData = <span class="keyword">ref</span> renderingData.cameraData;</span><br><span class="line">    <span class="keyword">ref</span> ScriptableRenderer renderer = <span class="keyword">ref</span> cameraData.renderer;</span><br><span class="line">    <span class="keyword">bool</span> isSceneViewCamera = cameraData.isSceneViewCamera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查各种后处理是否启用</span></span><br><span class="line">    <span class="keyword">bool</span> useStopNan = cameraData.isStopNaNEnabled &amp;&amp; m_Materials.stopNaN != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">bool</span> useSubPixeMorpAA = cameraData.antialiasing == AntialiasingMode.SubpixelMorphologicalAntiAliasing &amp;&amp; SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2;</span><br><span class="line">    <span class="keyword">var</span> dofMaterial = m_DepthOfField.mode.<span class="keyword">value</span> == DepthOfFieldMode.Gaussian ? m_Materials.gaussianDepthOfField : m_Materials.bokehDepthOfField;</span><br><span class="line">    <span class="keyword">bool</span> useDepthOfField = m_DepthOfField.IsActive() &amp;&amp; !isSceneViewCamera &amp;&amp; dofMaterial != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">bool</span> useLensFlare = !LensFlareCommonSRP.Instance.IsEmpty() &amp;&amp; m_SupportDataDrivenLensFlare;</span><br><span class="line">    <span class="keyword">bool</span> useMotionBlur = m_MotionBlur.IsActive() &amp;&amp; !isSceneViewCamera;</span><br><span class="line">    <span class="keyword">bool</span> usePaniniProjection = m_PaniniProjection.IsActive() &amp;&amp; !isSceneViewCamera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编辑下禁用运动模糊</span></span><br><span class="line">    useMotionBlur = useMotionBlur &amp;&amp; Application.isPlaying;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印不能使用TAA抗锯齿的原因</span></span><br><span class="line">    <span class="keyword">bool</span> useTemporalAA = cameraData.IsTemporalAAEnabled();</span><br><span class="line">    <span class="keyword">if</span> (cameraData.antialiasing == AntialiasingMode.TemporalAntiAliasing &amp;&amp; !useTemporalAA)</span><br><span class="line">        TemporalAA.ValidateAndWarn(<span class="keyword">ref</span> cameraData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余的Pass数量</span></span><br><span class="line">    <span class="keyword">int</span> amountOfPassesRemaining = (useStopNan ? <span class="number">1</span> : <span class="number">0</span>) + (useSubPixeMorpAA ? <span class="number">1</span> : <span class="number">0</span>) + (useDepthOfField ? <span class="number">1</span> : <span class="number">0</span>) + (useLensFlare ? <span class="number">1</span> : <span class="number">0</span>) + (useTemporalAA ? <span class="number">1</span> : <span class="number">0</span>) + (useMotionBlur ? <span class="number">1</span> : <span class="number">0</span>) + (usePaniniProjection ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用SwapBufferMSAA</span></span><br><span class="line">    <span class="keyword">if</span> (m_UseSwapBuffer &amp;&amp; amountOfPassesRemaining &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        renderer.EnableSwapBufferMSAA(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义获取原和目标纹理函数</span></span><br><span class="line">    RTHandle source = m_UseSwapBuffer ? renderer.cameraColorTargetHandle : m_Source;</span><br><span class="line">    RTHandle destination = m_UseSwapBuffer ? renderer.GetCameraColorFrontBuffer(cmd) : <span class="literal">null</span>;</span><br><span class="line">    <span class="function">RTHandle <span class="title">GetSource</span>(<span class="params"></span>)</span> =&gt; source;</span><br><span class="line">    <span class="function">RTHandle <span class="title">GetDestination</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (destination == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_TempTarget, GetCompatibleDescriptor(), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_TempTarget"</span>);</span><br><span class="line">            destination = m_TempTarget;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (destination == m_Source &amp;&amp; m_Descriptor.msaaSamples &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Avoid using m_Source.id as new destination, it may come with a depth buffer that we don't want, may have MSAA that we don't want etc</span></span><br><span class="line">            RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_TempTarget2, GetCompatibleDescriptor(), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_TempTarget2"</span>);</span><br><span class="line">            destination = m_TempTarget2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> destination;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义交换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">ref</span> ScriptableRenderer r</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        --amountOfPassesRemaining;</span><br><span class="line">        <span class="keyword">if</span> (m_UseSwapBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 交换颜色Buffer</span></span><br><span class="line">            r.SwapColorBuffer(cmd);</span><br><span class="line">            source = r.cameraColorTargetHandle;</span><br><span class="line">            <span class="comment">// 最后一个Pass, blit到 MSAA</span></span><br><span class="line">            <span class="keyword">if</span> (amountOfPassesRemaining == <span class="number">0</span> &amp;&amp; !m_HasFinalPass)</span><br><span class="line">                r.EnableSwapBufferMSAA(<span class="literal">true</span>);</span><br><span class="line">            destination = r.GetCameraColorFrontBuffer(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CoreUtils.Swap(<span class="keyword">ref</span> source, <span class="keyword">ref</span> destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    cmd.SetGlobalMatrix(ShaderConstants._FullscreenProjMat, GL.GetGPUProjectionMatrix(Matrix4x4.identity, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用使用Stop Not-a-Number后处理，将浮点数计算结果中的，NaN值修正为正常值（0）</span></span><br><span class="line">    <span class="keyword">if</span> (useStopNan)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.StopNaNs)))</span><br><span class="line">        &#123;</span><br><span class="line">            Blitter.BlitCameraTexture(cmd, GetSource(), GetDestination(), RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, m_Materials.stopNaN, <span class="number">0</span>);</span><br><span class="line">            Swap(<span class="keyword">ref</span> renderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subpixel Morphological Anti-aliasing (SMAA)抗锯齿</span></span><br><span class="line">    <span class="keyword">if</span> (useSubPixeMorpAA)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.SMAA)))</span><br><span class="line">        &#123;</span><br><span class="line">            DoSubpixelMorphologicalAntialiasing(<span class="keyword">ref</span> cameraData, cmd, GetSource(), GetDestination());</span><br><span class="line">            Swap(<span class="keyword">ref</span> renderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 景深效果</span></span><br><span class="line">    <span class="keyword">if</span> (useDepthOfField)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> markerName = m_DepthOfField.mode.<span class="keyword">value</span> == DepthOfFieldMode.Gaussian</span><br><span class="line">            ? URPProfileId.GaussianDepthOfField</span><br><span class="line">            : URPProfileId.BokehDepthOfField;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(markerName)))</span><br><span class="line">        &#123;</span><br><span class="line">            DoDepthOfField(cameraData.camera, cmd, GetSource(), GetDestination(), cameraData.pixelRect);</span><br><span class="line">            Swap(<span class="keyword">ref</span> renderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TAA抗锯齿</span></span><br><span class="line">    <span class="keyword">if</span> (useTemporalAA)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.TemporalAA)))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            TemporalAA.ExecutePass(cmd, m_Materials.temporalAntialiasing, <span class="keyword">ref</span> cameraData, source, destination, m_MotionVectors.rt);</span><br><span class="line">            Swap(<span class="keyword">ref</span> renderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运动模糊</span></span><br><span class="line">    <span class="keyword">if</span> (useMotionBlur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.MotionBlur)))</span><br><span class="line">        &#123;</span><br><span class="line">            DoMotionBlur(cmd, GetSource(), GetDestination(), <span class="keyword">ref</span> cameraData);</span><br><span class="line">            Swap(<span class="keyword">ref</span> renderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Panini projection（帕尼尼投影）后处理是一种用于图形渲染的视觉效果，旨在模拟宽角镜头的视觉效果，同时减少边缘扭曲。</span></span><br><span class="line">    <span class="comment">//这种方法得名于18世纪的意大利画家Giovanni Paolo Panini，他以其精湛的视角和全景画作而闻名。在现代图形渲染中，帕尼尼投影被用来改善宽屏幕或宽视角下的视觉体验，特别是在视频游戏和虚拟现实应用中，为用户提供更自然、更沉浸的视觉体验。</span></span><br><span class="line">    <span class="keyword">if</span> (usePaniniProjection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.PaniniProjection)))</span><br><span class="line">        &#123;</span><br><span class="line">            DoPaniniProjection(cameraData.camera, cmd, GetSource(), GetDestination());</span><br><span class="line">            Swap(<span class="keyword">ref</span> renderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//"Uber"一词通常用来形容一个综合性的或"全包"（all-in-one）的着色器或后处理效果，它集成了多种视觉效果和图形处理技术。</span></span><br><span class="line">    <span class="comment">//这种"Uber后处理效果"可能包括，但不限于，色彩校正、HDR（高动态范围）渲染、Bloom、景深（Depth of Field）、光晕（Lens Flares）、抗锯齿、阴影、光照效果等多个组件。</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.UberPostProcess)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 重置Shader关键值</span></span><br><span class="line">        m_Materials.uber.shaderKeywords = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置Bloom参数</span></span><br><span class="line">        <span class="keyword">bool</span> bloomActive = m_Bloom.IsActive();</span><br><span class="line">        <span class="keyword">if</span> (bloomActive)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.Bloom)))</span><br><span class="line">                SetupBloom(cmd, GetSource(), m_Materials.uber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 镜头光晕</span></span><br><span class="line">        <span class="keyword">if</span> (useLensFlare)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> usePanini;</span><br><span class="line">            <span class="keyword">float</span> paniniDistance;</span><br><span class="line">            <span class="keyword">float</span> paniniCropToFit;</span><br><span class="line">            <span class="keyword">if</span> (m_PaniniProjection.IsActive())</span><br><span class="line">            &#123;</span><br><span class="line">                usePanini = <span class="literal">true</span>;</span><br><span class="line">                paniniDistance = m_PaniniProjection.distance.<span class="keyword">value</span>;</span><br><span class="line">                paniniCropToFit = m_PaniniProjection.cropToFit.<span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                usePanini = <span class="literal">false</span>;</span><br><span class="line">                paniniDistance = <span class="number">1.0f</span>;</span><br><span class="line">                paniniCropToFit = <span class="number">1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.LensFlareDataDrivenComputeOcclusion)))</span><br><span class="line">            &#123;</span><br><span class="line">                LensFlareDataDrivenComputeOcclusion(cameraData.camera, cmd, GetSource(), usePanini, paniniDistance, paniniCropToFit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.LensFlareDataDriven)))</span><br><span class="line">            &#123;</span><br><span class="line">                LensFlareDataDriven(cameraData.camera, cmd, GetSource(), usePanini, paniniDistance, paniniCropToFit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置其他效果参数</span></span><br><span class="line">        <span class="comment">// Lens Distortion后处理效果模拟了真实世界相机镜头中常见的畸变现象，主要是桶形畸变（barrel distortion）和枕形畸变（pincushion distortion</span></span><br><span class="line">        SetupLensDistortion(m_Materials.uber, isSceneViewCamera);</span><br><span class="line">        <span class="comment">//色差（Chromatic Aberration），也称为色彩像差，是一种由于镜头无法将不同颜色的光线聚焦在同一点上而产生的视觉现象。</span></span><br><span class="line">        <span class="comment">//这种现象在图像的边缘部分尤为明显，表现为彩色的晕边，通常是紫色或绿色的边缘。色差通常出现在便宜的镜头或极宽角镜头的照片中，而高质量的镜头设计会尽量减少这种效果。</span></span><br><span class="line">        <span class="comment">//边缘会有类似彩虹的色斑</span></span><br><span class="line">        SetupChromaticAberration(m_Materials.uber);</span><br><span class="line">        <span class="comment">//晕影（Vignette）效果是一种在摄影、视频和图形渲染中常用的视觉效果，其特点是图像边缘相对于中心部分显得更暗，有时也呈现出柔和的过渡。</span></span><br><span class="line">        <span class="comment">//这种效果可以增强图像的焦点，通过在视觉上引导观众的注意力向中心集中，从而提升图像的美感和深度感。</span></span><br><span class="line">        <span class="comment">//在传统摄影中，晕影效果可能由于镜头特性、遮光不足或特定的处理技术而自然产生。而在数字图像处理和图形渲染中，晕影效果通常是通过后处理技术故意添加的。</span></span><br><span class="line">        SetupVignette(m_Materials.uber, cameraData.xr);</span><br><span class="line">        <span class="comment">//色彩分级是另一种强大的图像后处理技术，用于调整图像的整体色调，包括对比度、色温、饱和度等，以达到特定的视觉风格或情绪效果。</span></span><br><span class="line">        <span class="comment">//色彩分级在电影制作、视频游戏和摄影中广泛应用，用于增强视觉叙事或引导观众情绪。将原始颜色通过LUT(颜色查找表)，映射为对应颜色</span></span><br><span class="line">        SetupColorGrading(cmd, <span class="keyword">ref</span> renderingData, m_Materials.uber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Film Grain（胶片颗粒）是指在传统胶片摄影中出现的一种视觉效果，由于胶片上的银盐颗粒大小不一而产生的细微颗粒状纹理。在数码摄影和视频制作中，人们通常通过后期处理添加模拟的胶片颗粒效果，以达到增加质感、增强视觉深度或复古风格的目的。</span></span><br><span class="line">        SetupGrain(<span class="keyword">ref</span> cameraData, m_Materials.uber);</span><br><span class="line">        <span class="comment">//Dithering（抖动）是一种在数字图像处理中常用的技术，用于在有限的颜色深度显示设备上模拟更广泛的颜色范围。这种技术通过在像素之间故意添加噪声或图案，来模拟中间色调或渐变效果，从而减少颜色带（色阶突变）的视觉影响。</span></span><br><span class="line">        SetupDithering(<span class="keyword">ref</span> cameraData, m_Materials.uber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否需要转换回SRGB</span></span><br><span class="line">        <span class="keyword">if</span> (RequireSRGBConversionBlitToBackBuffer(<span class="keyword">ref</span> cameraData))</span><br><span class="line">            m_Materials.uber.EnableKeyword(ShaderKeywordStrings.LinearToSRGBConversion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否需要转换HDR输出</span></span><br><span class="line">        <span class="keyword">bool</span> requireHDROutput = RequireHDROutput(<span class="keyword">ref</span> cameraData);</span><br><span class="line">        <span class="keyword">if</span> (requireHDROutput)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Color space conversion is already applied through color grading, do encoding if uber post is the last pass</span></span><br><span class="line">            <span class="comment">// Otherwise encoding will happen in the final post process pass or the final blit pass</span></span><br><span class="line">            HDROutputUtils.Operation hdrOperation = !m_HasFinalPass &amp;&amp; m_EnableColorEncodingIfNeeded ? HDROutputUtils.Operation.ColorEncoding : HDROutputUtils.Operation.None;</span><br><span class="line">            SetupHDROutput(cameraData.hdrDisplayInformation, cameraData.hdrDisplayColorGamut, m_Materials.uber, hdrOperation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_UseFastSRGBLinearConversion)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Materials.uber.EnableKeyword(ShaderKeywordStrings.UseFastSRGBLinearConversion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DebugHandler debugHandler = GetActiveDebugHandler(<span class="keyword">ref</span> renderingData);</span><br><span class="line">        <span class="keyword">bool</span> resolveToDebugScreen = debugHandler != <span class="literal">null</span> &amp;&amp; debugHandler.WriteToDebugScreenTexture(<span class="keyword">ref</span> cameraData);</span><br><span class="line">        debugHandler?.UpdateShaderGlobalPropertiesForFinalValidationPass(cmd, <span class="keyword">ref</span> cameraData, !m_HasFinalPass &amp;&amp; !resolveToDebugScreen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成参数设置后，blit</span></span><br><span class="line">        <span class="keyword">var</span> colorLoadAction = RenderBufferLoadAction.DontCare;</span><br><span class="line">        <span class="keyword">if</span> (m_Destination == k_CameraTarget &amp;&amp; !cameraData.isDefaultViewport)</span><br><span class="line">            colorLoadAction = RenderBufferLoadAction.Load;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: We rendering to "camera target" we need to get the cameraData.targetTexture as this will get the targetTexture of the camera stack.</span></span><br><span class="line">        <span class="comment">// Overlay cameras need to output to the target described in the base camera while doing camera stack.</span></span><br><span class="line">        RenderTargetIdentifier cameraTargetID = BuiltinRenderTextureType.CameraTarget;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_VR &amp;&amp; ENABLE_XR_MODULE</span></span><br><span class="line">        <span class="keyword">if</span> (cameraData.xr.enabled)</span><br><span class="line">            cameraTargetID = cameraData.xr.renderTarget;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_UseSwapBuffer)</span><br><span class="line">            m_ResolveToScreen = cameraData.resolveFinalTarget || m_Destination.nameID == cameraTargetID || m_HasFinalPass == <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用了SwapBuffer但又不是相机栈的最后</span></span><br><span class="line">        <span class="keyword">if</span> (m_UseSwapBuffer &amp;&amp; !m_ResolveToScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m_HasFinalPass)</span><br><span class="line">            &#123;</span><br><span class="line">                renderer.EnableSwapBufferMSAA(<span class="literal">true</span>);</span><br><span class="line">                destination = renderer.GetCameraColorFrontBuffer(cmd);</span><br><span class="line">            &#125;</span><br><span class="line">            Blitter.BlitCameraTexture(cmd, GetSource(), destination, colorLoadAction, RenderBufferStoreAction.Store, m_Materials.uber, <span class="number">0</span>);</span><br><span class="line">            renderer.ConfigureCameraColorTarget(destination);</span><br><span class="line">            Swap(<span class="keyword">ref</span> renderer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!m_UseSwapBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> firstSource = GetSource();</span><br><span class="line">            Blitter.BlitCameraTexture(cmd, firstSource, GetDestination(), colorLoadAction, RenderBufferStoreAction.Store, m_Materials.uber, <span class="number">0</span>);</span><br><span class="line">            Blitter.BlitCameraTexture(cmd, GetDestination(), m_Destination, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, m_BlitMaterial, m_Destination.rt?.filterMode == FilterMode.Bilinear ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_ResolveToScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将最终结果Blit到调试器的纹理上</span></span><br><span class="line">            <span class="keyword">if</span> (resolveToDebugScreen)</span><br><span class="line">            &#123;</span><br><span class="line">                Blitter.BlitCameraTexture(cmd, GetSource(), debugHandler.DebugScreenColorHandle, RenderBufferLoadAction.Load, RenderBufferStoreAction.Store, m_Materials.uber, <span class="number">0</span>);</span><br><span class="line">                renderer.ConfigureCameraTarget(debugHandler.DebugScreenColorHandle, debugHandler.DebugScreenDepthHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将最终结果Blit到屏幕</span></span><br><span class="line">                RenderTargetIdentifier cameraTarget = cameraData.targetTexture != <span class="literal">null</span> ? <span class="keyword">new</span> RenderTargetIdentifier(cameraData.targetTexture) : cameraTargetID;</span><br><span class="line">                RTHandleStaticHelpers.SetRTHandleStaticWrapper(cameraTarget);</span><br><span class="line">                <span class="keyword">var</span> cameraTargetHandle = RTHandleStaticHelpers.s_RTHandleWrapper;</span><br><span class="line"></span><br><span class="line">                RenderingUtils.FinalBlit(cmd, <span class="keyword">ref</span> cameraData, GetSource(), cameraTargetHandle, colorLoadAction, RenderBufferStoreAction.Store, m_Materials.uber, <span class="number">0</span>);</span><br><span class="line">                renderer.ConfigureCameraColorTarget(cameraTargetHandle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内建后处理shader">内建后处理Shader</h2>
<h3 id="色彩校正色彩调整">色彩校正(色彩调整)</h3>
<p>Unity是将色彩校正信息存在LUT纹理中，最后再查找LUT纹理中的对应颜色来替换当前颜色。Unity内建的色彩校正后处理组件有:WhiteBalance（白平衡）,
ColorAdjustments（颜色调整）, SplitToning（色调分离）,
ChannelMixer(通道混合),
ShadowsMidtonesHighlights(阴影，中间调，高光),LiftGammaGain（提升，伽马，增强）,
ColorCurves（颜色曲线）, Tonemapping（色调映射）。</p>
<p>Neutral
LUT图，是一个“neutral”查找表（LUT）指的是一种不改变色彩的LUT，通常用于作为起点或基准。这种LUT不对图像的色彩、对比度或亮度做任何改变，使得原始图像保持不变。neutral
LUT通常用于测试、校准或作为创建自定义色彩分级预设的基础。</p>
<h4 id="whitebalance白平衡">WhiteBalance（白平衡）</h4>
<p>白平衡是图像处理中的一个重要步骤，目的是校正图像中的色彩，使得白色对象无论在什么样的光线下都被渲染为白色，从而提高图像的色彩准确性。在进行白平衡处理时，LMS系数用于调整图像中的颜色分量，以反映光源下的真实颜色。不同环境色温下拍出来的拍色是有一定差异的，白平衡的目的就是通过后期的手段将白色还原成白色。</p>
<p>色温图：</p>
<figure>
<img src="/images/unity/graphics/se_wu.png" alt="色温图" />
<figcaption aria-hidden="true">色温图</figcaption>
</figure>
<p>在调色的过程中，如果图片本身偏高色温（蓝色），那么就要补偿低色温（橙色），来达到白色。如果想营造某种艺术效果，可以根据需求调整。</p>
<p><strong>过程：</strong></p>
<ol type="1">
<li>将白平衡的色温(temperature)和色调(tint)参数转换成LMS系数</li>
<li>将原颜色在LMS空间应用白平衡参数</li>
<li>最后将LMS空间中的值转回线性RGB空间</li>
</ol>
<p><strong>代码：</strong>
色温(temperature)和色调(tint)参数转换成LMS系数: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">ColorBalanceToLMSCoeffs</span>(<span class="params"><span class="keyword">float</span> temperature, <span class="keyword">float</span> tint</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将色温和色调映射到，大约[-1.5;1.5]的范围，works best</span></span><br><span class="line">    <span class="keyword">float</span> t1 = temperature / <span class="number">65f</span>;</span><br><span class="line">    <span class="keyword">float</span> t2 = tint / <span class="number">65f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参考白点（D65）的的xy色度值, D65指的时，色温6500K(开尔文)是纯白的色度值</span></span><br><span class="line">    <span class="comment">// D65白点的色图值：x = 0.3127, y = 0.3290</span></span><br><span class="line">    <span class="comment">// 具体计算公式参见维基百科的[CIE 1931 XYZ色彩空间](https://zh.wikipedia.org/wiki/CIE_1931%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4)</span></span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">0.31271f</span> - t1 * (t1 &lt; <span class="number">0f</span> ? <span class="number">0.1f</span> : <span class="number">0.05f</span>);</span><br><span class="line">    <span class="keyword">float</span> y = StandardIlluminantY(x) + t2 * <span class="number">0.05f</span>;   <span class="comment">// 2.87f * x - 3f * x * x - 0.27509507f</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算LMS空间中的系数。</span></span><br><span class="line">    <span class="keyword">var</span> w1 = <span class="keyword">new</span> Vector3(<span class="number">0.949237f</span>, <span class="number">1.03542f</span>, <span class="number">1.08728f</span>); <span class="comment">// D65白点对应的LMS系数</span></span><br><span class="line">    <span class="keyword">var</span> w2 = CIExyToLMS(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector3(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将CIExy转换到LMS空间下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">CIExyToLMS</span>(<span class="params"><span class="keyword">float</span> x, <span class="keyword">float</span> y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 三刺值</span></span><br><span class="line">    <span class="keyword">float</span> Y = <span class="number">1f</span>;</span><br><span class="line">    <span class="keyword">float</span> X = Y * x / y;</span><br><span class="line">    <span class="keyword">float</span> Z = Y * (<span class="number">1f</span> - x - y) / y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三刺值到LMS的变化矩阵</span></span><br><span class="line">    <span class="keyword">float</span> L = <span class="number">0.7328f</span> * X + <span class="number">0.4296f</span> * Y - <span class="number">0.1624f</span> * Z;</span><br><span class="line">    <span class="keyword">float</span> M = <span class="number">-0.7036f</span> * X + <span class="number">1.6975f</span> * Y + <span class="number">0.0061f</span> * Z;</span><br><span class="line">    <span class="keyword">float</span> S = <span class="number">0.0030f</span> * X + <span class="number">0.0136f</span> * Y + <span class="number">0.9834f</span> * Z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector3(L, M, S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在LMS空间中计算白平衡</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前Lut位置的Neutral值</span></span><br><span class="line">float3 colorLMS = LinearToLMS(colorLinear);</span><br><span class="line"><span class="comment">// 计算白平衡</span></span><br><span class="line">colorLMS *= _ColorBalance.xyz;</span><br><span class="line"><span class="comment">// 转换回线性空间，进行后续的计算</span></span><br><span class="line">colorLinear = LMSToLinear(colorLMS);</span><br></pre></td></tr></table></figure>
<h4 id="coloradjustments颜色调整">ColorAdjustments（颜色调整）</h4>
<p>Color
Adjustments是图像处理和图形设计中常见的一组技术，用于修改和优化图像的色彩属性，包括亮度、对比度、饱和度、色调、曝光等。这些调整能够帮助图像更好地传达预期的视觉效果或情绪，提升图像质量，或者适应特定的显示设备和环境。</p>
<ul>
<li><strong>对比度(Contrast)</strong>：调整图像明暗区域之间的差异，增加对比度会使图像的明暗区域更加分明，而降低对比度则会使图像看起来更加平坦。</li>
<li><strong>色调(Hue)</strong>：改变图像中的色彩平衡，常用于为图像创建特定的色彩风格或修正图像的色温。</li>
<li><strong>饱和度(Saturation)</strong>：调整图像中颜色的强度，饱和度高的图像色彩会更加鲜明，而饱和度低的图像则色彩更加柔和。</li>
<li><strong>亮度(Brightness)</strong>：调整图像的明暗程度，使图像看起来更亮或更暗。</li>
<li><strong>曝光(Exposure)</strong>：模拟调整摄影中的曝光效果，可以使图像整体变亮或变暗，用于修正过曝或欠曝的图像</li>
</ul>
<p><strong>对比度</strong>：</p>
<p>过程：</p>
<ol type="1">
<li>将颜色转换到对数（LogC）空间</li>
<li>应用对比度调节公式， 如下</li>
<li>将结果转换回线性(Linear)空间</li>
</ol>
<p><span class="math inline">\((color - middleGray) * contrast +
middleGray\)</span></p>
<p>说明： color : 需要调节的颜色 middleGray :
中性灰色的定义（0.5或ACES定义的0.4135884） contrast ：对比度调节系数</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 colorLog = LinearToLogC(colorLinear);</span><br><span class="line">colorLog = (colorLog - ACEScc_MIDGRAY) * _HueSatCon.z + ACEScc_MIDGRAY;</span><br><span class="line">colorLinear = LogCToLinear(colorLog);</span><br></pre></td></tr></table></figure>
<p><strong>色调</strong>：</p>
<p>过程：</p>
<ol type="1">
<li>将RGB颜色转换到HSV色彩空间，</li>
<li>调整饱和度H值，</li>
<li>将结果转换回RGB空间</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 hsv = RgbToHsv(colorLinear);</span><br><span class="line"><span class="keyword">float</span> hue = hsv.x + _HueSatCon.x;</span><br><span class="line"> colorLinear = HsvToRgb(hsv);</span><br></pre></td></tr></table></figure>
<p><strong>饱和度</strong>：</p>
<p>过程：</p>
<ol type="1">
<li>将RGB颜色转换到HSV色彩空间，</li>
<li>调整饱和度S值，</li>
<li>将结果转换回RGB空间</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">luma = GetLuminance(colorLinear);    <span class="comment">// real3(0.2126729, 0.7151522, 0.0721750)  ACES:half3(0.272229, 0.674082, 0.0536895)</span></span><br><span class="line">colorLinear = luma.xxx + (_HueSatCon.yyy * satMult) * (colorLinear - luma.xxx);</span><br></pre></td></tr></table></figure>
<p><strong>曝光和亮度</strong></p>
<p><strong>曝光（Exposure）</strong> 和
<strong>亮度（Brightness）</strong>
是两个在摄影、视频制作和图像处理中常用的术语，它们描述图像的光照特性，但指代的概念和调整方式有所不同。</p>
<p><strong>曝光（Exposure）</strong>
曝光是指在拍摄过程中，光线作用在相机传感器上的量，这个量由光圈大小（Aperture）、快门速度（Shutter
Speed）和ISO感光度（ISO
Sensitivity）三个基本相机设置共同决定。曝光决定了图像最初捕捉到的光量，是摄影的一个基础概念。</p>
<p><strong>光圈：</strong>控制镜头进光量的大小。
<strong>快门速度：</strong>控制光线照射在传感器上的时间长度。
<strong>ISO感光度：</strong>控制传感器对光线的敏感度。</p>
<p>正确的曝光是指在特定的拍摄条件下，选取适当的光圈、快门速度和ISO设置，以便传感器接收到足够的光量，使得图像既不过曝（太亮，丢失细节）也不欠曝（太暗，缺乏细节）。
曝光调节模拟了在拍摄阶段改变光量的效果，它可以更加广泛地影响图像的整体明暗，包括极亮和极暗的区域。曝光调节通常对图像的动态范围有较大的影响，可能会导致亮部过曝或暗部过暗而丢失细节。在数学上，曝光调节可能被模拟为对图像每个像素值的乘法调整：
<span class="math display">\[C^{&#39;} = C x 2^{\delta EV} \]</span></p>
<ul>
<li><span class="math inline">\(C^{&#39;}\)</span>
是调整后的像素值。</li>
<li><span class="math inline">\(C\)</span> 是原始像素值</li>
<li><span class="math inline">\(\delta EV\)</span>
是曝光值的变化，以停（stop）为单位。正值表示增加曝光，负值表示减少曝光。每增加1个停，图像的亮度翻倍；每减少1个停，图像的亮度减半。</li>
</ul>
<p><strong>亮度（Brightness）</strong></p>
<p>亮度是指图像看起来的光线亮度感觉，是图像处理和显示设备中的一个概念，通常用于描述图像的视觉感受。亮度调整通常在图像已经被捕捉并需要在后期处理时改变其整体明暗程度时进行。
亮度调节可以通过多种方式在图像处理中实现。最直接的方法是对图像的每个像素的亮度分量进行调整。下面是一些基本的亮度调节方法：</p>
<p><strong>线性亮度调整</strong></p>
<p>最简单的亮度调整方法是对图像的每个像素值直接加上一个固定的量。对于RGB图像，这意味着对R、G、B三个通道的值都进行相同的调整：</p>
<p><span class="math display">\[C^{&#39;} = C + \delta \]</span></p>
<ul>
<li><span class="math inline">\(C^{&#39;}\)</span> 是调整后的颜色值</li>
<li><span class="math inline">\(C\)</span> 是原始颜色值，</li>
<li><span class="math inline">\(\delta\)</span>
是要调整的亮度量（可以为正值或负值）。</li>
</ul>
<p><strong>保持色彩比例的亮度调整</strong>
为了避免在调整亮度时改变色彩的相对比例（即色调和饱和度），可以先将RGB颜色转换到一个能够分离亮度信息的色彩空间（如HSV或HSL），只对亮度分量进行调整，然后再转换回RGB空间。亮度分量的调整可以表示为：
<span class="math display">\[V^{&#39;} = V + \delta \]</span></p>
<ul>
<li><span class="math inline">\(V^{&#39;}\)</span> 是调整后的亮度值</li>
<li><span class="math inline">\(V\)</span> 是原始的亮度值</li>
<li><span class="math inline">\(\delta\)</span> 是要调整的亮度量</li>
</ul>
<p><strong>伽马校正亮度调整</strong>
伽马校正提供了一种更复杂的亮度调整方式，可以更符合人眼对亮度的非线性感知：</p>
<p><span class="math display">\[C^{&#39;}= 255x(\frac{C}{255})^{1/
\gamma}\]</span></p>
<ul>
<li><span class="math inline">\(C^{&#39;}\)</span> 是调整后的颜色值</li>
<li><span class="math inline">\(C\)</span> 是原始颜色值</li>
<li><span class="math inline">\(\gamma\)</span>
是伽马校正值。通过调整<span
class="math inline">\(\gamma\)</span>值，可以在增亮或减暗图像的同时保持细节的自然外观。</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><strong>计算方式：</strong>
曝光调节通过乘法影响像素值，而亮度调节通过加法改变像素值。</li>
<li><strong>影响范围：</strong>
曝光调节可以更显著地改变图像的整体亮度，包括最亮和最暗的区域，可能会导致亮部或暗部细节的丢失。亮度调节则更加温和，通常不会导致亮部或暗部细节的丢失，但对动态范围的影响较小。</li>
<li><strong>应用场景：</strong>
在需要大幅度调整图像明暗，模拟不同曝光效果时，使用曝光调节；在需要微调图像亮度，保持大部分细节时，使用亮度调节。</li>
</ul>
<p><strong>SplitToning（色调分离）</strong></p>
<p>Split
Toning调节可以通过多种方法实现，特别是在处理数字图像时。基础思路涉及分别向图像的阴影（Shadows）和高光（Highlights）部分应用不同的色调，而保持中间调的颜色相对不变。</p>
<p><strong>过程：</strong></p>
<ol type="1">
<li>为了和Adobe产品的计算方式一样，要将线性颜色转换到Gamma</li>
<li>计算像素的亮度值，根据亮度值,确定分离后的阴影和高光颜色</li>
<li>将分离出来的阴影和高光颜色与原颜色使用柔光的混合模式进行混合</li>
<li>最后将Gamma空间颜色转换回线性空间</li>
</ol>
<p><strong>公式：</strong></p>
<p><strong>基础公式</strong>
假设我们有两个目标色调：一个用于阴影部分<span
class="math inline">\(C_{shadow}\)</span>，另一个用于高光部分 <span
class="math inline">\(C_{highlight}\)</span>。图像中每个像素点的最终色调<span
class="math inline">\(C_{final}\)</span>可以通过以下方式计算得出：</p>
<p><span class="math display">\[C_{final} = w * C_{shadow} +
(1-w)*C_{highlight}\]</span></p>
<p>其中，<span
class="math inline">\(w\)</span>是一个根据像素亮度确定的权重，用于控制该像素更接近阴影色调还是高光色调。权重<span
class="math inline">\(w\)</span>的计算可以通过多种方式实现，一种简单的方法是使用像素亮度的线性或非线性函数。</p>
<p><strong>权重计算</strong> 权重<span
class="math inline">\(w\)</span>可以根据像素的亮度<span
class="math inline">\(L\)</span>（通常是从0到1）进行计算，其中低亮度值接近阴影，高亮度值接近高光。一个简单的线性模型是：</p>
<p><span class="math display">\[w =
\frac{L-L_{min}}{L_{max}-L_{min}}\]</span></p>
<p>​这里，​<span class="math inline">\(L_{min}\)</span>和<span
class="math inline">\(L_{max}\)</span>分别表示图像中亮度的最小和最大值，用于确定阴影和高光的界限。为了更平滑的过渡，也可以使用基于S型函数的模型，如：</p>
<p><span class="math display">\[w =
\frac{1}{1+e^{-(L-L_{mid})*k}}\]</span></p>
<p>这里，<span
class="math inline">\(L_{mid}\)</span>是阴影和高光之间的中间亮度值，<span
class="math inline">\(k\)</span>是控制过渡平滑程度的参数。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽管与直觉相反，但让色调分离的工作方式与Adobe中的工作方式相同</span></span><br><span class="line"><span class="comment">// 我们必须在伽玛空间中进行所有数学运算的产品</span></span><br><span class="line"><span class="comment">// 亮度调节参数</span></span><br><span class="line"><span class="keyword">float</span> balance = _SplitShadows.w;</span><br><span class="line"><span class="comment">// 转换到Gamma空间</span></span><br><span class="line">float3 colorGamma = PositivePow(colorLinear, <span class="number">1.0</span> / <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算像素本身的亮度 + 调节亮度</span></span><br><span class="line"><span class="keyword">float</span> luma = saturate(GetLuminance(saturate(colorGamma)) + balance);</span><br><span class="line"><span class="comment">// 当luma变小时，会把大部分像素颜色往阴影颜色拉，否者像高光颜色拉</span></span><br><span class="line">float3 splitShadows = lerp((<span class="number">0.5</span>).xxx, _SplitShadows.xyz, <span class="number">1.0</span> - luma);</span><br><span class="line">float3 splitHighlights = lerp((<span class="number">0.5</span>).xxx, _SplitHighlights.xyz, luma);</span><br><span class="line"><span class="comment">// 用柔光混合模式混合原颜色和阴影色，以及高光色</span></span><br><span class="line">colorGamma = SoftLight(colorGamma, splitShadows);</span><br><span class="line">colorGamma = SoftLight(colorGamma, splitHighlights);</span><br><span class="line"><span class="comment">// 将颜色转换回线性空间</span></span><br><span class="line">colorLinear = PositivePow(colorGamma, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于色调分离的柔光混合模式。 只要 `blend` 为 [0;1] 即可在 HDR 中工作</span></span><br><span class="line"><span class="function">float3 <span class="title">SoftLight</span><span class="params">(float3 base, float3 blend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float3 r1 = <span class="number">2.0</span> * base * blend + base * base * (<span class="number">1.0</span> - <span class="number">2.0</span> * blend);</span><br><span class="line">    float3 r2 = <span class="built_in">sqrt</span>(base) * (<span class="number">2.0</span> * blend - <span class="number">1.0</span>) + <span class="number">2.0</span> * base * (<span class="number">1.0</span> - blend);</span><br><span class="line">    float3 t = <span class="built_in">step</span>(<span class="number">0.5</span>, blend);</span><br><span class="line">    <span class="keyword">return</span> r2 * t + (<span class="number">1.0</span> - t) * r1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="channelmixer通道混合">ChannelMixer(通道混合)</h4>
<p><strong>过程：</strong></p>
<p>Channel
Mixer，它允许用户调整图像中红色、绿色和蓝色通道的比例，以此来改变图像的总体色彩。通过混合这些颜色通道，用户可以实现广泛的色彩效果，包括颜色校正、黑白转换、色彩强化等。在数字图像处理中，一个像素的颜色通常由红色（R）、绿色（G）、蓝色（B）三个颜色通道的值组合而成。Channel
Mixer
允许用户调整这些颜色通道的输出比例，通过修改每个通道对最终图像颜色的贡献度来改变图像的颜色平衡。</p>
<p><strong>公式：</strong></p>
<p><span class="math inline">\(R_{out} = R_{in} * R_x + G_{in} * G_y +
B_{in} * B_z\)</span> <span class="math inline">\(G_{out} = R_{in} * R_x
+ G_{in} * G_y + B_{in} * B_z\)</span> <span
class="math inline">\(B_{out} = R_{in} * R_x + G_{in} * G_y + B_{in} *
B_z\)</span></p>
<p>x,y和z分别是红，绿和蓝色通道的混合系数</p>
<p><strong>代码：</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> colorLinear &#x3D; float3(</span><br><span class="line">    dot(colorLinear, _ChannelMixerRed.xyz),     &#x2F;&#x2F; R</span><br><span class="line">    dot(colorLinear, _ChannelMixerGreen.xyz),   &#x2F;&#x2F; G</span><br><span class="line">    dot(colorLinear, _ChannelMixerBlue.xyz)     &#x2F;&#x2F; B</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4
id="shadowsmidtoneshighlights阴影中间调高光">ShadowsMidtonesHighlights(阴影，中间调，高光)</h4>
<p>在图像处理和色彩分级中，对阴影（Shadows）、中间调（Midtones）、高光（Highlights）的调节是一种常见的技术，用于细致调整图像的色调平衡和对比度。这种方法允许你分别调整图像中暗部、中亮部和亮部的亮度、色彩和饱和度，以达到更为精细的视觉效果。</p>
<p><strong>过程：</strong></p>
<ol type="1">
<li>分离阴影、中间调、高光：首先，基于像素的亮度值将图像分割成阴影、中间调和高光三个部分。这通常通过设置亮度阈值来实现，不同的亮度范围对应于阴影、中间调和高光。</li>
<li>应用调节：对每个部分（阴影、中间调、高光）分别应用亮度、色彩和饱和度的调节。调节可以是线性的，也可以是基于特定曲线的，如S型曲线。</li>
</ol>
<p><strong>公式：</strong></p>
<p>虽然具体的调节公式可能根据不同的软件和实现而异，但可以用以下基础形式来近似描述：</p>
<p><span class="math display">\[C^{&#39;} = C + \Delta C x
W(L)\]</span></p>
<p>其中: - <span
class="math inline">\(C^{&#39;}\)</span>是调整后的颜色值。 - <span
class="math inline">\(C\)</span>是原颜色。 - <span
class="math inline">\(\Delta
C\)</span>是想应用的调整量，可以是亮度、色彩或饱和度的变化。 - <span
class="math inline">\(W(L)\)</span> 是一个基于像素亮度<span
class="math inline">\(L\)</span>的权重函数，用于确定该像素属于阴影、中间调还是高光，以及应该如何应用调整。</p>
<p><strong>代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">static</span> (<span class="params">Vector4, Vector4, Vector4</span>) <span class="title">PrepareShadowsMidtonesHighlights</span>(<span class="params"><span class="keyword">in</span> Vector4 inShadows, <span class="keyword">in</span> Vector4 inMidtones, <span class="keyword">in</span> Vector4 inHighlights</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="comment">// 根据权重设置最终应用的阴影颜色值</span></span><br><span class="line">    <span class="keyword">var</span> shadows = inShadows;</span><br><span class="line">    shadows.x = Mathf.GammaToLinearSpace(shadows.x);</span><br><span class="line">    shadows.y = Mathf.GammaToLinearSpace(shadows.y);</span><br><span class="line">    shadows.z = Mathf.GammaToLinearSpace(shadows.z);</span><br><span class="line">    weight = shadows.w * (Mathf.Sign(shadows.w) &lt; <span class="number">0f</span> ? <span class="number">1f</span> : <span class="number">4f</span>);</span><br><span class="line">    shadows.x = Mathf.Max(shadows.x + weight, <span class="number">0f</span>);</span><br><span class="line">    shadows.y = Mathf.Max(shadows.y + weight, <span class="number">0f</span>);</span><br><span class="line">    shadows.z = Mathf.Max(shadows.z + weight, <span class="number">0f</span>);</span><br><span class="line">    shadows.w = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据权重设置最终应用的中间调颜色值</span></span><br><span class="line">    <span class="keyword">var</span> midtones = inMidtones;</span><br><span class="line">    midtones.x = Mathf.GammaToLinearSpace(midtones.x);</span><br><span class="line">    midtones.y = Mathf.GammaToLinearSpace(midtones.y);</span><br><span class="line">    midtones.z = Mathf.GammaToLinearSpace(midtones.z);</span><br><span class="line">    weight = midtones.w * (Mathf.Sign(midtones.w) &lt; <span class="number">0f</span> ? <span class="number">1f</span> : <span class="number">4f</span>);</span><br><span class="line">    midtones.x = Mathf.Max(midtones.x + weight, <span class="number">0f</span>);</span><br><span class="line">    midtones.y = Mathf.Max(midtones.y + weight, <span class="number">0f</span>);</span><br><span class="line">    midtones.z = Mathf.Max(midtones.z + weight, <span class="number">0f</span>);</span><br><span class="line">    midtones.w = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据权重设置最终应用的高光颜色值</span></span><br><span class="line">    <span class="keyword">var</span> highlights = inHighlights;</span><br><span class="line">    highlights.x = Mathf.GammaToLinearSpace(highlights.x);</span><br><span class="line">    highlights.y = Mathf.GammaToLinearSpace(highlights.y);</span><br><span class="line">    highlights.z = Mathf.GammaToLinearSpace(highlights.z);</span><br><span class="line">    weight = highlights.w * (Mathf.Sign(highlights.w) &lt; <span class="number">0f</span> ? <span class="number">1f</span> : <span class="number">4f</span>);</span><br><span class="line">    highlights.x = Mathf.Max(highlights.x + weight, <span class="number">0f</span>);</span><br><span class="line">    highlights.y = Mathf.Max(highlights.y + weight, <span class="number">0f</span>);</span><br><span class="line">    highlights.z = Mathf.Max(highlights.z + weight, <span class="number">0f</span>);</span><br><span class="line">    highlights.w = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (shadows, midtones, highlights);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算亮度值</span></span><br><span class="line">luma = GetLuminance(colorLinear);</span><br><span class="line"><span class="comment">// 计算阴影，中间调和高光的调节系数（最终只有一个部分的系数为1，其他的都为0）</span></span><br><span class="line"><span class="keyword">float</span> shadowsFactor = <span class="number">1.0</span> - smoothstep(_ShaHiLimits.x, _ShaHiLimits.y, luma);</span><br><span class="line"><span class="keyword">float</span> highlightsFactor = smoothstep(_ShaHiLimits.z, _ShaHiLimits.w, luma);</span><br><span class="line"><span class="keyword">float</span> midtonesFactor = <span class="number">1.0</span> - shadowsFactor - highlightsFactor;</span><br><span class="line"><span class="comment">// 计算最终的颜色</span></span><br><span class="line">colorLinear = colorLinear * _Shadows.xyz * shadowsFactor</span><br><span class="line">    + colorLinear * _Midtones.xyz * midtonesFactor</span><br><span class="line">    + colorLinear * _Highlights.xyz * highlightsFactor;</span><br></pre></td></tr></table></figure>
<h4
id="liftgammagain提升伽马增强">LiftGammaGain（提升，伽马，增强）</h4>
<p>Lift Gamma
Gain是一种常用于色彩分级和图像调整中的技术，特别是在视频和电影后期制作中。它允许用户独立调整图像的阴影（Lift）、中间调（Gamma）和高光（Gain）部分，提供了对图像色彩和对比度的精细控制。这三个参数共同作用，可以实现复杂的视觉效果和色彩调整。</p>
<p><strong>原理：</strong></p>
<ul>
<li>Lift（提升）：主要影响图像的暗部（阴影）。调整Lift会向上或向下移动色彩的黑点，从而改变图像的整体明暗度，而不大幅影响高光。</li>
<li>Gamma（伽马）：影响图像的中间调。调整Gamma值是对图像中间亮度级别的调整，可以在不显著改变高光和阴影的情况下，增加或减少图像的对比度。</li>
<li>Gain（增益）：主要影响图像的亮部（高光）。调整Gain会增加或减少图像高光部分的亮度，而对暗部的影响较小。</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">static</span> (<span class="params">Vector4, Vector4, Vector4</span>) <span class="title">PrepareLiftGammaGain</span>(<span class="params"><span class="keyword">in</span> Vector4 inLift, <span class="keyword">in</span> Vector4 inGamma, <span class="keyword">in</span> Vector4 inGain</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lift = inLift;</span><br><span class="line">    lift.x = Mathf.GammaToLinearSpace(lift.x) * <span class="number">0.15f</span>;</span><br><span class="line">    lift.y = Mathf.GammaToLinearSpace(lift.y) * <span class="number">0.15f</span>;</span><br><span class="line">    lift.z = Mathf.GammaToLinearSpace(lift.z) * <span class="number">0.15f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> lumLift = Luminance(lift);</span><br><span class="line">    lift.x = lift.x - lumLift + lift.w;</span><br><span class="line">    lift.y = lift.y - lumLift + lift.w;</span><br><span class="line">    lift.z = lift.z - lumLift + lift.w;</span><br><span class="line">    lift.w = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gamma = inGamma;</span><br><span class="line">    gamma.x = Mathf.GammaToLinearSpace(gamma.x) * <span class="number">0.8f</span>;</span><br><span class="line">    gamma.y = Mathf.GammaToLinearSpace(gamma.y) * <span class="number">0.8f</span>;</span><br><span class="line">    gamma.z = Mathf.GammaToLinearSpace(gamma.z) * <span class="number">0.8f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> lumGamma = Luminance(gamma);</span><br><span class="line">    gamma.w += <span class="number">1f</span>;</span><br><span class="line">    gamma.x = <span class="number">1f</span> / Mathf.Max(gamma.x - lumGamma + gamma.w, <span class="number">1e-03</span>f);</span><br><span class="line">    gamma.y = <span class="number">1f</span> / Mathf.Max(gamma.y - lumGamma + gamma.w, <span class="number">1e-03</span>f);</span><br><span class="line">    gamma.z = <span class="number">1f</span> / Mathf.Max(gamma.z - lumGamma + gamma.w, <span class="number">1e-03</span>f);</span><br><span class="line">    gamma.w = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gain = inGain;</span><br><span class="line">    gain.x = Mathf.GammaToLinearSpace(gain.x) * <span class="number">0.8f</span>;</span><br><span class="line">    gain.y = Mathf.GammaToLinearSpace(gain.y) * <span class="number">0.8f</span>;</span><br><span class="line">    gain.z = Mathf.GammaToLinearSpace(gain.z) * <span class="number">0.8f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> lumGain = Luminance(gain);</span><br><span class="line">    gain.w += <span class="number">1f</span>;</span><br><span class="line">    gain.x = gain.x - lumGain + gain.w;</span><br><span class="line">    gain.y = gain.y - lumGain + gain.w;</span><br><span class="line">    gain.z = gain.z - lumGain + gain.w;</span><br><span class="line">    gain.w = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (lift, gamma, gain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colorLinear = colorLinear * _Gain.xyz + _Lift.xyz;</span><br><span class="line">colorLinear = sign(colorLinear) * <span class="built_in">pow</span>(<span class="built_in">abs</span>(colorLinear), _Gamma.xyz);</span><br></pre></td></tr></table></figure>
<h4 id="colorcurves颜色曲线">ColorCurves（颜色曲线）</h4>
<p>颜色曲线（Color
Curves）是一种强大的工具，它允许用户通过调整色彩通道的输入和输出值之间的曲线关系来精细控制图像的亮度、对比度、色彩平衡和色调。色彩曲线提供了比基本亮度和对比度调节更细致和灵活的控制方式。</p>
<p>Unity的ColorCurves提供了两种类型的曲线：色彩映射曲线和YRGB曲线</p>
<p><strong>色彩映射曲线</strong>
色彩映射曲线是在图像和视频后期处理中使用的常见方法，用于细粒度地调整色彩属性。尽管每种调节关注的色彩属性不同，它们都旨在通过不同的映射关系来改变图像的色彩表现。其中包括：HueVsHue、HueVsSat、SatVsSat和LumVsSat</p>
<ol type="1">
<li><p><strong>HueVsHue</strong>：这是色相对色相的调整，允许你根据原始色相改变色相。例如，可以将所有的绿色调整为更偏蓝的色相。</p></li>
<li><p><strong>HueVsSat</strong>：这是色相对饱和度的调整，允许你基于图像中特定色相的存在来增加或减少饱和度。例如，可以仅增加红色的饱和度而不影响其他色彩。</p></li>
<li><p><strong>SatVsSat</strong>：这是饱和度对饱和度的调整，允许你根据原始饱和度改变饱和度级别。这可以用来增强色彩鲜艳度或者使图像看起来更自然。</p></li>
<li><p><strong>LumVsSat</strong>：这是亮度对饱和度的调整，允许你基于像素的亮度值来增加或减少饱和度。例如，可以减少亮度最高区域的饱和度来防止色彩过饱和。</p></li>
</ol>
<p><strong>YRGB曲线</strong>
YRGB曲线是一种用于图像处理和颜色校正中的工具，它允许用户分别调整图像中的亮度（Y）和红色（R）、绿色（G）、蓝色（B）三个颜色通道。通过调整这些曲线，可以影响图像的整体色调、对比度和颜色平衡。</p>
<ul>
<li><p><strong>Y曲线</strong>：Y通常代表亮度（Luminance）或亮度信息，通过调整Y曲线，可以不影响色彩的情况下调整图像的亮暗程度。这是因为Y曲线单独控制亮度信息，不直接改变色彩。</p></li>
<li><p><strong>RGB曲线</strong>：RGB分别代表红色、绿色和蓝色三个颜色通道。通过独立调整每个颜色通道的曲线，可以控制图像中特定颜色的饱和度和色调。例如，提高红色曲线可以使图像看起来更暖，而调低蓝色曲线则会使图像看起来更凉。</p></li>
</ul>
<p><strong>过程：</strong></p>
<ol type="1">
<li>将曲线值映射到大小128*1的纹理中，曲线值离散到128个值存在纹理。</li>
<li>在Shader中计算Lut中的值。</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 色彩映射曲线</span></span><br><span class="line"><span class="keyword">float</span> satMult;</span><br><span class="line">float3 hsv = RgbToHsv(colorLinear);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hue Vs Sat</span></span><br><span class="line">    satMult = EvaluateCurve(_CurveHueVsSat, hsv.x) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sat Vs Sat</span></span><br><span class="line">    satMult *= EvaluateCurve(_CurveSatVsSat, hsv.y) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lum Vs Sat</span></span><br><span class="line">    satMult *= EvaluateCurve(_CurveLumVsSat, Luminance(colorLinear)) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hue Vs Hue</span></span><br><span class="line">    <span class="keyword">float</span> hue = hsv.x + _HueSatCon.x;</span><br><span class="line">    <span class="keyword">float</span> offset = EvaluateCurve(_CurveHueVsHue, hue) - <span class="number">0.5</span>;</span><br><span class="line">    hue += offset;</span><br><span class="line">    hsv.x = RotateHue(hue, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">colorLinear = HsvToRgb(hsv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算饱和度</span></span><br><span class="line">luma = GetLuminance(colorLinear);</span><br><span class="line">colorLinear = luma.xxx + (_HueSatCon.yyy * satMult) * (colorLinear - luma.xxx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// YRGB curves</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> kHalfPixel = (<span class="number">1.0</span> / <span class="number">128.0</span>) / <span class="number">2.0</span>;</span><br><span class="line">    float3 c = colorLinear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y (master)</span></span><br><span class="line">    c += kHalfPixel.xxx;</span><br><span class="line">    <span class="keyword">float</span> mr = EvaluateCurve(_CurveMaster, c.r);</span><br><span class="line">    <span class="keyword">float</span> mg = EvaluateCurve(_CurveMaster, c.g);</span><br><span class="line">    <span class="keyword">float</span> mb = EvaluateCurve(_CurveMaster, c.b);</span><br><span class="line">    c = float3(mr, mg, mb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RGB</span></span><br><span class="line">    c += kHalfPixel.xxx;</span><br><span class="line">    <span class="keyword">float</span> r = EvaluateCurve(_CurveRed, c.r);</span><br><span class="line">    <span class="keyword">float</span> g = EvaluateCurve(_CurveGreen, c.g);</span><br><span class="line">    <span class="keyword">float</span> b = EvaluateCurve(_CurveBlue, c.b);</span><br><span class="line">    colorLinear = float3(r, g, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tonemapping色调映射">Tonemapping（色调映射）</h4>
<p>色调映射（Tonemapping）算法</p>
<p>Neutral Tonemapping和ACES
Tonemapping是两种不同的色调映射（Tonemapping）算法，它们在处理图像时有一些区别：</p>
<p><strong>Neutral Tonemapping（中性色调映射）：</strong></p>
<ul>
<li>中性色调映射是一种简单的色调映射算法，旨在保持图像的整体对比度和亮度，并尽可能地保留原始图像的色彩和细节。</li>
<li>中性色调映射通常采用简单的灰度映射函数，将图像的亮度值进行线性或对数调整，以使得整个图像的亮度范围适应于显示设备的动态范围。</li>
<li>中性色调映射不太复杂，易于实现，并且通常用于一般的图像处理任务中。</li>
</ul>
<p><strong>ACES Tonemapping（Academy Color Encoding
System色调映射）：</strong></p>
<ul>
<li>ACES是一种广泛使用的颜色管理系统，旨在实现在各种不同设备和平台上的一致色彩表现。ACES
Tonemapping是基于这一系统的色调映射算法。</li>
<li>ACES
Tonemapping考虑了更多的颜色科学原理和视觉感知模型，以更好地模拟人眼对真实世界场景的感知。</li>
<li>ACES
Tonemapping通常包括对色彩、对比度和亮度的调整，以实现更加自然和逼真的图像呈现效果。</li>
<li>ACES
Tonemapping算法更复杂，需要更多的计算和参数调整，但可以产生更高质量的图像处理结果，特别是对于视觉特效和电影制作等专业领域。</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片原函数</span></span><br><span class="line"><span class="function">float4 <span class="title">FragLutBuilderHdr</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Lut 空间 我们使用 Alexa LogC (El 1000) 来存储 LUT，因为它提供了足够好的范围 (~58.85666)，并且足以存储在 fp16 中，而不会在暗部失去精度</span></span><br><span class="line">    float3 colorLutSpace = GetLutStripValue(input.texcoord, _Lut_Params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面那些后处理步骤，只是会在不同的空间中计算</span></span><br><span class="line">    float3 gradedColor = ColorGrade(colorLutSpace);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HDR_COLORSPACE_CONVERSION</span></span><br><span class="line">    <span class="comment">//处理输出到HDR显示器的转换</span></span><br><span class="line">    gradedColor = ProcessColorForHDR(gradedColor);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    gradedColor = Tonemap(gradedColor);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> float4(gradedColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理输入到HDR显示器时的转换</span></span><br><span class="line"><span class="function">float3 <span class="title">ProcessColorForHDR</span><span class="params">(float3 colorLinear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HDR_COLORSPACE_CONVERSION</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> _TONEMAP_ACES</span></span><br><span class="line">        float3 aces = ACEScg_to_ACES(colorLinear);</span><br><span class="line">        <span class="keyword">return</span> HDRMappingACES(aces.rgb, PaperWhite, MinNits, MaxNits, RangeReductionMode, <span class="literal">true</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">elif</span> _TONEMAP_NEUTRAL</span></span><br><span class="line">        <span class="keyword">return</span> HDRMappingFromRec2020(colorLinear.rgb, PaperWhite, MinNits, MaxNits, RangeReductionMode, HueShift, <span class="literal">true</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// 在 Rec2020 中完成分级，转换为预期的色彩空间和 [0, 10k] 尼特范围</span></span><br><span class="line">        <span class="keyword">return</span> RotateRec2020ToOutputSpace(colorLinear) * PaperWhite;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> colorLinear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 色调映射</span></span><br><span class="line"><span class="function">float3 <span class="title">Tonemap</span><span class="params">(float3 colorLinear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _TONEMAP_NEUTRAL</span></span><br><span class="line">    &#123;</span><br><span class="line">        colorLinear = NeutralTonemap(colorLinear);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span> _TONEMAP_ACES</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Note: input is actually ACEScg (AP1 w/ linear encoding)</span></span><br><span class="line">        float3 aces = ACEScg_to_ACES(colorLinear);</span><br><span class="line">        colorLinear = AcesTonemap(aces);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> colorLinear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="视觉效果vfx">视觉效果（VFX）</h3>
<h4 id="景深depth-of-fielddof">景深（Depth of Field，DOF）</h4>
<p>景深后处理是一种用于模拟相机镜头产生的景深效果的图像处理技术。它可以在后期处理阶段模拟出景深的效果，使得图像中的某些部分变得模糊，而其他部分保持清晰，从而增强了图像的艺术感和视觉效果。</p>
<p><strong>实现原理：</strong>
景深后处理的实现原理主要基于两个关键概念：景深和高斯模糊。</p>
<ol type="1">
<li><strong>景深（Depth of
Field，DOF）</strong>：景深是指相机镜头焦点前后一定范围内的物体都能保持清晰的范围。景深受到相机参数（如焦距、光圈大小）和拍摄场景的影响。在景深后处理中，通过模拟景深范围内的物体变得模糊来实现景深效果。</li>
<li><strong>高斯模糊</strong>：高斯模糊是一种常用的图像模糊技术，它通过对图像中每个像素的周围像素应用高斯函数来降低像素的清晰度。模糊半径决定了模糊的程度，通常用于模拟景深中物体的模糊效果。</li>
<li><strong>合成</strong>：将模糊处理后的图像与原始图像进行混合，以获得最终的景深效果。通常使用混合模式（如线性混合或增加混合）来调整模糊图像与原始图像之间的比例。</li>
</ol>
<p>URP提供了两种模糊算法：高斯模糊和散景模糊，代码如下：</p>
<p><strong>C#部分</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoDepthOfField</span>(<span class="params">Camera camera, CommandBuffer cmd, RTHandle source, RTHandle destination, Rect pixelRect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 高斯模糊方案</span></span><br><span class="line">    <span class="keyword">if</span> (m_DepthOfField.mode.<span class="keyword">value</span> == DepthOfFieldMode.Gaussian)</span><br><span class="line">        DoGaussianDepthOfField(camera, cmd, source, destination, pixelRect);</span><br><span class="line">    <span class="comment">// 散景模糊方案</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_DepthOfField.mode.<span class="keyword">value</span> == DepthOfFieldMode.Bokeh)</span><br><span class="line">        DoBokehDepthOfField(cmd, source, destination, pixelRect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置高斯模糊参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoGaussianDepthOfField</span>(<span class="params">Camera camera, CommandBuffer cmd, RTHandle source, RTHandle destination, Rect pixelRect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> downSample = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> material = m_Materials.gaussianDepthOfField;</span><br><span class="line">    <span class="keyword">int</span> wh = m_Descriptor.width / downSample;</span><br><span class="line">    <span class="keyword">int</span> hh = m_Descriptor.height / downSample;</span><br><span class="line">    <span class="keyword">float</span> farStart = m_DepthOfField.gaussianStart.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">float</span> farEnd = Mathf.Max(farStart, m_DepthOfField.gaussianEnd.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设半径 1 在 1080p 下为 1。超过一定半径后，我们的高斯核看起来会非常糟糕，因此在非常高的分辨率 (4K+)时，我们将其限制它</span></span><br><span class="line">    <span class="keyword">float</span> maxRadius = m_DepthOfField.gaussianMaxRadius.<span class="keyword">value</span> * (wh / <span class="number">1080f</span>);</span><br><span class="line">    maxRadius = Mathf.Min(maxRadius, <span class="number">2f</span>);</span><br><span class="line">    </span><br><span class="line">    CoreUtils.SetKeyword(material, ShaderKeywordStrings.HighQualitySampling, m_DepthOfField.highQualitySampling.<span class="keyword">value</span>);</span><br><span class="line">    material.SetVector(ShaderConstants._CoCParams, <span class="keyword">new</span> Vector3(farStart, farEnd, maxRadius));</span><br><span class="line"></span><br><span class="line">    RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_FullCoCTexture, GetCompatibleDescriptor(m_Descriptor.width, m_Descriptor.height, m_GaussianCoCFormat), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_FullCoCTexture"</span>);</span><br><span class="line">    RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_HalfCoCTexture, GetCompatibleDescriptor(wh, hh, m_GaussianCoCFormat), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_HalfCoCTexture"</span>);</span><br><span class="line">    RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_PingTexture, GetCompatibleDescriptor(wh, hh, GraphicsFormat.R16G16B16A16_SFloat), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_PingTexture"</span>);</span><br><span class="line">    RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_PongTexture, GetCompatibleDescriptor(wh, hh, GraphicsFormat.R16G16B16A16_SFloat), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_PongTexture"</span>);</span><br><span class="line"></span><br><span class="line">    PostProcessUtils.SetSourceSize(cmd, m_Descriptor);</span><br><span class="line">    cmd.SetGlobalVector(ShaderConstants._DownSampleScaleFactor, <span class="keyword">new</span> Vector4(<span class="number">1.0f</span> / downSample, <span class="number">1.0f</span> / downSample, downSample, downSample));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Compute CoC 计算焦外圈，CoC是指焦平面上物体的像散焦在焦平面上的像上所形成的圆形面积，通常被称为"焦外圆"。Compute CoC是计算这个圆的大小的过程，它是景深模拟算法中的重要部分。景深模拟是一种技术，通过模拟相机对焦的效果，以便在数字图像中产生与真实世界中相似的景深效果。Compute CoC用于确定在图像中哪些部分是焦外的，以便进行适当的模糊处理，从而模拟真实的景深效果。</span></span><br><span class="line">    Blitter.BlitCameraTexture(cmd, source, m_FullCoCTexture, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降采样和预处理颜色和coc，</span></span><br><span class="line">    m_MRT2[<span class="number">0</span>] = m_HalfCoCTexture.nameID;</span><br><span class="line">    m_MRT2[<span class="number">1</span>] = m_PingTexture.nameID;</span><br><span class="line"></span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._FullCoCTexture, m_FullCoCTexture.nameID);</span><br><span class="line">    CoreUtils.SetRenderTarget(cmd, m_MRT2, m_HalfCoCTexture);</span><br><span class="line">    Vector2 viewportScale = source.useScaling ? <span class="keyword">new</span> Vector2(source.rtHandleProperties.rtHandleScale.x, source.rtHandleProperties.rtHandleScale.y) : Vector2.one;</span><br><span class="line">    Blitter.BlitTexture(cmd, source, viewportScale, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊</span></span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._HalfCoCTexture, m_HalfCoCTexture.nameID);</span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._ColorTexture, source);</span><br><span class="line">    Blitter.BlitCameraTexture(cmd, m_PingTexture, m_PongTexture, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">2</span>);</span><br><span class="line">    Blitter.BlitCameraTexture(cmd, m_PongTexture, m_PingTexture, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._ColorTexture, m_PingTexture.nameID);</span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._FullCoCTexture, m_FullCoCTexture.nameID);</span><br><span class="line">    Blitter.BlitCameraTexture(cmd, source, destination, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置散景模糊参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoBokehDepthOfField</span>(<span class="params">CommandBuffer cmd, RTHandle source, RTHandle destination, Rect pixelRect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> downSample = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> material = m_Materials.bokehDepthOfField;</span><br><span class="line">    <span class="keyword">int</span> wh = m_Descriptor.width / downSample;</span><br><span class="line">    <span class="keyword">int</span> hh = m_Descriptor.height / downSample;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成合成图像的镜头和光圈相机模型[Potmesil81]</span></span><br><span class="line">    <span class="comment">//Potmesil（1981）的论文,提出了一种用于合成图像生成的镜头和光圈相机模型。该论文介绍了一种基于物理原理的相机模型，旨在模拟真实相机的成像过程，以生成高质量的合成图像。</span></span><br><span class="line">    <span class="comment">//这个模型考虑了光线从场景中的对象经过透镜和光圈到达成像平面的过程。透镜模型通常用于描述光线的折射和聚焦效应，而光圈模型则用于控制进入相机的光线的量和分布。</span></span><br><span class="line">    <span class="comment">//Potmesil 的相机模型还考虑了各种参数，例如透镜的焦距、光圈的直径以及相机与场景之间的距离等，以更准确地模拟真实相机的行为。这样的模型对于计算机图形学和合成图像生成非常有用，因为它们可以产生更逼真的图像，更好地模拟真实世界的光学效应。</span></span><br><span class="line">    <span class="keyword">float</span> F = m_DepthOfField.focalLength.<span class="keyword">value</span> / <span class="number">1000f</span>;</span><br><span class="line">    <span class="keyword">float</span> A = m_DepthOfField.focalLength.<span class="keyword">value</span> / m_DepthOfField.aperture.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">float</span> P = m_DepthOfField.focusDistance.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">float</span> maxCoC = (A * F) / (P - F);</span><br><span class="line">    <span class="keyword">float</span> maxRadius = GetMaxBokehRadiusInPixels(m_Descriptor.height);</span><br><span class="line">    <span class="keyword">float</span> rcpAspect = <span class="number">1f</span> / (wh / (<span class="keyword">float</span>)hh);</span><br><span class="line"></span><br><span class="line">    CoreUtils.SetKeyword(material, ShaderKeywordStrings.UseFastSRGBLinearConversion, m_UseFastSRGBLinearConversion);</span><br><span class="line">    cmd.SetGlobalVector(ShaderConstants._CoCParams, <span class="keyword">new</span> Vector4(P, maxCoC, maxRadius, rcpAspect));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备散景内核参数</span></span><br><span class="line">    <span class="keyword">int</span> hash = m_DepthOfField.GetHashCode();</span><br><span class="line">    <span class="keyword">if</span> (hash != m_BokehHash || maxRadius != m_BokehMaxRadius || rcpAspect != m_BokehRCPAspect)</span><br><span class="line">    &#123;</span><br><span class="line">        m_BokehHash = hash;</span><br><span class="line">        m_BokehMaxRadius = maxRadius;</span><br><span class="line">        m_BokehRCPAspect = rcpAspect;</span><br><span class="line">        PrepareBokehKernel(maxRadius, rcpAspect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd.SetGlobalVectorArray(ShaderConstants._BokehKernel, m_BokehKernel);</span><br><span class="line"></span><br><span class="line">    RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_FullCoCTexture, GetCompatibleDescriptor(m_Descriptor.width, m_Descriptor.height, GraphicsFormat.R8_UNorm), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_FullCoCTexture"</span>);</span><br><span class="line">    RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_PingTexture, GetCompatibleDescriptor(wh, hh, GraphicsFormat.R16G16B16A16_SFloat), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_PingTexture"</span>);</span><br><span class="line">    RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_PongTexture, GetCompatibleDescriptor(wh, hh, GraphicsFormat.R16G16B16A16_SFloat), FilterMode.Bilinear, TextureWrapMode.Clamp, name: <span class="string">"_PongTexture"</span>);</span><br><span class="line"></span><br><span class="line">    PostProcessUtils.SetSourceSize(cmd, m_Descriptor);</span><br><span class="line">    cmd.SetGlobalVector(ShaderConstants._DownSampleScaleFactor, <span class="keyword">new</span> Vector4(<span class="number">1.0f</span> / downSample, <span class="number">1.0f</span> / downSample, downSample, downSample));</span><br><span class="line">    <span class="keyword">float</span> uvMargin = (<span class="number">1.0f</span> / m_Descriptor.height) * downSample;</span><br><span class="line">    cmd.SetGlobalVector(ShaderConstants._BokehConstants, <span class="keyword">new</span> Vector4(uvMargin, uvMargin * <span class="number">2.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute CoC 计算焦外圈</span></span><br><span class="line">    Blitter.BlitCameraTexture(cmd, source, m_FullCoCTexture, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">0</span>);</span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._FullCoCTexture, m_FullCoCTexture.nameID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//降采样和预处理颜色和coc</span></span><br><span class="line">    Blitter.BlitCameraTexture(cmd, source, m_PingTexture, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 散景模糊</span></span><br><span class="line">    Blitter.BlitCameraTexture(cmd, m_PingTexture, m_PongTexture, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 散景模糊后再使用9-tap tent滤波核进行模糊，“9-tap tent filter” 意味着您想要应用一个 9个采样点的滤波器，滤波器的形状类似于一个帐篷（tent）。然而我们使用4个双线性（bilinear）采样点线性插值的方式来计算这9个采样点的值。</span></span><br><span class="line">    Blitter.BlitCameraTexture(cmd, m_PongTexture, m_PingTexture, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._DofTexture, m_PingTexture.nameID);</span><br><span class="line">    Blitter.BlitCameraTexture(cmd, source, destination, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, material, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Shader部分</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高斯模糊的景深效果</span></span><br><span class="line">Shader <span class="string">"Hidden/Universal Render Pipeline/GaussianDepthOfField"</span></span><br><span class="line">&#123;</span><br><span class="line">    HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.5</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> exclude_renderers gles</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl"</span></span></span><br><span class="line"></span><br><span class="line">        TEXTURE2D_X(_ColorTexture);</span><br><span class="line">        TEXTURE2D_X(_FullCoCTexture);</span><br><span class="line">        TEXTURE2D_X(_HalfCoCTexture);</span><br><span class="line"></span><br><span class="line">        float4 _SourceSize;</span><br><span class="line">        float4 _DownSampleScaleFactor;</span><br><span class="line"></span><br><span class="line">        float3 _CoCParams;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> FarStart        _CoCParams.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> FarEnd          _CoCParams.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MaxRadius       _CoCParams.z</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> BLUR_KERNEL 0</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> BLUR_KERNEL == 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可分离双线性 3-tap 高斯滤波器，相当于5-tap滤波</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> kTapCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">float</span> kOffsets[] = &#123;</span><br><span class="line">            <span class="number">-1.33333333</span>,</span><br><span class="line">             <span class="number">0.00000000</span>,</span><br><span class="line">             <span class="number">1.33333333</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> half kCoeffs[] = &#123;</span><br><span class="line">             <span class="number">0.35294118</span>,</span><br><span class="line">             <span class="number">0.29411765</span>,</span><br><span class="line">             <span class="number">0.35294118</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">elif</span> BLUR_KERNEL == 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 可分离双线性 5-tap 高斯滤波器，相当于9-tap滤波</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> kTapCount = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">float</span> kOffsets[] = &#123;</span><br><span class="line">            <span class="number">-3.23076923</span>,</span><br><span class="line">            <span class="number">-1.38461538</span>,</span><br><span class="line">             <span class="number">0.00000000</span>,</span><br><span class="line">             <span class="number">1.38461538</span>,</span><br><span class="line">             <span class="number">3.23076923</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> half kCoeffs[] = &#123;</span><br><span class="line">             <span class="number">0.07027027</span>,</span><br><span class="line">             <span class="number">0.31621622</span>,</span><br><span class="line">             <span class="number">0.22702703</span>,</span><br><span class="line">             <span class="number">0.31621622</span>,</span><br><span class="line">             <span class="number">0.07027027</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算Coc</span></span><br><span class="line">        <span class="function">half <span class="title">FragCoC</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> depth = LOAD_TEXTURE2D_X(_CameraDepthTexture, _SourceSize.xy * uv).x;</span><br><span class="line">            depth = LinearEyeDepth(depth, _ZBufferParams);</span><br><span class="line">            half coc = (depth - FarStart) / (FarEnd - FarStart);</span><br><span class="line">            <span class="keyword">return</span> saturate(coc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PrefilterOutput</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            half  coc   : SV_Target0;</span><br><span class="line">            half3 color : SV_Target1;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行滤波处理</span></span><br><span class="line">        <span class="function">PrefilterOutput <span class="title">FragPrefilter</span><span class="params">(Varyings input)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> _HIGH_QUALITY_SAMPLING</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//《High Quality Antialiasing》（Lorach07）提出了使用旋转网格来最小化水平和垂直边界带来的伪影。这种技术旨在改善图形渲染中的抗锯齿效果，特别是在处理水平和垂直边界时。</span></span><br><span class="line">            <span class="comment">//这种方法的核心思想是，通过旋转采样网格，使得锯齿边缘的能量在整个图像上更加均匀地分布。通常情况下，水平和垂直边界会导致锯齿效应更加显著，因为它们的方向与像素阵列的方向相对应。通过旋转网格，可以打破这种规律，减少锯齿效应。</span></span><br><span class="line">            <span class="comment">//具体实现时，可以在像素级别上应用旋转网格。这意味着在像素着色器中，对于每个像素，都可以使用不同的旋转网格来进行采样。这样，即使在处理水平和垂直边界时，也可以获得更加均匀的采样，从而减少锯齿效应。</span></span><br><span class="line">            <span class="comment">//通过这种方法，可以提高图形渲染的质量，特别是对于需要处理锯齿效应的场景，例如渲染具有许多直线或边缘的场景，如建筑物或栅格图形。</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> kCount = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">const</span> float2 kTaps[] = &#123;</span><br><span class="line">                float2( <span class="number">0.0</span>,  <span class="number">0.0</span>),</span><br><span class="line">                float2( <span class="number">0.9</span>, <span class="number">-0.4</span>),</span><br><span class="line">                float2(<span class="number">-0.9</span>,  <span class="number">0.4</span>),</span><br><span class="line">                float2( <span class="number">0.4</span>,  <span class="number">0.9</span>),</span><br><span class="line">                float2(<span class="number">-0.4</span>, <span class="number">-0.9</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            half3 colorAcc = <span class="number">0.0</span>;</span><br><span class="line">            half farCoCAcc = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            UNITY_UNROLL</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                float2 tapCoord = _SourceSize.zw * kTaps[i] + uv;</span><br><span class="line">                half3 tapColor = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, tapCoord).xyz;</span><br><span class="line">                half coc = SAMPLE_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, tapCoord).x;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 预先乘以焦平面模糊（CoC）可以帮助减少背景模糊向聚焦区域的渗透。这个技术常用于渲染引擎中，以改善焦外区域的逼真度，同时保持焦点区域的清晰度。</span></span><br><span class="line">                colorAcc += tapColor * coc;</span><br><span class="line">                farCoCAcc += coc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half3 color = colorAcc * rcp(kCount);</span><br><span class="line">            half farCoC = farCoCAcc * rcp(kCount);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//理论上，对 CoC 进行双线性采样可能不太准确，因为 CoC 的大小通常不是线性变化的。然而，在某些情况下，为了提高速度和简化实现，可以选择使用双线性采样来近似 CoC。</span></span><br><span class="line">            <span class="comment">//双线性采样是一种简单且快速的插值方法，适用于许多图形渲染情景。它通过对四个最近的像素进行加权平均来估计一个给定位置的值。虽然这种方法在处理 CoC 时可能会引入一些误差，但在实践中，它通常可以提供足够的准确性，特别是在需要快速渲染的情况下。</span></span><br><span class="line">            half farCoC = SAMPLE_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, uv).x;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//快速的双线性下采样源目标，并预先将 CoC 与颜色值相乘以减少背景模糊渗透到焦点区域</span></span><br><span class="line">            half3 color = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv).xyz;</span><br><span class="line">            color *= farCoC;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            PrefilterOutput o;</span><br><span class="line">            o.coc   = farCoC;</span><br><span class="line">            o.color = color;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">Blur</span><span class="params">(Varyings input, float2 dir, <span class="keyword">float</span> premultiply)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use the center CoC as radius</span></span><br><span class="line">            int2 positionSS = int2(_SourceSize.xy * _DownSampleScaleFactor.xy * uv);</span><br><span class="line">            half samp0CoC = LOAD_TEXTURE2D_X(_HalfCoCTexture, positionSS).x;</span><br><span class="line"></span><br><span class="line">            float2 offset = _SourceSize.zw * _DownSampleScaleFactor.zw * dir * samp0CoC * MaxRadius;</span><br><span class="line">            half4 acc = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            UNITY_UNROLL</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kTapCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                float2 sampCoord = uv + kOffsets[i] * offset;</span><br><span class="line">                half sampCoC = SAMPLE_TEXTURE2D_X(_HalfCoCTexture, sampler_LinearClamp, sampCoord).x;</span><br><span class="line">                half3 sampColor = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, sampCoord).xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Weight &amp; pre-multiply to limit bleeding on the focused area</span></span><br><span class="line">                half weight = saturate(<span class="number">1.0</span> - (samp0CoC - sampCoC));</span><br><span class="line">                acc += half4(sampColor, premultiply ? sampCoC : <span class="number">1.0</span>) * kCoeffs[i] * weight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            acc.xyz /= acc.w + <span class="number">1e-4</span>; <span class="comment">// Zero-div guard</span></span><br><span class="line">            <span class="keyword">return</span> half4(acc.xyz, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragBlurH</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Blur(input, float2(<span class="number">1.0</span>, <span class="number">0.0</span>), <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragBlurV</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Blur(input, float2(<span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragComposite</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            half3 baseColor = LOAD_TEXTURE2D_X(_BlitTexture, _SourceSize.xy * uv).xyz;</span><br><span class="line">            half coc = LOAD_TEXTURE2D_X(_FullCoCTexture, _SourceSize.xy * uv).x;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> _HIGH_QUALITY_SAMPLING &amp;&amp; !defined(SHADER_API_GLES)</span></span><br><span class="line">            half3 farColor = SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_ColorTexture, sampler_LinearClamp), uv, _SourceSize * _DownSampleScaleFactor, <span class="number">1.0</span>, unity_StereoEyeIndex).xyz;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            half3 farColor = SAMPLE_TEXTURE2D_X(_ColorTexture, sampler_LinearClamp, uv).xyz;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            half3 dstColor = <span class="number">0.0</span>;</span><br><span class="line">            half dstAlpha = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">            UNITY_BRANCH</span><br><span class="line">            <span class="keyword">if</span> (coc &gt; <span class="number">0.0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Non-linear blend</span></span><br><span class="line">                <span class="comment">// "CryEngine 3 Graphics Gems" [Sousa13]</span></span><br><span class="line">                half blend = <span class="built_in">sqrt</span>(coc * TWO_PI);</span><br><span class="line">                dstColor = farColor * saturate(blend);</span><br><span class="line">                dstAlpha = saturate(<span class="number">1.0</span> - blend);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> half4(baseColor * dstAlpha + dstColor, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">"RenderPipeline"</span> = <span class="string">"UniversalPipeline"</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Gaussian Depth Of Field CoC"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragCoC</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Gaussian Depth Of Field Prefilter"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragPrefilter</span><br><span class="line">                #pragma multi_compile_local _ _HIGH_QUALITY_SAMPLING</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Gaussian Depth Of Field Blur Horizontal"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragBlurH</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Gaussian Depth Of Field Blur Vertical"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragBlurV</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Gaussian Depth Of Field Composite"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragComposite</span><br><span class="line">                #pragma multi_compile_local _ _HIGH_QUALITY_SAMPLING</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散景模糊的景深效果</span></span><br><span class="line">Shader <span class="string">"Hidden/Universal Render Pipeline/BokehDepthOfField"</span></span><br><span class="line">&#123;</span><br><span class="line">    HLSLINCLUDE</span><br><span class="line">        #pragma exclude_renderers gles</span><br><span class="line">        #pragma multi_compile_local_fragment _ _USE_FAST_SRGB_LINEAR_CONVERSION</span><br><span class="line"></span><br><span class="line">        #include <span class="string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span></span><br><span class="line">        #include <span class="string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"</span></span><br><span class="line">        #include <span class="string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"</span></span><br><span class="line">        #include <span class="string">"Packages/com.unity.render-pipelines.universal/Shaders/PostProcessing/Common.hlsl"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not change this without changing PostProcessPass.PrepareBokehKernel()</span></span><br><span class="line">        #define SAMPLE_COUNT            <span class="number">42</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Toggle this to reduce flickering - note that it will reduce overall bokeh energy and add</span></span><br><span class="line">        <span class="comment">// a small cost to the pre-filtering pass</span></span><br><span class="line">        #define COC_LUMA_WEIGHTING      <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        TEXTURE2D_X(_DofTexture);</span><br><span class="line">        TEXTURE2D_X(_FullCoCTexture);</span><br><span class="line"></span><br><span class="line">        half4 _SourceSize;</span><br><span class="line">        half4 _HalfSourceSize;</span><br><span class="line">        half4 _DownSampleScaleFactor;</span><br><span class="line">        half4 _CoCParams;</span><br><span class="line">        half4 _BokehKernel[SAMPLE_COUNT];</span><br><span class="line">        half4 _BokehConstants;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> FocusDist       _CoCParams.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MaxCoC          _CoCParams.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MaxRadius       _CoCParams.z</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> RcpAspect       _CoCParams.w</span></span><br><span class="line"></span><br><span class="line">        <span class="function">half <span class="title">FragCoC</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line"></span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line">            <span class="keyword">float</span> depth = LOAD_TEXTURE2D_X(_CameraDepthTexture, _SourceSize.xy * uv).x;</span><br><span class="line">            <span class="keyword">float</span> linearEyeDepth = LinearEyeDepth(depth, _ZBufferParams);</span><br><span class="line"></span><br><span class="line">            half coc = (<span class="number">1.0</span> - FocusDist / linearEyeDepth) * MaxCoC;</span><br><span class="line">            half nearCoC = clamp(coc, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            half farCoC = saturate(coc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> saturate((farCoC + nearCoC + <span class="number">1.0</span>) * <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragPrefilter</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> SHADER_TARGET &gt;= 45 &amp;&amp; defined(PLATFORM_SUPPORT_GATHER)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sample source colors</span></span><br><span class="line">            half4 cr = GATHER_RED_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);</span><br><span class="line">            half4 cg = GATHER_GREEN_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);</span><br><span class="line">            half4 cb = GATHER_BLUE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);</span><br><span class="line"></span><br><span class="line">            half3 c0 = half3(cr.x, cg.x, cb.x);</span><br><span class="line">            half3 c1 = half3(cr.y, cg.y, cb.y);</span><br><span class="line">            half3 c2 = half3(cr.z, cg.z, cb.z);</span><br><span class="line">            half3 c3 = half3(cr.w, cg.w, cb.w);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sample CoCs</span></span><br><span class="line">            half4 cocs = GATHER_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, uv) * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">            half coc0 = cocs.x;</span><br><span class="line">            half coc1 = cocs.y;</span><br><span class="line">            half coc2 = cocs.z;</span><br><span class="line">            half coc3 = cocs.w;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">            float3 duv = _SourceSize.zwz * float3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">-0.5</span>);</span><br><span class="line">            float2 uv0 = uv - duv.xy;</span><br><span class="line">            float2 uv1 = uv - duv.zy;</span><br><span class="line">            float2 uv2 = uv + duv.zy;</span><br><span class="line">            float2 uv3 = uv + duv.xy;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sample source colors</span></span><br><span class="line">            half3 c0 = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv0).xyz;</span><br><span class="line">            half3 c1 = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv1).xyz;</span><br><span class="line">            half3 c2 = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv2).xyz;</span><br><span class="line">            half3 c3 = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv3).xyz;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sample CoCs</span></span><br><span class="line">            half coc0 = SAMPLE_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, uv0).x * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">            half coc1 = SAMPLE_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, uv1).x * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">            half coc2 = SAMPLE_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, uv2).x * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">            half coc3 = SAMPLE_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, uv3).x * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> COC_LUMA_WEIGHTING</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Apply CoC and luma weights to reduce bleeding and flickering</span></span><br><span class="line">            half w0 = <span class="built_in">abs</span>(coc0) / (Max3(c0.x, c0.y, c0.z) + <span class="number">1.0</span>);</span><br><span class="line">            half w1 = <span class="built_in">abs</span>(coc1) / (Max3(c1.x, c1.y, c1.z) + <span class="number">1.0</span>);</span><br><span class="line">            half w2 = <span class="built_in">abs</span>(coc2) / (Max3(c2.x, c2.y, c2.z) + <span class="number">1.0</span>);</span><br><span class="line">            half w3 = <span class="built_in">abs</span>(coc3) / (Max3(c3.x, c3.y, c3.z) + <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Weighted average of the color samples</span></span><br><span class="line">            half3 avg = c0 * w0 + c1 * w1 + c2 * w2 + c3 * w3;</span><br><span class="line">            avg /= <span class="built_in">max</span>(w0 + w1 + w2 + w3, <span class="number">1e-5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">            half3 avg = (c0 + c1 + c2 + c3) / <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Select the largest CoC value</span></span><br><span class="line">            half cocMin = <span class="built_in">min</span>(coc0, Min3(coc1, coc2, coc3));</span><br><span class="line">            half cocMax = <span class="built_in">max</span>(coc0, Max3(coc1, coc2, coc3));</span><br><span class="line">            half coc = (-cocMin &gt; cocMax ? cocMin : cocMax) * MaxRadius;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Premultiply CoC</span></span><br><span class="line">            avg *= smoothstep(<span class="number">0</span>, _SourceSize.w * <span class="number">2.0</span>, <span class="built_in">abs</span>(coc));</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> defined(UNITY_COLORSPACE_GAMMA)</span></span><br><span class="line">            avg = GetSRGBToLinear(avg);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> half4(avg, coc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Accumulate</span><span class="params">(half4 samp0, float2 uv, half4 disp, inout half4 farAcc, inout half4 nearAcc)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            half4 samp = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + disp.wy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Compare CoC of the current sample and the center sample and select smaller one</span></span><br><span class="line">            half farCoC = <span class="built_in">max</span>(<span class="built_in">min</span>(samp0.a, samp.a), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Compare the CoC to the sample distance &amp; add a small margin to smooth out</span></span><br><span class="line">            half farWeight = saturate((farCoC - disp.z + _BokehConstants.y) / _BokehConstants.y);</span><br><span class="line">            half nearWeight = saturate((-samp.a - disp.z + _BokehConstants.y) / _BokehConstants.y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cut influence from focused areas because they're darkened by CoC premultiplying. This is only</span></span><br><span class="line">            <span class="comment">// needed for near field</span></span><br><span class="line">            nearWeight *= <span class="built_in">step</span>(_BokehConstants.x, -samp.a);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Accumulation</span></span><br><span class="line">            farAcc += half4(samp.rgb, <span class="number">1.0</span>h) * farWeight;</span><br><span class="line">            nearAcc += half4(samp.rgb, <span class="number">1.0</span>h) * nearWeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragBlur</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            half4 samp0 = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);</span><br><span class="line"></span><br><span class="line">            half4 farAcc = <span class="number">0.0</span>;  <span class="comment">// Background: far field bokeh</span></span><br><span class="line">            half4 nearAcc = <span class="number">0.0</span>; <span class="comment">// Foreground: near field bokeh</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Center sample isn't in the kernel array, accumulate it separately</span></span><br><span class="line">            Accumulate(samp0, uv, <span class="number">0.0</span>, farAcc, nearAcc);</span><br><span class="line"></span><br><span class="line">            UNITY_LOOP</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; SAMPLE_COUNT; si++)</span><br><span class="line">            &#123;</span><br><span class="line">                Accumulate(samp0, uv, _BokehKernel[si], farAcc, nearAcc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the weighted average</span></span><br><span class="line">            farAcc.rgb /= farAcc.a + (farAcc.a == <span class="number">0.0</span>);     <span class="comment">// Zero-div guard</span></span><br><span class="line">            nearAcc.rgb /= nearAcc.a + (nearAcc.a == <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Normalize the total of the weights for the near field</span></span><br><span class="line">            nearAcc.a *= PI / (SAMPLE_COUNT + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Alpha premultiplying</span></span><br><span class="line">            half alpha = saturate(nearAcc.a);</span><br><span class="line">            half3 rgb = lerp(farAcc.rgb, nearAcc.rgb, alpha);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> half4(rgb, alpha);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragPostBlur</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9-tap tent filter with 4 bilinear samples</span></span><br><span class="line">            float4 duv = _SourceSize.zwzw * _DownSampleScaleFactor.zwzw * float4(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>);</span><br><span class="line">            half4 acc;</span><br><span class="line">            acc  = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - duv.xy);</span><br><span class="line">            acc += SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - duv.zy);</span><br><span class="line">            acc += SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + duv.zy);</span><br><span class="line">            acc += SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + duv.xy);</span><br><span class="line">            <span class="keyword">return</span> acc * <span class="number">0.25</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragComposite</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            half4 dof = SAMPLE_TEXTURE2D_X(_DofTexture, sampler_LinearClamp, uv);</span><br><span class="line">            half coc = SAMPLE_TEXTURE2D_X(_FullCoCTexture, sampler_LinearClamp, uv).r;</span><br><span class="line">            coc = (coc - <span class="number">0.5</span>) * <span class="number">2.0</span> * MaxRadius;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Convert CoC to far field alpha value</span></span><br><span class="line">            <span class="keyword">float</span> ffa = smoothstep(_SourceSize.w * <span class="number">2.0</span>, _SourceSize.w * <span class="number">4.0</span>, coc);</span><br><span class="line"></span><br><span class="line">            half4 color = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> defined(UNITY_COLORSPACE_GAMMA)</span></span><br><span class="line">            color = GetSRGBToLinear(color);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            half alpha = Max3(dof.r, dof.g, dof.b);</span><br><span class="line">            color = lerp(color, half4(dof.rgb, alpha), ffa + dof.a - ffa * dof.a);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> defined(UNITY_COLORSPACE_GAMMA)</span></span><br><span class="line">            color = GetLinearToSRGB(color);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">"RenderPipeline"</span> = <span class="string">"UniversalPipeline"</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bokeh Depth Of Field CoC"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragCoC</span><br><span class="line">                #pragma target <span class="number">4.5</span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bokeh Depth Of Field Prefilter"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragPrefilter</span><br><span class="line">                #pragma target <span class="number">4.5</span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bokeh Depth Of Field Blur"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragBlur</span><br><span class="line">                #pragma target <span class="number">4.5</span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bokeh Depth Of Field Post Blur"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragPostBlur</span><br><span class="line">                #pragma target <span class="number">4.5</span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bokeh Depth Of Field Composite"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragComposite</span><br><span class="line">                #pragma target <span class="number">4.5</span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运动模糊motion-blur">运动模糊（Motion Blur）</h4>
<p>Motion Blur
的后处理实现原理是在图像已经捕获或生成后，在整个图像上应用模糊效果，以模拟相机或物体运动时的模糊效果。</p>
<p>以下是 Motion Blur 后处理的基本原理：</p>
<p><strong>1. 获取速度信息：</strong>
在图像处理中，速度信息通常是由每个像素的运动向量表示的。这些向量可以通过两个连续帧之间的像素位移或动作估计算法（如光流法）来获取。</p>
<p><strong>2. 计算模糊效果：</strong>
一旦获得了速度信息，就可以根据每个像素的运动向量来计算应用于该像素的模糊程度。通常情况下，速度越高的像素，应用的模糊效果就越强烈。</p>
<p><strong>3. 模糊处理：</strong>
一种常见的模糊方法是使用卷积核。对于每个像素，可以根据其周围像素的权重来计算模糊效果。这可以通过高斯模糊、运动模糊或其他模糊核来实现。</p>
<p><strong>4. 混合：</strong>
最后，将计算得到的模糊效果应用到原始图像上。通常采用像素值的混合或者合成技术来实现。混合的方式可以是简单的加权平均，也可以是更复杂的技术，如逐像素运动模糊等。</p>
<p><strong>核心函数代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算每个像素的移动速度</span></span><br><span class="line"><span class="function">half2 <span class="title">GetCameraVelocity</span><span class="params">(float4 uv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">        half depth = SampleSceneDepth(uv.xy).x;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        half depth = lerp(UNITY_NEAR_CLIP_VALUE, <span class="number">1</span>, SampleSceneDepth(uv.xy).x);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    float4 worldPos = float4(ComputeWorldSpacePosition(uv.xy, depth, UNITY_MATRIX_I_VP), <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    float4 prevClipPos = mul(_PrevViewProjM, worldPos);</span><br><span class="line">    float4 curClipPos = mul(_ViewProjM, worldPos);</span><br><span class="line"></span><br><span class="line">    half2 prevPosCS = prevClipPos.xy / prevClipPos.w;</span><br><span class="line">    half2 curPosCS = curClipPos.xy / curClipPos.w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backwards motion vectors</span></span><br><span class="line">    half2 velocity = (prevPosCS - curPosCS);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">        velocity.y = -velocity.y;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ClampVelocity(velocity, _Clamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">half3 <span class="title">GatherSample</span><span class="params">(half sampleNumber, half2 velocity, half invSampleCount, float2 centerUV, half randomVal, half velocitySign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half  offsetLength = (sampleNumber + <span class="number">0.5</span>h) + (velocitySign * (randomVal - <span class="number">0.5</span>h));</span><br><span class="line">    float2 sampleUV = centerUV + (offsetLength * invSampleCount) * velocity * velocitySign;</span><br><span class="line">    <span class="keyword">return</span> SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_PointClamp, sampleUV).xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">half4 <span class="title">DoMotionBlur</span><span class="params">(VaryingsCMB input, <span class="keyword">int</span> iterations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line"></span><br><span class="line">    float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord.xy);</span><br><span class="line">    half2 velocity = GetCameraVelocity(float4(uv, input.texcoord.zw)) * _Intensity;</span><br><span class="line">    half randomVal = InterleavedGradientNoise(uv * _SourceSize.xy, <span class="number">0</span>);</span><br><span class="line">    half invSampleCount = rcp(iterations * <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    half3 color = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    UNITY_UNROLL</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iterations; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        color += GatherSample(i, velocity, invSampleCount, uv, randomVal, <span class="number">-1.0</span>);</span><br><span class="line">        color += GatherSample(i, velocity, invSampleCount, uv, randomVal,  <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> half4(color * invSampleCount, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="panini投影panini-projection">Panini投影（Panini
Projection）</h4>
<p>Panini Projection
是一种透视投影技术，它可以在保持图像的透视感的同时，扭曲图像以适应更宽的视角，从而产生一种类似鱼眼镜头的效果。实现
Panini Projection 的后处理通常涉及以下步骤：</p>
<p><strong>1. 确定投影参数：</strong> 首先，需要确定用于 Panini
投影的参数，包括视角（FOV）、压缩因子等。这些参数将影响最终投影效果的弯曲程度和透视感。</p>
<p><strong>2. 图像扭曲：</strong> 将原始图像应用于 Panini
投影的算法，对图像进行扭曲。这通常涉及到对图像中的每个像素进行重新定位，以适应所选的投影参数。在这一步中，图像中的像素位置会根据所选的参数进行重新映射，以产生弯曲的效果。</p>
<p><strong>3. 插值和填充：</strong>
由于进行投影扭曲可能会导致某些像素位置在新图像中没有对应的值，因此需要进行插值和填充处理。通常采用的插值方法包括双线性插值、双三次插值等，以确保图像的平滑过渡和连续性。</p>
<p><strong>4. 边缘处理：</strong>
在扭曲后的图像边缘可能会出现拉伸或压缩的情况，因此需要进行边缘处理以消除这种失真。常见的方法包括使用遮罩或者边界像素的加权平均来平滑边缘过渡。</p>
<p>总的来说，Panini Projection 的后处理实现原理涉及将原始图像应用于
Panini
投影算法，对图像进行扭曲和重新映射，然后进行插值、填充和边缘处理，最终得到扭曲的图像以产生所需的透视效果。</p>
<p><strong>核心函数代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float2 <span class="title">Panini_UnitDistance</span><span class="params">(float2 view_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Given</span></span><br><span class="line">    <span class="comment">//    S----------- E--X-------</span></span><br><span class="line">    <span class="comment">//    |      ` .  /,´</span></span><br><span class="line">    <span class="comment">//    |-- ---    Q</span></span><br><span class="line">    <span class="comment">//  1 |       ,´/  `</span></span><br><span class="line">    <span class="comment">//    |     ,´ /    ´</span></span><br><span class="line">    <span class="comment">//    |   ,´  /      `</span></span><br><span class="line">    <span class="comment">//    | ,´   /       .</span></span><br><span class="line">    <span class="comment">//    O`    /        .</span></span><br><span class="line">    <span class="comment">//    |    /         `</span></span><br><span class="line">    <span class="comment">//    |   /         ´</span></span><br><span class="line">    <span class="comment">//  1 |  /         ´</span></span><br><span class="line">    <span class="comment">//    | /        ´</span></span><br><span class="line">    <span class="comment">//    |/_  .  ´</span></span><br><span class="line">    <span class="comment">//    P</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Have E</span></span><br><span class="line">    <span class="comment">// Want to find X</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// First apply tangent-secant theorem to find Q</span></span><br><span class="line">    <span class="comment">//   PE*QE = SE*SE</span></span><br><span class="line">    <span class="comment">//   QE = PE-PQ</span></span><br><span class="line">    <span class="comment">//   PQ = PE-(SE*SE)/PE</span></span><br><span class="line">    <span class="comment">//   Q = E*(PQ/PE)</span></span><br><span class="line">    <span class="comment">// Then project Q to find X</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> d = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> view_dist = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> view_dist_sq = <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> view_hyp = <span class="built_in">sqrt</span>(view_pos.x * view_pos.x + view_dist_sq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> cyl_hyp = view_hyp - (view_pos.x * view_pos.x) / view_hyp;</span><br><span class="line">    <span class="keyword">float</span> cyl_hyp_frac = cyl_hyp / view_hyp;</span><br><span class="line">    <span class="keyword">float</span> cyl_dist = view_dist * cyl_hyp_frac;</span><br><span class="line"></span><br><span class="line">    float2 cyl_pos = view_pos * cyl_hyp_frac;</span><br><span class="line">    <span class="keyword">return</span> cyl_pos / (cyl_dist - d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float2 <span class="title">Panini_Generic</span><span class="params">(float2 view_pos, <span class="keyword">float</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Given</span></span><br><span class="line">    <span class="comment">//    S----------- E--X-------</span></span><br><span class="line">    <span class="comment">//    |    `  ~.  /,´</span></span><br><span class="line">    <span class="comment">//    |-- ---    Q</span></span><br><span class="line">    <span class="comment">//    |        ,/    `</span></span><br><span class="line">    <span class="comment">//  1 |      ,´/       `</span></span><br><span class="line">    <span class="comment">//    |    ,´ /         ´</span></span><br><span class="line">    <span class="comment">//    |  ,´  /           ´</span></span><br><span class="line">    <span class="comment">//    |,`   /             ,</span></span><br><span class="line">    <span class="comment">//    O    /</span></span><br><span class="line">    <span class="comment">//    |   /               ,</span></span><br><span class="line">    <span class="comment">//  d |  /</span></span><br><span class="line">    <span class="comment">//    | /                ,</span></span><br><span class="line">    <span class="comment">//    |/                .</span></span><br><span class="line">    <span class="comment">//    P</span></span><br><span class="line">    <span class="comment">//    |              ´</span></span><br><span class="line">    <span class="comment">//    |         , ´</span></span><br><span class="line">    <span class="comment">//    +-    ´</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Have E</span></span><br><span class="line">    <span class="comment">// Want to find X</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// First compute line-circle intersection to find Q</span></span><br><span class="line">    <span class="comment">// Then project Q to find X</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> view_dist = <span class="number">1.0</span> + d;</span><br><span class="line">    <span class="keyword">float</span> view_hyp_sq = view_pos.x * view_pos.x + view_dist * view_dist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> isect_D = view_pos.x * d;</span><br><span class="line">    <span class="keyword">float</span> isect_discrim = view_hyp_sq - isect_D * isect_D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> cyl_dist_minus_d = (-isect_D * view_pos.x + view_dist * <span class="built_in">sqrt</span>(isect_discrim)) / view_hyp_sq;</span><br><span class="line">    <span class="keyword">float</span> cyl_dist = cyl_dist_minus_d + d;</span><br><span class="line"></span><br><span class="line">    float2 cyl_pos = view_pos * (cyl_dist / view_dist);</span><br><span class="line">    <span class="keyword">return</span> cyl_pos / (cyl_dist - d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">half4 <span class="title">FragPaniniProjection</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line"></span><br><span class="line">    float2 view_pos = (<span class="number">2.0</span> * input.texcoord - <span class="number">1.0</span>) * _Params.xy * _Params.w;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _GENERIC</span></span><br><span class="line">    float2 proj_pos = Panini_Generic(view_pos, _Params.z);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// _UNIT_DISTANCE</span></span></span><br><span class="line">    float2 proj_pos = Panini_UnitDistance(view_pos);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    float2 proj_ndc = proj_pos / _Params.xy;</span><br><span class="line">    float2 coords = proj_ndc * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, coords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛光bloom">泛光（Bloom）</h4>
<p>泛光（Bloom）后处理是一种常用的图像处理技术，用于增强图像中亮度较高区域的效果，使其产生发光的感觉。其原理如下：</p>
<p><strong>1. 提取高亮区域：</strong>
首先，对原始图像进行处理，提取出高亮区域。这些高亮区域通常是亮度值较高的像素，可以通过阈值处理或者高通滤波器等方法来提取。</p>
<p><strong>2. 生成泛光图：</strong>
将提取出的高亮区域进行模糊处理，生成泛光图。这一步可以使用高斯模糊、径向模糊等模糊算法，使高亮区域周围产生较大的光晕效果。</p>
<p><strong>3. 叠加到原始图像：</strong>
将生成的泛光图与原始图像进行叠加。通常情况下，叠加时会根据泛光图中的亮度值进行加权叠加，使高亮区域的发光效果更加明显。</p>
<p><strong>C#代码:</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupBloom</span>(<span class="params">CommandBuffer cmd, RTHandle source, Material uberMaterial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 降分辨率</span></span><br><span class="line">    <span class="keyword">int</span> downres = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (m_Bloom.downscale.<span class="keyword">value</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> BloomDownscaleMode.Half:</span><br><span class="line">            downres = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BloomDownscaleMode.Quarter:</span><br><span class="line">            downres = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tw = m_Descriptor.width &gt;&gt; downres;</span><br><span class="line">    <span class="keyword">int</span> th = m_Descriptor.height &gt;&gt; downres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定迭代次数</span></span><br><span class="line">    <span class="keyword">int</span> maxSize = Mathf.Max(tw, th);</span><br><span class="line">    <span class="keyword">int</span> iterations = Mathf.FloorToInt(Mathf.Log(maxSize, <span class="number">2f</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mipCount = Mathf.Clamp(iterations, <span class="number">1</span>, m_Bloom.maxIterations.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器参数</span></span><br><span class="line">    <span class="keyword">float</span> clamp = m_Bloom.clamp.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">float</span> threshold = Mathf.GammaToLinearSpace(m_Bloom.threshold.<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">float</span> thresholdKnee = threshold * <span class="number">0.5f</span>; <span class="comment">// Hardcoded soft knee</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置材质参数</span></span><br><span class="line">    <span class="keyword">float</span> scatter = Mathf.Lerp(<span class="number">0.05f</span>, <span class="number">0.95f</span>, m_Bloom.scatter.<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">var</span> bloomMaterial = m_Materials.bloom;</span><br><span class="line">    bloomMaterial.SetVector(ShaderConstants._Params, <span class="keyword">new</span> Vector4(scatter, clamp, threshold, thresholdKnee));</span><br><span class="line">    CoreUtils.SetKeyword(bloomMaterial, ShaderKeywordStrings.BloomHQ, m_Bloom.highQualityFiltering.<span class="keyword">value</span>);</span><br><span class="line">    CoreUtils.SetKeyword(bloomMaterial, ShaderKeywordStrings.UseRGBM, m_UseRGBM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建RT</span></span><br><span class="line">    <span class="keyword">var</span> desc = GetCompatibleDescriptor(tw, th, m_DefaultHDRFormat);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mipCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_BloomMipUp[i], desc, FilterMode.Bilinear, TextureWrapMode.Clamp, name: m_BloomMipUp[i].name);</span><br><span class="line">        RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_BloomMipDown[i], desc, FilterMode.Bilinear, TextureWrapMode.Clamp, name: m_BloomMipDown[i].name);</span><br><span class="line">        desc.width = Mathf.Max(<span class="number">1</span>, desc.width &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        desc.height = Mathf.Max(<span class="number">1</span>, desc.height &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原图Blit到m_BloomMipDown[0]</span></span><br><span class="line">    Blitter.BlitCameraTexture(cmd, source, m_BloomMipDown[<span class="number">0</span>], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, bloomMaterial, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Gaussian Pyramid是一种图像金字塔构建方法，通常用于图像处理和计算机视觉中的多尺度分析。它的基本思想是通过逐级下采样来生成一系列分辨率逐渐降低的图像。具体而言，它的操作步骤如下：</span></span><br><span class="line">    <span class="comment">//高斯模糊（Gaussian Blur）：首先，对原始图像进行高斯模糊操作，这有助于去除图像中的高频细节，使图像更加平滑。</span></span><br><span class="line">    <span class="comment">//下采样（Downsampling）：然后，对模糊后的图像进行下采样操作，即将图像尺寸减小为原始图像的一半（或其他比例），这样就得到了一个分辨率降低的图像。</span></span><br><span class="line">    <span class="comment">//重复操作：这两个步骤可以迭代多次，每次都在前一级图像上进行高斯模糊和下采样操作，生成更低分辨率的图像。</span></span><br><span class="line">    <span class="keyword">var</span> lastDown = m_BloomMipDown[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mipCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Blitter.BlitCameraTexture(cmd, lastDown, m_BloomMipUp[i], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, bloomMaterial, <span class="number">1</span>);</span><br><span class="line">        Blitter.BlitCameraTexture(cmd, m_BloomMipUp[i], m_BloomMipDown[i], RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, bloomMaterial, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        lastDown = m_BloomMipDown[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上采样（默认情况下为双线性，HQ 过滤采用双三次)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mipCount - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> lowMip = (i == mipCount - <span class="number">2</span>) ? m_BloomMipDown[i + <span class="number">1</span>] : m_BloomMipUp[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">var</span> highMip = m_BloomMipDown[i];</span><br><span class="line">        <span class="keyword">var</span> dst = m_BloomMipUp[i];</span><br><span class="line"></span><br><span class="line">        cmd.SetGlobalTexture(ShaderConstants._SourceTexLowMip, lowMip);</span><br><span class="line">        Blitter.BlitCameraTexture(cmd, highMip, dst, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, bloomMaterial, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 uber 上设置 Bloom</span></span><br><span class="line">    <span class="keyword">var</span> tint = m_Bloom.tint.<span class="keyword">value</span>.linear;</span><br><span class="line">    <span class="keyword">var</span> luma = ColorUtils.Luminance(tint);</span><br><span class="line">    tint = luma &gt; <span class="number">0f</span> ? tint * (<span class="number">1f</span> / luma) : Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> bloomParams = <span class="keyword">new</span> Vector4(m_Bloom.intensity.<span class="keyword">value</span>, tint.r, tint.g, tint.b);</span><br><span class="line">    uberMaterial.SetVector(ShaderConstants._Bloom_Params, bloomParams);</span><br><span class="line">    uberMaterial.SetFloat(ShaderConstants._Bloom_RGBM, m_UseRGBM ? <span class="number">1f</span> : <span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">    cmd.SetGlobalTexture(ShaderConstants._Bloom_Texture, m_BloomMipUp[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在uber上设置镜头污垢参数</span></span><br><span class="line">    <span class="comment">// 保持纵横比正确并将污垢纹理居中，不被拉伸或挤压</span></span><br><span class="line">    <span class="keyword">var</span> dirtTexture = m_Bloom.dirtTexture.<span class="keyword">value</span> == <span class="literal">null</span> ? Texture2D.blackTexture : m_Bloom.dirtTexture.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">float</span> dirtRatio = dirtTexture.width / (<span class="keyword">float</span>)dirtTexture.height;</span><br><span class="line">    <span class="keyword">float</span> screenRatio = m_Descriptor.width / (<span class="keyword">float</span>)m_Descriptor.height;</span><br><span class="line">    <span class="keyword">var</span> dirtScaleOffset = <span class="keyword">new</span> Vector4(<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line">    <span class="keyword">float</span> dirtIntensity = m_Bloom.dirtIntensity.<span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtRatio &gt; screenRatio)</span><br><span class="line">    &#123;</span><br><span class="line">        dirtScaleOffset.x = screenRatio / dirtRatio;</span><br><span class="line">        dirtScaleOffset.z = (<span class="number">1f</span> - dirtScaleOffset.x) * <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (screenRatio &gt; dirtRatio)</span><br><span class="line">    &#123;</span><br><span class="line">        dirtScaleOffset.y = dirtRatio / screenRatio;</span><br><span class="line">        dirtScaleOffset.w = (<span class="number">1f</span> - dirtScaleOffset.y) * <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uberMaterial.SetVector(ShaderConstants._LensDirt_Params, dirtScaleOffset);</span><br><span class="line">    uberMaterial.SetFloat(ShaderConstants._LensDirt_Intensity, dirtIntensity);</span><br><span class="line">    uberMaterial.SetTexture(ShaderConstants._LensDirt_Texture, dirtTexture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_Bloom.highQualityFiltering.<span class="keyword">value</span>)</span><br><span class="line">        uberMaterial.EnableKeyword(dirtIntensity &gt; <span class="number">0f</span> ? ShaderKeywordStrings.BloomHQDirt : ShaderKeywordStrings.BloomHQ);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        uberMaterial.EnableKeyword(dirtIntensity &gt; <span class="number">0f</span> ? ShaderKeywordStrings.BloomLQDirt : ShaderKeywordStrings.BloomLQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Shader代码:</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Hidden/Universal Render Pipeline/Bloom"</span></span><br><span class="line">&#123;</span><br><span class="line">    HLSLINCLUDE</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> exclude_renderers gles</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local _ _USE_RGBM</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRendering.hlsl"</span></span></span><br><span class="line"></span><br><span class="line">        float4 _BlitTexture_TexelSize;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D_X(_SourceTexLowMip);</span><br><span class="line">        float4 _SourceTexLowMip_TexelSize;</span><br><span class="line"></span><br><span class="line">        float4 _Params; <span class="comment">// x: scatter, y: clamp, z: threshold (linear), w: threshold knee</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> Scatter             _Params.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ClampMax            _Params.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> Threshold           _Params.z</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ThresholdKnee       _Params.w</span></span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">EncodeHDR</span><span class="params">(half3 color)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> _USE_RGBM</span></span><br><span class="line">            half4 outColor = EncodeRGBM(color);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            half4 outColor = half4(color, <span class="number">1.0</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_COLORSPACE_GAMMA</span></span><br><span class="line">            <span class="keyword">return</span> half4(<span class="built_in">sqrt</span>(outColor.xyz), outColor.w); <span class="comment">// linear to γ</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> outColor;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half3 <span class="title">DecodeHDR</span><span class="params">(half4 color)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_COLORSPACE_GAMMA</span></span><br><span class="line">            color.xyz *= color.xyz; <span class="comment">// γ to linear</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> _USE_RGBM</span></span><br><span class="line">            <span class="keyword">return</span> DecodeRGBM(color);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> color.xyz;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragPrefilter</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_FOVEATED_RENDERING_NON_UNIFORM_RASTER)</span></span><br><span class="line">            uv = RemapFoveatedRenderingResolve(uv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> _BLOOM_HQ</span></span><br><span class="line">            <span class="keyword">float</span> texelSize = _BlitTexture_TexelSize.x;</span><br><span class="line">            half4 A = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">-1.0</span>, <span class="number">-1.0</span>));</span><br><span class="line">            half4 B = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">0.0</span>, <span class="number">-1.0</span>));</span><br><span class="line">            half4 C = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">1.0</span>, <span class="number">-1.0</span>));</span><br><span class="line">            half4 D = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">-0.5</span>, <span class="number">-0.5</span>));</span><br><span class="line">            half4 E = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">0.5</span>, <span class="number">-0.5</span>));</span><br><span class="line">            half4 F = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">-1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            half4 G = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);</span><br><span class="line">            half4 H = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            half4 I = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">-0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">            half4 J = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">            half4 K = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">-1.0</span>, <span class="number">1.0</span>));</span><br><span class="line">            half4 L = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">            half4 M = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + texelSize * float2(<span class="number">1.0</span>, <span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">            half2 div = (<span class="number">1.0</span> / <span class="number">4.0</span>) * half2(<span class="number">0.5</span>, <span class="number">0.125</span>);</span><br><span class="line"></span><br><span class="line">            half4 o = (D + E + I + J) * div.x;</span><br><span class="line">            o += (A + B + G + F) * div.y;</span><br><span class="line">            o += (B + C + H + G) * div.y;</span><br><span class="line">            o += (F + G + L + K) * div.y;</span><br><span class="line">            o += (G + H + M + L) * div.y;</span><br><span class="line"></span><br><span class="line">            half3 color = o.xyz;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            half3 color = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv).xyz;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            color = <span class="built_in">min</span>(ClampMax, color);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阈值化</span></span><br><span class="line">            half brightness = Max3(color.r, color.g, color.b);</span><br><span class="line">            half softness = clamp(brightness - Threshold + ThresholdKnee, <span class="number">0.0</span>, <span class="number">2.0</span> * ThresholdKnee);</span><br><span class="line">            softness = (softness * softness) / (<span class="number">4.0</span> * ThresholdKnee + <span class="number">1e-4</span>);</span><br><span class="line">            half multiplier = <span class="built_in">max</span>(brightness - Threshold, softness) / <span class="built_in">max</span>(brightness, <span class="number">1e-4</span>);</span><br><span class="line">            color *= multiplier;</span><br><span class="line"></span><br><span class="line">            color = <span class="built_in">max</span>(color, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> EncodeHDR(color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragBlurH</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            <span class="keyword">float</span> texelSize = _BlitTexture_TexelSize.x * <span class="number">2.0</span>;</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9-tap高斯模糊</span></span><br><span class="line">            half3 c0 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - float2(texelSize * <span class="number">4.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">            half3 c1 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - float2(texelSize * <span class="number">3.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">            half3 c2 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - float2(texelSize * <span class="number">2.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">            half3 c3 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - float2(texelSize * <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">            half3 c4 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv                               ));</span><br><span class="line">            half3 c5 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + float2(texelSize * <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">            half3 c6 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + float2(texelSize * <span class="number">2.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">            half3 c7 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + float2(texelSize * <span class="number">3.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">            half3 c8 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + float2(texelSize * <span class="number">4.0</span>, <span class="number">0.0</span>)));</span><br><span class="line"></span><br><span class="line">            half3 color = c0 * <span class="number">0.01621622</span> + c1 * <span class="number">0.05405405</span> + c2 * <span class="number">0.12162162</span> + c3 * <span class="number">0.19459459</span></span><br><span class="line">                        + c4 * <span class="number">0.22702703</span></span><br><span class="line">                        + c5 * <span class="number">0.19459459</span> + c6 * <span class="number">0.12162162</span> + c7 * <span class="number">0.05405405</span> + c8 * <span class="number">0.01621622</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> EncodeHDR(color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragBlurV</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            <span class="keyword">float</span> texelSize = _BlitTexture_TexelSize.y;</span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 双线性插值方式用5个采样点模拟9-tap高斯核</span></span><br><span class="line">            half3 c0 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - float2(<span class="number">0.0</span>, texelSize * <span class="number">3.23076923</span>)));</span><br><span class="line">            half3 c1 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv - float2(<span class="number">0.0</span>, texelSize * <span class="number">1.38461538</span>)));</span><br><span class="line">            half3 c2 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv                                      ));</span><br><span class="line">            half3 c3 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + float2(<span class="number">0.0</span>, texelSize * <span class="number">1.38461538</span>)));</span><br><span class="line">            half3 c4 = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv + float2(<span class="number">0.0</span>, texelSize * <span class="number">3.23076923</span>)));</span><br><span class="line"></span><br><span class="line">            half3 color = c0 * <span class="number">0.07027027</span> + c1 * <span class="number">0.31621622</span></span><br><span class="line">                        + c2 * <span class="number">0.22702703</span></span><br><span class="line">                        + c3 * <span class="number">0.31621622</span> + c4 * <span class="number">0.07027027</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> EncodeHDR(color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half3 <span class="title">Upsample</span><span class="params">(float2 uv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            half3 highMip = DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv));</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> _BLOOM_HQ &amp;&amp; !defined(SHADER_API_GLES)</span></span><br><span class="line">            half3 lowMip = DecodeHDR(SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_SourceTexLowMip, sampler_LinearClamp), uv, _SourceTexLowMip_TexelSize.zwxy, (<span class="number">1.0</span>).xx, unity_StereoEyeIndex));</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            half3 lowMip = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTexLowMip, sampler_LinearClamp, uv));</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lerp(highMip, lowMip, Scatter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragUpsample</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line">            half3 color = Upsample(UnityStereoTransformScreenSpaceTex(input.texcoord));</span><br><span class="line">            <span class="keyword">return</span> EncodeHDR(color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">"RenderType"</span> = <span class="string">"Opaque"</span> <span class="string">"RenderPipeline"</span> = <span class="string">"UniversalPipeline"</span>&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bloom Prefilter"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragPrefilter</span><br><span class="line">                #pragma multi_compile_local _ _BLOOM_HQ</span><br><span class="line">                #pragma multi_compile_fragment _ _FOVEATED_RENDERING_NON_UNIFORM_RASTER</span><br><span class="line">                <span class="comment">// Foveated rendering currently not supported in dxc on metal</span></span><br><span class="line">                #pragma never_use_dxc metal</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bloom Blur Horizontal"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragBlurH</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bloom Blur Vertical"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragBlurV</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"Bloom Upsample"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragUpsample</span><br><span class="line">                #pragma multi_compile_local _ _BLOOM_HQ</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="晕影效果vignette">晕影效果(Vignette)</h4>
<p>晕影效果（Vignette）是一种在图像边缘逐渐减弱亮度或增加饱和度的效果，通常用于突出图像中心或增加视觉焦点。实现晕影效果的后处理方法通常基于图像处理技术，其实现原理可以概括如下：</p>
<ol type="1">
<li><p><strong>基于距离的衰减：</strong>
一种常见的实现方法是根据像素与图像中心的距离来计算衰减系数，距离中心越远的像素，衰减系数越大。这样，在后处理过程中，可以根据像素与中心的距离来对像素的亮度或饱和度进行加权，使得边缘逐渐变暗或变饱和。</p></li>
<li><p><strong>径向函数：</strong>
晕影效果的实现也可以利用径向函数来描述衰减的形式，例如高斯函数或多项式函数。通过选择合适的径向函数参数，可以实现不同形式的晕影效果，例如较平滑的渐变或较陡峭的渐变。</p></li>
<li><p><strong>遮罩技术：</strong>
另一种实现晕影效果的方法是使用遮罩技术，即在图像上叠加一个透明的黑色或彩色遮罩，使得边缘透明度逐渐增加。通过调整遮罩的形状和透明度，可以实现不同形式的晕影效果。</p></li>
</ol>
<p><strong>C#代码</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置晕影参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupVignette</span>(<span class="params">Material material, XRPass xrPass</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = m_Vignette.color.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">var</span> center = m_Vignette.center.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">var</span> aspectRatio = m_Descriptor.width / (<span class="keyword">float</span>)m_Descriptor.height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> v1 = <span class="keyword">new</span> Vector4(</span><br><span class="line">        color.r, color.g, color.b,</span><br><span class="line">        m_Vignette.rounded.<span class="keyword">value</span> ? aspectRatio : <span class="number">1f</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> v2 = <span class="keyword">new</span> Vector4(</span><br><span class="line">        center.x, center.y,</span><br><span class="line">        m_Vignette.intensity.<span class="keyword">value</span> * <span class="number">3f</span>,</span><br><span class="line">        m_Vignette.smoothness.<span class="keyword">value</span> * <span class="number">5f</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    material.SetVector(ShaderConstants._Vignette_Params1, v1);</span><br><span class="line">    material.SetVector(ShaderConstants._Vignette_Params2, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">half3 <span class="title">ApplyVignette</span><span class="params">(half3 input, float2 uv, float2 center, <span class="keyword">float</span> intensity, <span class="keyword">float</span> roundness, <span class="keyword">float</span> smoothness, half3 color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    center = UnityStereoTransformScreenSpaceTex(center);</span><br><span class="line">    float2 dist = <span class="built_in">abs</span>(uv - center) * intensity;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(UNITY_SINGLE_PASS_STEREO)</span></span><br><span class="line">    dist.x /= unity_StereoScaleOffset[unity_StereoEyeIndex].x;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    dist.x *= roundness;</span><br><span class="line">    <span class="keyword">float</span> vfactor = <span class="built_in">pow</span>(saturate(<span class="number">1.0</span> - dot(dist, dist)), smoothness);</span><br><span class="line">    <span class="keyword">return</span> input * lerp(color, (<span class="number">1.0</span>).xxx, vfactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="胶片颗粒film-grain">胶片颗粒（Film Grain）</h4>
<p>胶片颗粒效果（Film
Grain）是一种模拟传统胶片摄影中出现的颗粒状噪点的效果，可以增加图像的质感和艺术感。实现胶片颗粒效果的后处理方法通常基于图像处理技术，其实现原理可以概括如下：</p>
<ol type="1">
<li><p><strong>随机噪声生成：</strong>
胶片颗粒效果的实现通常涉及生成随机的颗粒噪声。可以使用伪随机数生成器来生成服从特定分布（如高斯分布）的随机数序列，然后将这些随机数映射到图像像素上，以模拟胶片颗粒的分布。</p></li>
<li><p><strong>混合叠加：</strong>
生成的颗粒噪声可以与原始图像进行混合叠加。可以通过调整混合的透明度或混合模式（如叠加、乘法等）来控制颗粒效果的强度和影响范围。</p></li>
<li><p><strong>空间滤波：</strong>
在一些情况下，可以使用空间滤波技术来模拟胶片颗粒的空间分布特征。例如，可以使用卷积滤波器（如高斯滤波器）来对图像进行模糊处理，然后通过减去模糊图像和原始图像之间的差异来生成颗粒噪声。</p></li>
<li><p><strong>颗粒参数调整：</strong>
胶片颗粒效果的外观可以通过调整参数来控制，例如颗粒的大小、密度、形状和颜色等。通过调整这些参数，可以实现不同类型和风格的胶片颗粒效果。</p></li>
</ol>
<p><strong>C#代码</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConfigureFilmGrain</span>(<span class="params">PostProcessData data, FilmGrain settings, <span class="keyword">int</span> cameraPixelWidth, <span class="keyword">int</span> cameraPixelHeight, Material material</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> texture = settings.texture.<span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (settings.type.<span class="keyword">value</span> != FilmGrainLookup.Custom)</span><br><span class="line">        texture = data.textures.filmGrainTex[(<span class="keyword">int</span>)settings.type.<span class="keyword">value</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LWRP_DEBUG_STATIC_POSTFX</span></span><br><span class="line">    <span class="keyword">float</span> offsetX = <span class="number">0f</span>;</span><br><span class="line">    <span class="keyword">float</span> offsetY = <span class="number">0f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    Random.InitState(Time.frameCount);</span><br><span class="line">    <span class="keyword">float</span> offsetX = Random.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">float</span> offsetY = Random.<span class="keyword">value</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tilingParams = texture == <span class="literal">null</span></span><br><span class="line">        ? Vector4.zero</span><br><span class="line">        : <span class="keyword">new</span> Vector4(cameraPixelWidth / (<span class="keyword">float</span>)texture.width, cameraPixelHeight / (<span class="keyword">float</span>)texture.height, offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">    material.SetTexture(ShaderConstants._Grain_Texture, texture);</span><br><span class="line">    material.SetVector(ShaderConstants._Grain_Params, <span class="keyword">new</span> Vector2(settings.intensity.<span class="keyword">value</span> * <span class="number">4f</span>, settings.response.<span class="keyword">value</span>));</span><br><span class="line">    material.SetVector(ShaderConstants._Grain_TilingParams, tilingParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Shader代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">half3 <span class="title">ApplyGrain</span><span class="params">(half3 input, float2 uv, TEXTURE2D_PARAM(GrainTexture, GrainSampler), <span class="keyword">float</span> intensity, <span class="keyword">float</span> response, float2 scale, float2 offset, <span class="keyword">float</span> oneOverPaperWhite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 颗粒范围为 [0;1]，中性值为 0.5</span></span><br><span class="line">    half grain = SAMPLE_TEXTURE2D(GrainTexture, GrainSampler, uv * scale + offset).w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重映射范围 [-1;1]</span></span><br><span class="line">    grain = (grain - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于场景亮度的噪声响应曲线</span></span><br><span class="line">    <span class="keyword">float</span> lum = Luminance(input);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HDR_INPUT</span></span><br><span class="line">    lum *= oneOverPaperWhite;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    lum = <span class="number">1.0</span> - <span class="built_in">sqrt</span>(lum);</span><br><span class="line">    lum = lerp(<span class="number">1.0</span>, lum, response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input + input * grain * intensity * lum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="uber">Uber</h3>
<p>"Uber"一词通常用来形容一个综合性的或"全包"（all-in-one）的着色器或后处理效果，它集成了多种视觉效果和图形处理技术。
这种"Uber后处理效果"可能包括，但不限于，色彩校正、HDR（高动态范围）渲染、Bloom、晕影效果(Vignette)、光晕（Lens
Flares）、胶片颗粒（Film Grain）等多个组件。</p>
<p><strong>Shader代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Hidden/Universal Render Pipeline/UberPost"</span></span><br><span class="line">&#123;</span><br><span class="line">    HLSLINCLUDE</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> exclude_renderers gles</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _DISTORTION</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _CHROMATIC_ABERRATION</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _BLOOM_LQ _BLOOM_HQ _BLOOM_LQ_DIRT _BLOOM_HQ_DIRT</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _HDR_GRADING _TONEMAP_ACES _TONEMAP_NEUTRAL</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _FILM_GRAIN</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _DITHERING</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _GAMMA_20 _LINEAR_TO_SRGB_CONVERSION</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _USE_FAST_SRGB_LINEAR_CONVERSION</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_fragment _ _FOVEATED_RENDERING_NON_UNIFORM_RASTER</span></span><br><span class="line">        <span class="comment">// Foveated rendering currently not supported in dxc on metal</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> never_use_dxc metal</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_fragment _ DEBUG_DISPLAY</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_fragment _ SCREEN_COORD_OVERRIDE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ HDR_INPUT HDR_ENCODING</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HDR_ENCODING</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> HDR_INPUT 1 <span class="comment">// this should be defined when HDR_ENCODING is defined</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/ScreenCoordOverride.hlsl"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HDR_ENCODING)</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/HDROutput.hlsl"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/Shaders/PostProcessing/Common.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Debug/DebuggingFullscreen.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRendering.hlsl"</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hardcoded dependencies to reduce the number of variants</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> _BLOOM_LQ || _BLOOM_HQ || _BLOOM_LQ_DIRT || _BLOOM_HQ_DIRT</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">define</span> BLOOM</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _BLOOM_LQ_DIRT || _BLOOM_HQ_DIRT</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">define</span> BLOOM_DIRT</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        TEXTURE2D_X(_Bloom_Texture);</span><br><span class="line">        TEXTURE2D(_LensDirt_Texture);</span><br><span class="line">        TEXTURE2D(_Grain_Texture);</span><br><span class="line">        TEXTURE2D(_InternalLut);</span><br><span class="line">        TEXTURE2D(_UserLut);</span><br><span class="line">        TEXTURE2D(_BlueNoise_Texture);</span><br><span class="line">        TEXTURE2D_X(_OverlayUITexture);</span><br><span class="line"></span><br><span class="line">        float4 _Lut_Params;</span><br><span class="line">        float4 _UserLut_Params;</span><br><span class="line">        float4 _Bloom_Params;</span><br><span class="line">        <span class="keyword">float</span> _Bloom_RGBM;</span><br><span class="line">        float4 _LensDirt_Params;</span><br><span class="line">        <span class="keyword">float</span> _LensDirt_Intensity;</span><br><span class="line">        float4 _Distortion_Params1;</span><br><span class="line">        float4 _Distortion_Params2;</span><br><span class="line">        <span class="keyword">float</span> _Chroma_Params;</span><br><span class="line">        half4 _Vignette_Params1;</span><br><span class="line">        float4 _Vignette_Params2;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> USING_STEREO_MATRICES</span></span><br><span class="line">        float4 _Vignette_ParamsXR;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        float2 _Grain_Params;</span><br><span class="line">        float4 _Grain_TilingParams;</span><br><span class="line">        float4 _Bloom_Texture_TexelSize;</span><br><span class="line">        float4 _Dithering_Params;</span><br><span class="line">        float4 _HDROutputLuminanceParams;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DistCenter              _Distortion_Params1.xy</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DistAxis                _Distortion_Params1.zw</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DistTheta               _Distortion_Params2.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DistSigma               _Distortion_Params2.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DistScale               _Distortion_Params2.z</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DistIntensity           _Distortion_Params2.w</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ChromaAmount            _Chroma_Params.x</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> BloomIntensity          _Bloom_Params.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> BloomTint               _Bloom_Params.yzw</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> BloomRGBM               _Bloom_RGBM.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LensDirtScale           _LensDirt_Params.xy</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LensDirtOffset          _LensDirt_Params.zw</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LensDirtIntensity       _LensDirt_Intensity.x</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> VignetteColor           _Vignette_Params1.xyz</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> USING_STEREO_MATRICES</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> VignetteCenterEye0      _Vignette_ParamsXR.xy</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> VignetteCenterEye1      _Vignette_ParamsXR.zw</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> VignetteCenter          _Vignette_Params2.xy</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> VignetteIntensity       _Vignette_Params2.z</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> VignetteSmoothness      _Vignette_Params2.w</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> VignetteRoundness       _Vignette_Params1.w</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LutParams               _Lut_Params.xyz</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> PostExposure            _Lut_Params.w</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> UserLutParams           _UserLut_Params.xyz</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> UserLutContribution     _UserLut_Params.w</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainIntensity          _Grain_Params.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainResponse           _Grain_Params.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainScale              _Grain_TilingParams.xy</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainOffset             _Grain_TilingParams.zw</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DitheringScale          _Dithering_Params.xy</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DitheringOffset         _Dithering_Params.zw</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MinNits                 _HDROutputLuminanceParams.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MaxNits                 _HDROutputLuminanceParams.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> PaperWhite              _HDROutputLuminanceParams.z</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> OneOverPaperWhite       _HDROutputLuminanceParams.w</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// UV扭曲，部分后处理需要扭曲UV</span></span><br><span class="line">        <span class="function">float2 <span class="title">DistortUV</span><span class="params">(float2 uv)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _DISTORTION</span></span><br><span class="line">            &#123;</span><br><span class="line">                uv = (uv - <span class="number">0.5</span>) * DistScale + <span class="number">0.5</span>;</span><br><span class="line">                float2 ruv = DistAxis * (uv - <span class="number">0.5</span> - DistCenter);</span><br><span class="line">                <span class="keyword">float</span> ru = length(float2(ruv));</span><br><span class="line"></span><br><span class="line">                UNITY_BRANCH</span><br><span class="line">                <span class="keyword">if</span> (DistIntensity &gt; <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">float</span> wu = ru * DistTheta;</span><br><span class="line">                    ru = <span class="built_in">tan</span>(wu) * (rcp(ru * DistSigma));</span><br><span class="line">                    uv = uv + ruv * (ru - <span class="number">1.0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ru = rcp(ru) * DistTheta * <span class="built_in">atan</span>(ru * DistSigma);</span><br><span class="line">                    uv = uv + ruv * (ru - <span class="number">1.0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> uv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragUberPost</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line"></span><br><span class="line">            float2 uv = SCREEN_COORD_APPLY_SCALEBIAS(UnityStereoTransformScreenSpaceTex(input.texcoord));</span><br><span class="line">            float2 uvDistorted = DistortUV(uv);</span><br><span class="line"></span><br><span class="line">            half3 color = (<span class="number">0.0</span>).xxx;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//色差（Chromatic Aberration），也称为色彩像差，是一种由于镜头无法将不同颜色的光线聚焦在同一点上而产生的视觉现象。</span></span><br><span class="line">            <span class="comment">//这种现象在图像的边缘部分尤为明显，表现为彩色的晕边，通常是紫色或绿色的边缘。色差通常出现在便宜的镜头或极宽角镜头的照片中，而高质量的镜头设计会尽量减少这种效果。</span></span><br><span class="line">            <span class="comment">//边缘会有类似彩虹的色斑</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _CHROMATIC_ABERRATION</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//高清渲染管线（HDRP）中的色差的超快速版本，使用3个样本和硬编码的光谱LUT。在低端GPU上性能显著提升。</span></span><br><span class="line">                float2 coords = <span class="number">2.0</span> * uv - <span class="number">1.0</span>;</span><br><span class="line">                float2 <span class="built_in">end</span> = uv - coords * dot(coords, coords) * ChromaAmount;</span><br><span class="line">                float2 delta = (<span class="built_in">end</span> - uv) / <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">                half r = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(uvDistorted)                ).x;</span><br><span class="line">                half g = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(DistortUV(delta + uv)      )).y;</span><br><span class="line">                half b = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(DistortUV(delta * <span class="number">2.0</span> + uv))).z;</span><br><span class="line"></span><br><span class="line">                color = half3(r, g, b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                color = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(uvDistorted)).xyz;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Gamma 空间...只需将 Uber 的其余部分以线性方式进行，最后再转换回 sRGB</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_COLORSPACE_GAMMA</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = GetSRGBToLinear(color);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 泛光（Bloom）</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> defined(BLOOM)</span></span><br><span class="line">            &#123;</span><br><span class="line">                float2 uvBloom = uvDistorted;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> defined(_FOVEATED_RENDERING_NON_UNIFORM_RASTER)</span></span><br><span class="line">                    uvBloom = RemapFoveatedRenderingDistort(uvBloom);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> _BLOOM_HQ &amp;&amp; !defined(SHADER_API_GLES)</span></span><br><span class="line">                half4 bloom = SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_Bloom_Texture, sampler_LinearClamp), SCREEN_COORD_REMOVE_SCALEBIAS(uvBloom), _Bloom_Texture_TexelSize.zwxy, (<span class="number">1.0</span>).xx, unity_StereoEyeIndex);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                half4 bloom = SAMPLE_TEXTURE2D_X(_Bloom_Texture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(uvBloom));</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> UNITY_COLORSPACE_GAMMA</span></span><br><span class="line">                bloom.xyz *= bloom.xyz; <span class="comment">// γ to linear</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                UNITY_BRANCH</span><br><span class="line">                <span class="keyword">if</span> (BloomRGBM &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bloom.xyz = DecodeRGBM(bloom);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bloom.xyz *= BloomIntensity;</span><br><span class="line">                color += bloom.xyz * BloomTint;</span><br><span class="line"></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> defined(BLOOM_DIRT)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//污垢纹理的 UV 应该是 DistortUV(uv * DirtScale + DirtOffset)，但考虑到我们在污垢纹理上使用了覆盖式比例，差异并不大，因此我们选择在这里保存一些 ALU，以防镜头畸变处于活动状态 。</span></span><br><span class="line">                    half3 dirt = SAMPLE_TEXTURE2D(_LensDirt_Texture, sampler_LinearClamp, uvDistorted * LensDirtScale + LensDirtOffset).xyz;</span><br><span class="line">                    dirt *= LensDirtIntensity;</span><br><span class="line">                    color += dirt * bloom.xyz;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// To save on variants we'll use an uniform branch for vignette. Lower end platforms</span></span><br><span class="line">            <span class="comment">// don't like these but if we're running Uber it means we're running more expensive</span></span><br><span class="line">            <span class="comment">// effects anyway. Lower-end devices would limit themselves to on-tile compatible effect</span></span><br><span class="line">            <span class="comment">// and thus this shouldn't too much of a problem (famous last words).</span></span><br><span class="line">            <span class="comment">//为了节省变体，我们将使用统一的小插图分支。 低端平台不喜欢这些，但如果我们运行 Uber，这意味着我们无论如何都会运行更昂贵的效果。 低端设备会将自己限制为瓷砖兼容效果，因此这应该不是什么太大的问题（著名的遗言）。</span></span><br><span class="line">            UNITY_BRANCH</span><br><span class="line">            <span class="keyword">if</span> (VignetteIntensity &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                color = ApplyVignette(color, uvDistorted, VignetteCenter, VignetteIntensity, VignetteRoundness, VignetteSmoothness, VignetteColor);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 颜色修正</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = ApplyColorGrading(color, PostExposure, TEXTURE2D_ARGS(_InternalLut, sampler_LinearClamp), LutParams, TEXTURE2D_ARGS(_UserLut, sampler_LinearClamp), UserLutParams, UserLutContribution);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 胶片颗粒（Film Grain）</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _FILM_GRAIN</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = ApplyGrain(color, uv, TEXTURE2D_ARGS(_Grain_Texture, sampler_LinearRepeat), GrainIntensity, GrainResponse, GrainScale, GrainOffset, OneOverPaperWhite);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 Unity 配置为使用 gamma 颜色编码时，我们忽略转换为 gamma 2.0 的请求，而是回退到 sRGB 编码</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _GAMMA_20 &amp;&amp; !UNITY_COLORSPACE_GAMMA</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = LinearToGamma20(color);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Back to sRGB</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">elif</span> UNITY_COLORSPACE_GAMMA || _LINEAR_TO_SRGB_CONVERSION</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = GetLinearToSRGB(color);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Dithering（抖动）是一种在数字图像处理中常用的技术，用于在有限的颜色深度显示设备上模拟更广泛的颜色范围。这种技术通过在像素之间故意添加噪声或图案，来模拟中间色调或渐变效果，从而减少颜色带（色阶突变）的视觉影响。</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _DITHERING</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = ApplyDithering(color, uv, TEXTURE2D_ARGS(_BlueNoise_Texture, sampler_PointRepeat), DitheringScale, DitheringOffset, PaperWhite, OneOverPaperWhite);</span><br><span class="line">                <span class="comment">//假设颜色 &gt; 0 并防止 0 - ditherNoise。</span></span><br><span class="line">                <span class="comment">//如果通过渲染到 FP16 纹理反馈到后处理，负色可能会导致问题。</span></span><br><span class="line">                color = <span class="built_in">max</span>(color, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// HDR编码颜色</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> HDR_ENCODING</span></span><br><span class="line">            &#123;</span><br><span class="line">                float4 uiSample = SAMPLE_TEXTURE2D_X(_OverlayUITexture, sampler_PointClamp, input.texcoord);</span><br><span class="line">                color.rgb = SceneUIComposition(uiSample, color.rgb, PaperWhite, MaxNits);</span><br><span class="line">                color.rgb = OETF(color.rgb, MaxNits);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> half4(color, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"RenderType"</span> = <span class="string">"Opaque"</span> <span class="string">"RenderPipeline"</span> = <span class="string">"UniversalPipeline"</span></span><br><span class="line">        &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"UberPost"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragUberPost</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="finalpass">FinalPass</h3>
<p>FinalPass是在后处理Pass处理完后，对其进行最后一次修改，主要包括：HDR输出，升/降分辨率和应用各种抗锯齿算法(FXAA和TAA等)</p>
<p><strong>C#代码</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染最终Pass</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderFinalPass</span>(<span class="params">CommandBuffer cmd, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ref</span> <span class="keyword">var</span> cameraData = <span class="keyword">ref</span> renderingData.cameraData;</span><br><span class="line">    <span class="keyword">var</span> material = m_Materials.finalPass;</span><br><span class="line">    material.shaderKeywords = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置目标纹理大小（计算动态分辨率）</span></span><br><span class="line">    PostProcessUtils.SetSourceSize(cmd, cameraData.cameraTargetDescriptor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置Film Grain（胶片颗粒）</span></span><br><span class="line">    SetupGrain(<span class="keyword">ref</span> cameraData, material);</span><br><span class="line">    <span class="comment">//Dithering（抖动）</span></span><br><span class="line">    SetupDithering(<span class="keyword">ref</span> cameraData, material);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否需要转换回SRGB</span></span><br><span class="line">    <span class="keyword">if</span> (RequireSRGBConversionBlitToBackBuffer(<span class="keyword">ref</span> cameraData))</span><br><span class="line">        material.EnableKeyword(ShaderKeywordStrings.LinearToSRGBConversion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否输出HDR</span></span><br><span class="line">    HDROutputUtils.Operation hdrOperations = HDROutputUtils.Operation.None;</span><br><span class="line">    <span class="keyword">bool</span> requireHDROutput = RequireHDROutput(<span class="keyword">ref</span> cameraData);</span><br><span class="line">    <span class="keyword">if</span> (requireHDROutput)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If there is a final post process pass, it's always the final pass so do color encoding</span></span><br><span class="line">        hdrOperations = m_EnableColorEncodingIfNeeded ? HDROutputUtils.Operation.ColorEncoding : HDROutputUtils.Operation.None;</span><br><span class="line">        <span class="comment">// If the color space conversion wasn't applied by the uber pass, do it here</span></span><br><span class="line">        <span class="keyword">if</span> (!cameraData.postProcessEnabled)</span><br><span class="line">            hdrOperations |= HDROutputUtils.Operation.ColorConversion;</span><br><span class="line"></span><br><span class="line">        SetupHDROutput(cameraData.hdrDisplayInformation, cameraData.hdrDisplayColorGamut, material, hdrOperations);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置调式处理器</span></span><br><span class="line">    DebugHandler debugHandler = GetActiveDebugHandler(<span class="keyword">ref</span> renderingData);</span><br><span class="line">    <span class="keyword">bool</span> resolveToDebugScreen = debugHandler != <span class="literal">null</span> &amp;&amp; debugHandler.WriteToDebugScreenTexture(<span class="keyword">ref</span> cameraData);</span><br><span class="line">    debugHandler?.UpdateShaderGlobalPropertiesForFinalValidationPass(cmd, <span class="keyword">ref</span> cameraData, m_IsFinalPass &amp;&amp; !resolveToDebugScreen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_UseSwapBuffer)</span><br><span class="line">        m_Source = cameraData.renderer.GetCameraColorBackBuffer(cmd);</span><br><span class="line"></span><br><span class="line">    RTHandle sourceTex = m_Source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> colorLoadAction = cameraData.isDefaultViewport ? RenderBufferLoadAction.DontCare : RenderBufferLoadAction.Load;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isFxaaEnabled = (cameraData.antialiasing == AntialiasingMode.FastApproximateAntialiasing);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否FSR重采样是否开启</span></span><br><span class="line">    <span class="keyword">bool</span> isFsrEnabled = ((cameraData.imageScalingMode == ImageScalingMode.Upscaling) &amp;&amp; (cameraData.upscalingFilter == ImageUpscalingFilter.FSR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重复使用 RCAS 通道作为 TAA 的可选独立后锐化通道。 这避免了 EASU 的成本，并且可用于其他升级选项。如果启用 FSR，则 FSR 设置将覆盖 TAA 设置，并且我们仅执行一次 RCAS。</span></span><br><span class="line">    <span class="keyword">bool</span> isTaaSharpeningEnabled = (cameraData.IsTemporalAAEnabled() &amp;&amp; cameraData.taaSettings.contrastAdaptiveSharpening &gt; <span class="number">0.0f</span>) &amp;&amp; !isFsrEnabled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终渲染目标需要缩放</span></span><br><span class="line">    <span class="keyword">if</span> (cameraData.imageScalingMode != ImageScalingMode.None)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当在缩放渲染中启用 FXAA 时，我们在单独的 blit 中执行它，因为它不是设计用于在</span></span><br><span class="line">        <span class="comment">// 输入和输出分辨率不匹配的情况。</span></span><br><span class="line">        <span class="comment">// 当 FSR 处于活动状态时，我们总是需要额外的通道，因为它有非常特殊的颜色编码要求。</span></span><br><span class="line">            <span class="comment">// 注意：理想的实现可以将此颜色转换逻辑内联到 UberPost 通道中，但当前的代码结构会使</span></span><br><span class="line">            <span class="comment">// 这个过程非常复杂。 具体来说，我们需要保证 uber post 输出始终写入 UNORM 格式渲染</span></span><br><span class="line">            <span class="comment">// 目标是为了保留特殊编码的颜色数据的精度。</span></span><br><span class="line">        <span class="keyword">bool</span> isSetupRequired = (isFxaaEnabled || isFsrEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保从临时渲染目标中删除任何 MSAA 和附加的深度缓冲区</span></span><br><span class="line">        <span class="keyword">var</span> tempRtDesc = cameraData.cameraTargetDescriptor;</span><br><span class="line">        tempRtDesc.msaaSamples = <span class="number">1</span>;</span><br><span class="line">        tempRtDesc.depthBufferBits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择 UNORM 格式，因为我们已经执行了色调映射。 （值在0-1范围内）</span></span><br><span class="line">        <span class="comment">// 这可以提高精度，如果我们想在使用 FSR 时避免过度条带，这是必需的。</span></span><br><span class="line">        <span class="keyword">if</span> (!requireHDROutput)</span><br><span class="line">            tempRtDesc.graphicsFormat = UniversalRenderPipeline.MakeUnormRenderTextureGraphicsFormat();</span><br><span class="line"></span><br><span class="line">        m_Materials.scalingSetup.shaderKeywords = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//是否启用了FXAA抗锯齿或是否启用了FSR重采样</span></span><br><span class="line">        <span class="keyword">if</span> (isSetupRequired)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//需要HDR输出</span></span><br><span class="line">            <span class="keyword">if</span> (requireHDROutput)</span><br><span class="line">            &#123;</span><br><span class="line">                SetupHDROutput(cameraData.hdrDisplayInformation, cameraData.hdrDisplayColorGamut, m_Materials.scalingSetup, hdrOperations);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//启用了FXAA</span></span><br><span class="line">            <span class="keyword">if</span> (isFxaaEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Materials.scalingSetup.EnableKeyword(ShaderKeywordStrings.Fxaa);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//启用了FRS</span></span><br><span class="line">            <span class="keyword">if</span> (isFsrEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Materials.scalingSetup.EnableKeyword(hdrOperations.HasFlag(HDROutputUtils.Operation.ColorEncoding) ? ShaderKeywordStrings.Gamma20AndHDRInput : ShaderKeywordStrings.Gamma20);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Blit</span></span><br><span class="line">            RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_ScalingSetupTarget, tempRtDesc, FilterMode.Point, TextureWrapMode.Clamp, name: <span class="string">"_ScalingSetupTexture"</span>);</span><br><span class="line">            Blitter.BlitCameraTexture(cmd, m_Source, m_ScalingSetupTarget, colorLoadAction, RenderBufferStoreAction.Store, m_Materials.scalingSetup, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            sourceTex = m_ScalingSetupTarget;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据缩放模式（放大或缩小）</span></span><br><span class="line">        <span class="keyword">switch</span> (cameraData.imageScalingMode)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> ImageScalingMode.Upscaling:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在放大情况下，根据所选的放大过滤器设置材质关键字</span></span><br><span class="line">                <span class="comment">// 注意：如果启用了 FSR，无论当前渲染比例如何，我们都会沿着这条路径走下去。 我们这样做是因为</span></span><br><span class="line">                <span class="comment">// FSR 在 100% 比例下仍然提供视觉效果。 这也将实现 99% 和 100% 之间的过渡</span></span><br><span class="line">                <span class="comment">// 对于 FSR 与动态分辨率缩放一起使用的情况，缩放不太明显。</span></span><br><span class="line">                <span class="keyword">switch</span> (cameraData.upscalingFilter)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> ImageUpscalingFilter.Point:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//TAA 后锐化是 RCAS 通道，避免用点采样覆盖它。</span></span><br><span class="line">                        <span class="keyword">if</span>(!isTaaSharpeningEnabled)</span><br><span class="line">                            material.EnableKeyword(ShaderKeywordStrings.PointSampling);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> ImageUpscalingFilter.Linear:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//Shader的模式重采样算法，不做任何设置</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> ImageUpscalingFilter.FSR:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//FSR重采样</span></span><br><span class="line">                        m_Materials.easu.shaderKeywords = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">var</span> upscaleRtDesc = tempRtDesc;</span><br><span class="line">                        upscaleRtDesc.width = cameraData.pixelWidth;</span><br><span class="line">                        upscaleRtDesc.height = cameraData.pixelHeight;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// EASU</span></span><br><span class="line">                        RenderingUtils.ReAllocateIfNeeded(<span class="keyword">ref</span> m_UpscaledTarget, upscaleRtDesc, FilterMode.Point, TextureWrapMode.Clamp, name: <span class="string">"_UpscaledTexture"</span>);</span><br><span class="line">                        <span class="keyword">var</span> fsrInputSize = <span class="keyword">new</span> Vector2(cameraData.cameraTargetDescriptor.width, cameraData.cameraTargetDescriptor.height);</span><br><span class="line">                        <span class="keyword">var</span> fsrOutputSize = <span class="keyword">new</span> Vector2(cameraData.pixelWidth, cameraData.pixelHeight);</span><br><span class="line">                        FSRUtils.SetEasuConstants(cmd, fsrInputSize, fsrInputSize, fsrOutputSize);</span><br><span class="line"></span><br><span class="line">                        Blitter.BlitCameraTexture(cmd, sourceTex, m_UpscaledTarget, colorLoadAction, RenderBufferStoreAction.Store, m_Materials.easu, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// RCAS</span></span><br><span class="line">                        <span class="comment">// 如果可用，则使用覆盖值，否则使用默认值。</span></span><br><span class="line">                        <span class="keyword">float</span> sharpness = cameraData.fsrOverrideSharpness ? cameraData.fsrSharpness : FSRUtils.kDefaultSharpnessLinear;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 设置 RCAS 通道的参数，除非锐度值表明它不会产生任何影响。</span></span><br><span class="line">                        <span class="keyword">if</span> (cameraData.fsrSharpness &gt; <span class="number">0.0f</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// RCAS 在最后的 post blit 期间执行，但我们在这里设置参数是为了更好的逻辑分组。</span></span><br><span class="line">                            material.EnableKeyword(requireHDROutput ? ShaderKeywordStrings.EasuRcasAndHDRInput : ShaderKeywordStrings.Rcas);</span><br><span class="line">                            FSRUtils.SetRcasConstantsLinear(cmd, sharpness);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 更新源纹理以进行下一步操作</span></span><br><span class="line">                        sourceTex = m_UpscaledTarget;</span><br><span class="line">                        PostProcessUtils.SetSourceSize(cmd, upscaleRtDesc);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ImageScalingMode.Downscaling:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在缩小的情况下，我们不执行任何类型的过滤器覆盖逻辑，因为我们总是想要线性过滤</span></span><br><span class="line">                <span class="comment">// 它已经是着色器中的默认选项。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缩小尺寸时还禁用 TAA 后锐化通道。</span></span><br><span class="line">                isTaaSharpeningEnabled = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isFxaaEnabled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在未缩放的渲染中，FXAA 可以在 FinalPost 着色器中安全地执行</span></span><br><span class="line">        material.EnableKeyword(ShaderKeywordStrings.Fxaa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重用 RCAS 作为 TAA 的独立锐化过滤器。</span></span><br><span class="line">    <span class="comment">// 如果启用了 FSR，那么它会覆盖 TAA 设置，我们会跳过它。</span></span><br><span class="line">    <span class="keyword">if</span>(isTaaSharpeningEnabled)</span><br><span class="line">    &#123;</span><br><span class="line">        material.EnableKeyword(ShaderKeywordStrings.Rcas);</span><br><span class="line">        FSRUtils.SetRcasConstantsLinear(cmd, cameraData.taaSettings.contrastAdaptiveSharpening);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> cameraTarget = RenderingUtils.GetCameraTargetIdentifier(<span class="keyword">ref</span> renderingData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolveToDebugScreen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Blit 到调试器纹理而不是相机目标</span></span><br><span class="line">        Blitter.BlitCameraTexture(cmd, sourceTex, debugHandler.DebugScreenColorHandle, RenderBufferLoadAction.Load, RenderBufferStoreAction.Store, material, <span class="number">0</span>);</span><br><span class="line">        cameraData.renderer.ConfigureCameraTarget(debugHandler.DebugScreenColorHandle, debugHandler.DebugScreenDepthHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Blit到最终屏幕</span></span><br><span class="line">        RTHandleStaticHelpers.SetRTHandleStaticWrapper(cameraTarget);</span><br><span class="line">        <span class="keyword">var</span> cameraTargetHandle = RTHandleStaticHelpers.s_RTHandleWrapper;</span><br><span class="line">        RenderingUtils.FinalBlit(cmd, <span class="keyword">ref</span> cameraData, sourceTex, cameraTargetHandle, colorLoadAction, RenderBufferStoreAction.Store, material, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Shader代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Hidden/Universal Render Pipeline/FinalPost"</span></span><br><span class="line">&#123;</span><br><span class="line">    HLSLINCLUDE</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _POINT_SAMPLING _RCAS _EASU_RCAS_AND_HDR_INPUT</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _FXAA</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _FILM_GRAIN</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _DITHERING</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ _LINEAR_TO_SRGB_CONVERSION</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_fragment _ DEBUG_DISPLAY</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_fragment _ SCREEN_COORD_OVERRIDE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_local_fragment _ HDR_INPUT HDR_COLORSPACE_CONVERSION HDR_ENCODING HDR_COLORSPACE_CONVERSION_AND_ENCODING</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/ScreenCoordOverride.hlsl"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HDR_COLORSPACE_CONVERSION) || defined(HDR_ENCODING) || defined(HDR_COLORSPACE_CONVERSION_AND_ENCODING)</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> HDR_INPUT 1 <span class="comment">// this should be defined when HDR_COLORSPACE_CONVERSION or HDR_ENCODING are defined</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/ShaderLibrary/HDROutput.hlsl"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Debug/DebuggingFullscreen.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.universal/Shaders/PostProcessing/Common.hlsl"</span></span></span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_Grain_Texture);</span><br><span class="line">        TEXTURE2D(_BlueNoise_Texture);</span><br><span class="line">        TEXTURE2D_X(_OverlayUITexture);</span><br><span class="line"></span><br><span class="line">        float4 _SourceSize;</span><br><span class="line">        float2 _Grain_Params;</span><br><span class="line">        float4 _Grain_TilingParams;</span><br><span class="line">        float4 _Dithering_Params;</span><br><span class="line">        float4 _HDROutputLuminanceParams;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainIntensity          _Grain_Params.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainResponse           _Grain_Params.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainScale              _Grain_TilingParams.xy</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> GrainOffset             _Grain_TilingParams.zw</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DitheringScale          _Dithering_Params.xy</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> DitheringOffset         _Dithering_Params.zw</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MinNits                 _HDROutputLuminanceParams.x</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MaxNits                 _HDROutputLuminanceParams.y</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> PaperWhite              _HDROutputLuminanceParams.z</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> OneOverPaperWhite       _HDROutputLuminanceParams.w</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> SHADER_TARGET &gt;= 45</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">define</span> FSR_INPUT_TEXTURE _BlitTexture</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">define</span> FSR_INPUT_SAMPLER sampler_LinearClamp</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果定义了 HDR_INPUT，我们还必须在包含 FSR 公共标头之前定义 FSR_EASU_ONE_OVER_PAPER_WHITE。</span></span><br><span class="line">            <span class="comment">// URP 实际上并不使用 FinalPost 着色器中的 EASU，仅使用 RCAS。</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">define</span> FSR_EASU_ONE_OVER_PAPER_WHITE  OneOverPaperWhite</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Packages/com.unity.render-pipelines.core/Runtime/PostProcessing/Shaders/FSRCommon.hlsl"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function">half4 <span class="title">FragFinalPost</span><span class="params">(Varyings input)</span> : SV_Target</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line"></span><br><span class="line">            float2 uv = UnityStereoTransformScreenSpaceTex(input.texcoord);</span><br><span class="line">            float2 positionNDC = uv;</span><br><span class="line">            int2   positionSS  = uv * _SourceSize.xy;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _POINT_SAMPLING</span></span><br><span class="line">            half3 color = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_PointClamp, uv).xyz;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">elif</span> (_RCAS || _EASU_RCAS_AND_HDR_INPUT) &amp;&amp; SHADER_TARGET &gt;= 45</span></span><br><span class="line">            half3 color = ApplyRCAS(positionSS);</span><br><span class="line">            <span class="comment">// 当Unity配置为使用gamma颜色编码时，我们必须在执行RCAS后从线性转换回来。</span></span><br><span class="line">            <span class="comment">//（此着色器变体的输入颜色数据始终是线性编码的，因为 RCAS 需要它）</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _EASU_RCAS_AND_HDR_INPUT</span></span><br><span class="line">            <span class="comment">// Revert operation from ScalingSetup.shader</span></span><br><span class="line">            color.rgb = FastTonemapInvert(color.rgb) * PaperWhite;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_COLORSPACE_GAMMA</span></span><br><span class="line">            color = GetLinearToSRGB(color);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            half3 color = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv).xyz;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _FXAA</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = ApplyFXAA(color, positionNDC, positionSS, _SourceSize, _BlitTexture, PaperWhite, OneOverPaperWhite);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _FILM_GRAIN</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = ApplyGrain(color, SCREEN_COORD_APPLY_SCALEBIAS(positionNDC), TEXTURE2D_ARGS(_Grain_Texture, sampler_LinearRepeat), GrainIntensity, GrainResponse, GrainScale, GrainOffset, OneOverPaperWhite);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _LINEAR_TO_SRGB_CONVERSION</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = LinearToSRGB(color);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> _DITHERING</span></span><br><span class="line">            &#123;</span><br><span class="line">                color = ApplyDithering(color, SCREEN_COORD_APPLY_SCALEBIAS(positionNDC), TEXTURE2D_ARGS(_BlueNoise_Texture, sampler_PointRepeat), DitheringScale, DitheringOffset, PaperWhite, OneOverPaperWhite);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> HDR_COLORSPACE_CONVERSION</span></span><br><span class="line">            &#123;</span><br><span class="line">                color.rgb = RotateRec709ToOutputSpace(color.rgb) * PaperWhite;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> HDR_ENCODING</span></span><br><span class="line">            &#123;</span><br><span class="line">                float4 uiSample = SAMPLE_TEXTURE2D_X(_OverlayUITexture, sampler_PointClamp, input.texcoord);</span><br><span class="line">                color.rgb = SceneUIComposition(uiSample, color.rgb, PaperWhite, MaxNits);</span><br><span class="line">                color.rgb = OETF(color.rgb, MaxNits);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            half4 finalColor = half4(color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG_DISPLAY)</span></span><br><span class="line">            half4 debugColor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(CanDebugOverrideOutputColor(finalColor, uv, debugColor))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> debugColor;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Standard FinalPost shader variant with support for FSR</span></span><br><span class="line">    <span class="comment">/// Note: FSR requires shader target 4.5 because it relies on texture gather instructions</span></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">"RenderType"</span> = <span class="string">"Opaque"</span> <span class="string">"RenderPipeline"</span> = <span class="string">"UniversalPipeline"</span>&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"FinalPost"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragFinalPost</span><br><span class="line">                #pragma target <span class="number">4.5</span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Fallback version of FinalPost shader which lacks support for FSR</span></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">"RenderType"</span> = <span class="string">"Opaque"</span> <span class="string">"RenderPipeline"</span> = <span class="string">"UniversalPipeline"</span>&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">"FinalPost"</span></span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">                #pragma vertex Vert</span><br><span class="line">                #pragma fragment FragFinalPost</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>Unity的后处理系统主要包含三个部分：</p>
<ol type="1">
<li>Volume系统，主要负责后处理数据的编辑，包括不同Volume对象中的相交部分的插值计算。</li>
<li>URP的后处理Pass, 主要有三个Pass：生成LUT的Pass,
后处理Pass，FinalPass。Pass主要是计算和设置Shader中要用到的参数以及调用Blit</li>
<li>各种后处理Shader，处理图像。</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li><a
href="https://juejin.cn/post/7079995071986139167">你真的了解眼里所见的色彩吗？(一文总结RGB/HSV/Lab)</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/28741691?utm_id=0">数字图像处理之6大颜色空间</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/245646670">关于后处理效果的一些总结</a></li>
<li><a
href="https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">HSL和HSV色彩空间</a></li>
<li><a
href="https://face2ai.com/DIP-8-6-%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4-HSI-HSL-HSV-HSB/">【数字图像处理】8.6:彩色图像-色彩空间
HSI(HSL)、HSV(HSB)</a></li>
<li><a href="https://patents.google.com/patent/CN103065287A/en" target="_blank" rel="noopener">Image
enhancement algorithm based on hue, saturation, lightness (HSL) space
and self-adaptation inverse hyperbolic tangent function</a></li>
<li><a
href="https://docs.unity3d.com/Manual/PostProcessingOverview.html">Post-processing
and full-screen effects</a></li>
<li><a
href="https://docs.unrealengine.com/5.0/en-US/post-process-effects-in-unreal-engine/">Post
Process Effects</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/143811985">后期误区——白平衡，深藏不露的调色高手</a></li>
<li><a href="https://en.wikipedia.org/wiki/LMS_color_space" target="_blank" rel="noopener">LMS color
space</a></li>
<li><a
href="https://zh.wikipedia.org/wiki/CIE_1931%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">CIE
1931 XYZ色彩空间</a></li>
<li><a
href="https://www.youtube.com/watch?v=xIIegno5WJo">CIE1931色彩空间介绍</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Standard_illuminant#Illuminant_series_D">Standard
illuminant</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%90%8E%E5%A4%84%E7%90%86/" rel="tag"><i class="fa fa-tag"></i> 后处理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2023/04/02/Unity/Graphics/Photoshop%E5%9B%BE%E5%B1%82%E6%B7%B7%E5%90%88/" rel="next" title="Photoshop图层混合">
                  <i class="fa fa-chevron-left"></i> Photoshop图层混合
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2024/04/24/Unity/Optimization/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9F%BA%E7%A1%80/" rel="prev" title="性能优化-基础">
                  性能优化-基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#颜色"><span class="nav-number">1.</span> <span class="nav-text">颜色</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#颜色数据表示linearlogc"><span class="nav-number">1.1.</span> <span class="nav-text">颜色数据表示（Linear，LogC）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#颜色空间"><span class="nav-number">1.2.</span> <span class="nav-text">颜色空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xyz颜色空间"><span class="nav-number">1.2.1.</span> <span class="nav-text">XYZ颜色空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lms颜色空间"><span class="nav-number">1.2.2.</span> <span class="nav-text">LMS颜色空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rgb颜色空间"><span class="nav-number">1.2.3.</span> <span class="nav-text">RGB颜色空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cmycmyk颜色空间"><span class="nav-number">1.2.4.</span> <span class="nav-text">CMY&#x2F;CMYK颜色空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lab颜色空间"><span class="nav-number">1.2.5.</span> <span class="nav-text">Lab颜色空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hsvhsb颜色空间"><span class="nav-number">1.2.6.</span> <span class="nav-text">HSV&#x2F;HSB颜色空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hsihsl颜色空间"><span class="nav-number">1.2.7.</span> <span class="nav-text">HSI&#x2F;HSL颜色空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hsvhsb与hsihsl颜色空间对比"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">HSV&#x2F;HSB与HSI&#x2F;HSL颜色空间对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hsv出现的动机"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">HSV出现的动机</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#抗锯齿anti-aliasing-aa"><span class="nav-number">2.</span> <span class="nav-text">抗锯齿（Anti-aliasing, AA）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全屏抗锯齿fsaafull-screen-anti-aliasing"><span class="nav-number">2.1.</span> <span class="nav-text">全屏抗锯齿（FSAA，Full
Screen Anti-Aliasing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超采样抗锯齿ssaasuper-sample-anti-aliasing"><span class="nav-number">2.2.</span> <span class="nav-text">超采样抗锯齿（SSAA，Super-Sample
Anti-Aliasing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重采样抗锯齿msaamulti-sample-anti-aliasing"><span class="nav-number">2.3.</span> <span class="nav-text">多重采样抗锯齿（MSAA，Multi-Sample
Anti-Aliasing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速近似抗锯齿fxaafast-approximate-anti-aliasing"><span class="nav-number">2.4.</span> <span class="nav-text">快速近似抗锯齿（FXAA，Fast
Approximate Anti-Aliasing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子像素抗锯齿smaasubpixel-morphological-anti-aliasing"><span class="nav-number">2.5.</span> <span class="nav-text">子像素抗锯齿（SMAA，Subpixel
Morphological Anti-Aliasing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间抗锯齿taatemporal-anti-aliasing"><span class="nav-number">2.6.</span> <span class="nav-text">时间抗锯齿（TAA，Temporal
Anti-Aliasing）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#urp后处理源码分析"><span class="nav-number">3.</span> <span class="nav-text">URP后处理源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volume系统"><span class="nav-number">3.1.</span> <span class="nav-text">Volume系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化类"><span class="nav-number">3.1.1.</span> <span class="nav-text">持久化类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volumeprofile"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">VolumeProfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volumecomponent"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">VolumeComponent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volumeparameter"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">VolumeParameter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时类"><span class="nav-number">3.1.2.</span> <span class="nav-text">运行时类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volumestack"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">VolumeStack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volumemanager"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">VolumeManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volume"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">Volume</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#postprocesspasses和postprocesspass"><span class="nav-number">3.2.</span> <span class="nav-text">PostProcessPasses和PostProcessPass</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#colorgradinglutpass"><span class="nav-number">3.2.1.</span> <span class="nav-text">ColorGradingLutPass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#postprocesspass"><span class="nav-number">3.2.2.</span> <span class="nav-text">PostProcessPass</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内建后处理shader"><span class="nav-number">3.3.</span> <span class="nav-text">内建后处理Shader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#色彩校正色彩调整"><span class="nav-number">3.3.1.</span> <span class="nav-text">色彩校正(色彩调整)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebalance白平衡"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">WhiteBalance（白平衡）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#coloradjustments颜色调整"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">ColorAdjustments（颜色调整）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#channelmixer通道混合"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">ChannelMixer(通道混合)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shadowsmidtoneshighlights阴影中间调高光"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">ShadowsMidtonesHighlights(阴影，中间调，高光)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#liftgammagain提升伽马增强"><span class="nav-number">3.3.1.5.</span> <span class="nav-text">LiftGammaGain（提升，伽马，增强）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#colorcurves颜色曲线"><span class="nav-number">3.3.1.6.</span> <span class="nav-text">ColorCurves（颜色曲线）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tonemapping色调映射"><span class="nav-number">3.3.1.7.</span> <span class="nav-text">Tonemapping（色调映射）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视觉效果vfx"><span class="nav-number">3.3.2.</span> <span class="nav-text">视觉效果（VFX）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#景深depth-of-fielddof"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">景深（Depth of Field，DOF）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运动模糊motion-blur"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">运动模糊（Motion Blur）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#panini投影panini-projection"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">Panini投影（Panini
Projection）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛光bloom"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">泛光（Bloom）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#晕影效果vignette"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">晕影效果(Vignette)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#胶片颗粒film-grain"><span class="nav-number">3.3.2.6.</span> <span class="nav-text">胶片颗粒（Film Grain）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uber"><span class="nav-number">3.3.3.</span> <span class="nav-text">Uber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalpass"><span class="nav-number">3.3.4.</span> <span class="nav-text">FinalPass</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张卫"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">张卫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/zw514159799" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;zw514159799" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Divad1111?tab=repositories" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Divad1111?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/qilezaitu" title="博客园 &amp;rarr; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;qilezaitu" rel="noopener" target="_blank"><i class="fa fa-fw fa-cnblogs"></i>博客园</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张卫</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">542k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:13</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
