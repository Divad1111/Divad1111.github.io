<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="组成原理 在计算机科学中，组成原理通常指的是计算机系统的基本组成部分，比如主板 (Motherboard)、中央处理器（CPU）、存储器（内存）、输入&#x2F;输出设备等，并且涉及到它们之间的连接和交互。本节主要介绍一下PC和手机的组成部件，以及它们的作用。 PC 主板 (Motherboard) 主板 (Motherboard)主要由BIOS、总线、扩展插槽、芯片组和I&#x2F;O端口等组成。   主板图">
<meta property="og:type" content="article">
<meta property="og:title" content="性能优化-基础">
<meta property="og:url" content="http://yoursite.com/2024/04/24/Unity/Optimization/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="张卫的博客">
<meta property="og:description" content="组成原理 在计算机科学中，组成原理通常指的是计算机系统的基本组成部分，比如主板 (Motherboard)、中央处理器（CPU）、存储器（内存）、输入&#x2F;输出设备等，并且涉及到它们之间的连接和交互。本节主要介绍一下PC和手机的组成部件，以及它们的作用。 PC 主板 (Motherboard) 主板 (Motherboard)主要由BIOS、总线、扩展插槽、芯片组和I&#x2F;O端口等组成。   主板图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/mainborad.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/ufs_speed.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/ufs_vs_emmc.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/ahci_vs_nvme.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/scsi_achi_nvme.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/emmc_ufs_nvme.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/elf-file-format.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/elf-similar-merge.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/profiler-window-layout.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/file_access.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/asset_loading.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/memory_i.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/memory_p.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/memory_p_u.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/memory_p_a.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/cpu.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/rendering.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/ui.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/physics.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/physics2d.png">
<meta property="og:image" content="http://yoursite.com/images/unity/optimization/Profiler_Tank_details.png">
<meta property="article:published_time" content="2024-04-24T04:09:28.000Z">
<meta property="article:modified_time" content="2025-07-05T03:04:21.599Z">
<meta property="article:author" content="张卫">
<meta property="article:tag" content="优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/unity/optimization/mainborad.png">

<link rel="canonical" href="http://yoursite.com/2024/04/24/Unity/Optimization/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>性能优化-基础 | 张卫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张卫的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Done is better than perfect</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/04/24/Unity/Optimization/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="张卫">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张卫的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          性能优化-基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-24 12:09:28" itemprop="dateCreated datePublished" datetime="2024-04-24T12:09:28+08:00">2024-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-05 11:04:21" itemprop="dateModified" datetime="2025-07-05T11:04:21+08:00">2025-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index">
                    <span itemprop="name">Unity</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="组成原理">组成原理</h1>
<p>在计算机科学中，组成原理通常指的是计算机系统的基本组成部分，比如主板
(Motherboard)、中央处理器（CPU）、存储器（内存）、输入/输出设备等，并且涉及到它们之间的连接和交互。本节主要介绍一下PC和手机的组成部件，以及它们的作用。</p>
<h2 id="pc">PC</h2>
<h3 id="主板-motherboard">主板 (Motherboard)</h3>
<p>主板
(Motherboard)主要由BIOS、总线、扩展插槽、芯片组和I/O端口等组成。</p>
<figure>
<img src="/images/unity/optimization/mainborad.png" alt="主板图" />
<figcaption aria-hidden="true">主板图</figcaption>
</figure>
<a id="more"></a>
<h4 id="bios">BIOS</h4>
<p>BIOS（Basic Input/Output
System）是计算机系统中的一个重要组成部分，它是一组固化在计算机主板上的软件程序，负责在计算机启动时初始化硬件设备、进行自检（POST，Power-On
Self-Test）、加载操作系统等关键任务。下面是对BIOS的详细介绍：</p>
<ol type="1">
<li><strong>功能：</strong></li>
</ol>
<ul>
<li>初始化硬件：BIOS负责初始化计算机中的各种硬件设备，包括处理器、内存、硬盘、显卡、键盘、鼠标等。</li>
<li>自检（POST）：在计算机开机时，BIOS会进行自检，检测系统中各个硬件设备是否正常工作。</li>
<li>提供基本输入/输出功能：BIOS提供了基本的输入/输出功能，使得计算机能够与外部设备（如键盘、显示器、存储设备）进行通信。</li>
<li>启动操作系统：BIOS负责在计算机启动时加载操作系统的启动程序，将控制权转交给操作系统，使其能够运行。</li>
</ul>
<ol start="2" type="1">
<li><strong>存储位置：</strong></li>
</ol>
<ul>
<li>BIOS通常存储在计算机主板上的闪存芯片中，这种闪存通常被称为“BIOS芯片”或“CMOS芯片”。</li>
<li>在一些早期的计算机中，BIOS可能存储在EEPROM（Electrically Erasable
Programmable Read-Only Memory）芯片或ROM芯片中。</li>
</ul>
<ol start="3" type="1">
<li><strong>用户界面：</strong></li>
</ol>
<ul>
<li>传统的BIOS具有文本界面，用户可以通过键盘输入命令来配置和管理BIOS设置。</li>
<li>近年来，随着UEFI（Unified Extensible Firmware
Interface，统一可扩展固件接口）的普及，许多计算机开始使用UEFI
BIOS，它提供了更现代化和图形化的用户界面，使得用户能够更直观地进行设置和配置。</li>
</ul>
<h4 id="总线">总线</h4>
<p>一台电脑由多个电子元器件组成，如CPU，内存，硬盘等，各元器件之间往往需要相互传递数据。
<strong>数据传输的公用通道，就是总线。</strong>
区分总线承载能力的名词叫<strong>带宽</strong>,也就是单位时间内能传输的数据量。
常见的总线(通道)有<strong>SATA</strong>和<strong>PCIe</strong>。</p>
<ul>
<li><strong>SATA</strong>总线常见的就是SATA3.0，理论最高速度只有6Gbps，此类接口的固态硬盘理论传输速度为600M/s；</li>
<li><strong>PCIe</strong>总线参见的有PCIe3.0和PCIe4.0,通道数量不同，速度也会不同。以PCIe3.0x4通道总线来说，它的带宽高达32Gbps,此类接口的固态硬盘实际传输速度可以轻松突破1000MB/s,顶级产品甚至可以达到4000MB/s以上；
综上，<strong>同为固态硬盘，走的是哪种总线，至关重要</strong>。</li>
</ul>
<h5 id="协议">协议</h5>
<p>有了传输的通道，
那么就要定义传输通道将如何传输数据，<strong>这种传输数据的规则就叫协议</strong>。
目前，硬盘常用的协议，主要有<strong>AHCI</strong>和<strong>NVMe</strong>两种。
<strong>NVMe</strong>与<strong>AHCI</strong>都是逻辑设备接口的一种标准，不过<strong>NVMe</strong>相比<strong>AHCI</strong>在延时性、功耗、IPOS等一些方面性能要强。
不过，并非是说<strong>NVMe</strong>协议的固态硬盘一定比<strong>AHCI</strong>协议的速度快，具体的速度还要看走的是哪种总线，以及硬盘本身的性能。</p>
<h5 id="接口">接口</h5>
<p>最后，我们来看一下固态硬盘的接口。
上面谈到的总线和协议，都是看不见摸不着的理论，因此，我们需要物理层面的接口，将硬盘与电脑连接起来。
最常见的硬盘接口，主要是<strong>SATA接口</strong>以及<strong>M.2接口</strong>。</p>
<ul>
<li><strong>SATA接口</strong>，主流硬盘接口之一，是Serial
ATA的缩写，即串行ATA。它是一种电脑总线，主要功能是用作主板和大量存储设备（如硬盘及光盘驱动器）之间的数据传输。</li>
<li><strong>M.2接口</strong>，又称为NGFF（老名字），是新一代接口标准，拥有比SATA接口更小的尺寸，同时提供<strong>更高的传输性能</strong>。按金手指的类型，M.2接口又细分为M-Key和B-Key，B&amp;M-Key。</li>
</ul>
<h4 id="芯片组">芯片组</h4>
<p>在早期的计算机主板中，北桥和南桥是两个独立的芯片，它们分别负责不同的任务。北桥芯片主要负责与处理器、内存和显卡之间的通信，而南桥芯片则负责与硬盘、USB设备和其他低速设备之间的通信。然而，随着技术的发展，现代计算机主板上已经不再使用北桥和南桥这两个独立的芯片了。取而代之的是将它们集成到单一的芯片组中，例如Intel的Z系列芯片组。
这种集成设计使得处理器、内存、显卡、硬盘、USB设备和其他设备之间的通信更加高效和可靠。通过将北桥和南桥的功能集成到单一芯片组中，主板制造商可以更好地控制硬件的兼容性和性能，同时也可以减少主板上的芯片数量，降低成本和功耗。
虽然北桥和南桥的概念已经逐渐被淘汰，但在一些特殊情况下，仍然需要使用到南桥芯片。例如，某些高级的USB设备可能需要直接与南桥芯片通信，因此在一些高端主板上仍然保留了南桥芯片。但是，这些南桥芯片的功能通常已经被大大简化，只负责一些基本的输入/输出任务。
总之，现代计算机主板上已经不再使用北桥和南桥这两个独立的芯片了。取而代之的是将它们集成到单一的芯片组中，这种设计使得硬件的兼容性和性能得到更好的保障，同时也可以降低成本和功耗。</p>
<h3 id="中央处理器-cpu">中央处理器 (CPU)</h3>
<p>中央处理器（CPU）是计算机系统中最重要的组件之一，其性能和功能直接影响到计算机的运行速度和能力。以下是CPU的主要参数：</p>
<ol type="1">
<li><strong>核心数量（Cores）：</strong></li>
</ol>
<ul>
<li>CPU的核心数量指的是处理器内部包含的独立处理单元的数量。每个核心都可以执行独立的指令流，因此核心数量直接影响到CPU的多任务处理能力和并行计算能力。</li>
<li>多核处理器可以同时处理多个任务，提高系统的整体性能。</li>
</ul>
<ol start="2" type="1">
<li><strong>线程数量（Threads）：</strong></li>
</ol>
<ul>
<li>线程数量指的是CPU能够同时执行的线程数量。线程是指在操作系统中独立调度和执行的基本执行单元。</li>
<li>超线程技术可以使得单个物理核心模拟出多个逻辑核心，从而提高处理器的线程并发能力，增加系统的多任务处理性能。</li>
</ul>
<ol start="3" type="1">
<li><strong>时钟频率（Clock Speed）：</strong></li>
</ol>
<ul>
<li>时钟频率指的是CPU内部时钟的运行速度，通常以赫兹（Hz）为单位表示。时钟频率越高，CPU执行指令的速度就越快。</li>
<li>虽然时钟频率是CPU性能的重要指标之一，但不同架构和制造工艺的CPU之间不能直接比较。因此，时钟频率并不是唯一决定性能的因素。</li>
</ul>
<ol start="4" type="1">
<li><strong>缓存大小（Cache Size）：</strong></li>
</ol>
<ul>
<li>缓存是CPU内部用于临时存储数据和指令的高速存储器。它可以加速CPU对常用数据和指令的访问，提高系统的响应速度和整体性能。</li>
<li>CPU通常包含多级缓存（如L1、L2、L3缓存），缓存大小对CPU的性能和成本都有重要影响。</li>
</ul>
<ol start="5" type="1">
<li><strong>制造工艺（Manufacturing Process）：</strong></li>
</ol>
<ul>
<li>制造工艺指的是CPU芯片的制造工艺技术，包括晶体管的尺寸和布局等。制造工艺的进步可以使得CPU在相同尺寸下集成更多的晶体管，提高性能和能效。</li>
<li>常见的制造工艺包括14纳米、10纳米、7纳米等。</li>
</ul>
<ol start="6" type="1">
<li><strong>指令集架构（Instruction Set
Architecture，ISA）：</strong></li>
</ol>
<ul>
<li>指令集架构定义了CPU支持的指令集合和指令执行方式。常见的指令集架构包括x86、x86-64（AMD64）、ARM等。</li>
<li>指令集架构决定了软件在CPU上的运行兼容性和性能表现。</li>
</ul>
<h3 id="内存-ram">内存 (RAM)</h3>
<p>内存（RAM，Random Access
Memory）技术包括多种类型，每种类型都有不同的特点、优势和用途。以下是几种常见的内存技术及其区别：</p>
<ol type="1">
<li><strong>DRAM（Dynamic Random Access Memory）：</strong></li>
</ol>
<ul>
<li>DRAM是一种动态随机存取存储器，它使用电容来存储数据，并且需要周期性地刷新以保持数据的有效性。</li>
<li>主要分为SDRAM（Synchronous DRAM）、DDR（Double Data
Rate）、DDR2、DDR3、DDR4和DDR5等几个主要代数。每一代DDR内存都在数据传输速度、功耗和密度等方面有所改进。</li>
<li>区别在于每一代DDR内存的频率、带宽和时序参数有所不同，随着代数的增加，内存的性能和功耗都得到了提升。</li>
</ul>
<ol start="2" type="1">
<li><strong>SRAM（Static Random Access Memory）：</strong></li>
</ol>
<ul>
<li>SRAM是一种静态随机存取存储器，它使用触发器（flip-flops）作为存储单元，相比DRAM，SRAM的访问速度更快，但成本更高。</li>
<li>SRAM通常用于高性能的缓存和寄存器文件等需要快速访问的应用，如CPU缓存和高性能存储器。</li>
</ul>
<h3 id="图形处理器-gpu">图形处理器 (GPU)</h3>
<p>GPU（图形处理器）是一种专门设计用于处理图形和图像相关任务的处理器。它们最初是为了处理计算机图形渲染而设计的，但随着技术的发展，GPU
在其他领域也发挥着越来越重要的作用，如科学计算、深度学习、数据分析等。</p>
<p><strong>GPU主要有以下几个组件：</strong></p>
<ol type="1">
<li><strong>处理器核心：</strong>GPU
中包含大量的处理器核心，每个核心都能够执行特定的计算任务。这些核心通常被设计成多线程，并能够同时处理多个数据。</li>
<li><strong>内存：</strong>GPU
配备自己的内存，用于存储图形数据、纹理和其他计算所需的数据。这些内存通常是高速且具有大容量。</li>
<li><strong>显存控制器：</strong>负责管理 GPU
内存的访问和分配，以确保高效的数据传输和处理。</li>
<li><strong>图形管线：</strong>图形管线是 GPU
中用于处理图形渲染任务的主要组件之一。它包括顶点处理、几何处理、光栅化、像素处理等阶段，用于将图形数据转换成最终的图像输出。</li>
<li><strong>纹理单元：</strong>用于处理纹理映射和纹理滤波等任务的单元，以提高图形渲染的质量和效率。</li>
<li><strong>渲染输出单元</strong>：负责将处理后的图像数据输出到显示器或存储设备，以供用户观看或后续处理。</li>
</ol>
<h3 id="存储设备-storage">存储设备 (Storage)</h3>
<p>存储设备是计算机系统中用于存储数据的硬件设备。它们允许用户将数据永久地保存在计算机中，并在需要时进行访问和检索。存储设备通常根据其内部技术、容量、速度和用途等因素进行分类。以下是存储设备的一些常见类型和特点：</p>
<p><strong>主要类型：</strong></p>
<ol type="1">
<li><strong>硬盘驱动器（HDD）：</strong></li>
</ol>
<ul>
<li>使用旋转磁盘和磁头来读写数据。</li>
<li>相对较大的存储容量，但读写速度相对较慢。</li>
<li>适用于大容量存储和长期存储。</li>
</ul>
<ol start="2" type="1">
<li><strong>固态硬盘（SSD）：</strong></li>
</ol>
<ul>
<li>使用闪存存储器来存储数据，无机械运动部件。</li>
<li>读写速度快，响应时间短。</li>
<li>耐用性好，不容易受到震动和冲击的影响。</li>
<li>适用于需要高速读写和响应的应用，如操作系统和应用程序。</li>
</ul>
<ol start="3" type="1">
<li><strong>光盘驱动器：</strong></li>
</ol>
<ul>
<li>使用激光技术读写数据，包括 CD、DVD 和 Blu-ray 等。</li>
<li>适用于光盘媒体上的数据存储和传输。</li>
</ul>
<ol start="4" type="1">
<li><strong>闪存驱动器（USB 存储设备）：</strong></li>
</ol>
<ul>
<li>使用闪存存储器来存储数据。</li>
<li>便携小巧，易于携带和使用。</li>
<li>适用于临时数据传输和备份。</li>
</ul>
<ol start="5" type="1">
<li><strong>网络存储（NAS）：</strong></li>
</ol>
<ul>
<li>使用专用存储设备连接到网络，可以通过网络访问存储的数据。</li>
<li>可以提供共享文件存储、数据备份、远程访问等功能。</li>
</ul>
<h2 id="手机">手机</h2>
<p>手机相比于电脑，集成度就更高。手机也是通过主板链接各个硬件系统，其他中包括：</p>
<ol type="1">
<li><strong>主板（Motherboard）：</strong>主板是手机的核心组件，包含处理器（CPU）、内存（RAM）、存储芯片（ROM）、通信芯片、传感器等重要部件。</li>
<li><strong>显示屏幕（Display
Screen）：</strong>显示屏通常是手机的最大部分，用于显示图像、文字和视频等内容。它可以是LCD（液晶显示器）、OLED（有机发光二极管）或AMOLED（主动矩阵有机发光二极管）等技术。</li>
<li><strong>外壳（Casing）：</strong>外壳是手机的外部框架，用于保护内部电子元件和提供结构支撑。它通常由塑料、金属或玻璃等材料制成。</li>
<li><strong>电池（Battery）：</strong>电池提供手机所需的电力。它通常是可充电的锂离子电池，尺寸和容量会根据手机型号和设计而有所不同。</li>
<li><strong>摄像头（Camera）：</strong>现代手机通常配备前置摄像头和后置摄像头，用于拍摄照片和视频通话。</li>
<li><strong>扬声器和麦克风（Speakers and
Microphones）：</strong>扬声器用于播放音频，麦克风用于接收声音并进行通话或录音。</li>
<li><strong>连接器（Connectors）：</strong>手机通常具有充电端口、耳机插孔、SIM卡插槽和扩展存储卡插槽等连接器，用于连接外部设备和提供扩展功能。</li>
<li><strong>天线（Antennas）：</strong>天线用于接收和发送无线信号，包括Wi-Fi、蓝牙、GPS和移动网络信号等。</li>
</ol>
<p><strong>主板上核心的就是SOC，全称“System On
Chip”，翻译成中文应该叫“片上系统”，通俗来讲，它表示“所有功能集成在一片上”，我们常说的“骁龙855”，“麒麟980”就是SOC。SOC主要包括：</strong></p>
<ol type="1">
<li><strong>中央处理（CPU）</strong>，负责执行手机上的各种计算任务。处理器的性能直接影响到手机的运行速度和响应能力。ARM是常见的处理器架构。</li>
<li><strong>图像处理器（GPU）</strong>，图形处理器负责处理手机上的图形和视觉内容，包括游戏、视频播放和图形用户界面等。它能够加速图形渲染和处理复杂的图形效果。</li>
<li><strong>嵌入式神经网络处理器（NPU）</strong>，它的全称叫neural-network
process
units，这个名字听起来很高端，简单来说，它主要负责负责处理涉及神经网络算法和机器学习的海量数据，因为神经网络算法及机器学习需要涉及海量的信息处理，而当下的
CPU / GPU
都无法达到如此高效的处理能力，需要一个独立的处理芯片来做这个事，才有NPU的诞生。现在的“人工智能”AI的概念可以说非常火热，而NPU就是让手机变得更智能，更聪明的必要条件。</li>
<li><strong>图像处理器（ISP）</strong>，全称Image Signal
Processor，不是GPU的“图形处理器”！它负责接收感光原件CMOS的原始数据，对这些数据做出“粗加工”，得到最后我们看到的照片，ISP需要与CMOS匹配。</li>
<li><strong>基带（Baseband）</strong>,
基带的核心就是调制解调器（Modem）,这个调制解调器主要的作用就是负责信号传输，所谓调制，就是把需要传输的信号，通过一定的规则调制到载波上面让后通过无线收发器发送出去的工程，解调就是相反的过程，等于说它把基站的语言“翻译成”手机能懂的，让二者能够“顺畅交流”，我们用户就能接打电话，连接网络了。</li>
<li><strong>协处理器(Coprocessor)</strong>,
这是一种协助中央处理器完成其无法执行，或执行效率、效果低下的处理工作而开发和应用之处理器。这种中央处理器无法执行的工作有很多，比如设备间的信号传输、接入设备的管理等；而执行效率、效果低下的有图形处理、声频处理等。为了进行这些处理，各种辅助处理器就诞生了。</li>
<li><strong>数字信号处理器(DSP)</strong>, 它全称叫Digital Signal
Processor，它不仅仅应用在手机，在雷达、通信、图像处理、医疗电子、工业机器人等高密集计算领域皆有广泛应用，手机上而言，主要负责语音，包括通话和语音输入，也负责一些图像处理的任务。</li>
<li><strong>内存(Memory)</strong>，仅提供支持的内存类型，并非代表SOC芯片里也集成了内存。除了内存之外，SOC也能影响所用的闪存类型，比如有的SOC只能用eMMC闪存。</li>
<li><strong>闪存(Flash)</strong>，仅提供支持的内存类型,
闪存对应的PC的硬盘。</li>
</ol>
<h3 id="arm结构">ARM结构</h3>
<p>说到移动平台就不得不提ARM，ARM（Advanced RISC
Machines）是一家总部位于英国剑桥的半导体和软件设计公司，成立于1990年。ARM
以设计低功耗、高性能的 RISC（Reduced Instruction Set
Computing）架构处理器而闻名。该公司的处理器架构被广泛应用于移动设备、智能手机、平板电脑、物联网设备、汽车电子、嵌入式系统以及工业控制等领域。</p>
<p>ARM 公司的一些关键特点和业务范围：</p>
<p>处理器设计：ARM 设计了一系列低功耗、高性能的处理器架构，包括
Cortex-A、Cortex-R 和 Cortex-M
系列，覆盖了从高性能应用到嵌入式系统的广泛范围。
授权模式：ARM的授权方式分为TLA（技术许可协议）和ALA（架构许可协议）两类：TLA是指客户直接购买Arm的IP来用，可以在上面进行部分修改，比如高通的骁龙系列芯片；ALA则允许客户基于Arm架构下的指令集来自行设计IP，开发定制处理器内核，苹果芯片就是典型代表
生态系统：ARM
拥有庞大的合作伙伴和生态系统，包括芯片设计厂商、芯片制造厂商、软件开发者、系统集成商等。这些合作伙伴共同推动了
ARM 技术的发展和应用，并且为客户提供了全方位的技术支持和解决方案。
物联网和智能化：随着物联网和智能化技术的快速发展，ARM
公司致力于为物联网设备、智能家居、智能城市等领域提供先进的处理器架构和解决方案，推动智能化应用的普及和发展。
全球影响力：ARM
的处理器架构已经成为全球最流行的处理器架构之一，几乎所有的智能手机、平板电脑和物联网设备都采用了
ARM 的处理器架构。ARM 公司在全球范围内拥有广泛的客户和市场影响力。</p>
<p>由ARM公司设计出来的芯片架构就是ARM架构也叫做ARM指令集架构，ARM公司将这些设计以知识产权授权的方式给其他芯片厂商或集成商，不同的授权协议具有不同的权限：
1. TLA（技术许可协议），
依据售卖的芯片收费，但ARM好像打算改变了收取设计权利金的依据，将从芯片均价改为设备均价。
2. ALA（架构许可协议），
这种模式的自由度最大，适合那些技术强劲的公司，比较典型的就是苹果公司，他们购买相关指令集后，自己去设计芯片，此外高通，华为也是购买的架构和指令集。</p>
<p><strong>ARM的特点:</strong></p>
<ol type="1">
<li>ARM指令都是32位定长的（ARMv7架构及之前版本都是32位，但是ARMv8架构一部份采用了64位指令集，而2022年6月29号发布的ARMv9版本芯片则全面采用64位指令集）</li>
<li>寄存器数量丰富（37个寄存器（大多））</li>
<li>普通的Load/Store指令</li>
<li>多寄存器的Load/Store指令</li>
<li>指令的条件执行</li>
<li>单时钟周期中的单条指令完成数据移位操作和ALU操作</li>
<li>通过变种和协处理器来扩展ARM处理器的功能</li>
<li>扩展了16位的Thumb指令来提高代码密度</li>
</ol>
<p>ARM作为RISC微处理器与CISC微处理器技术对比如下： <img
src="/images/unity/optimization/mainborad.png"
alt="精简指令和复杂指令集" /></p>
<p>上面提到的Cortex-A、Cortex-R， Cortex-M 和ARMv8/9有什么关系？</p>
<p>ARMv8 和 Cortex-A 是 ARM
公司的两个不同概念，但它们之间存在着密切的关系。</p>
<ol type="1">
<li><strong>ARMv8：</strong></li>
</ol>
<ul>
<li>ARMv8 是 ARM
公司发布的第八代指令集架构（ISA），它定义了处理器的指令集和执行规范。ARMv8
架构支持 64 位和 32
位的指令集，并引入了许多新的特性和增强功能，如更大的寻址空间、更强的安全性、更高的性能等。ARMv8
架构使得 ARM 处理器能够在 64
位模式下运行操作系统和应用程序，提高了计算能力和系统的扩展性。</li>
</ul>
<ol start="2" type="1">
<li><strong>Cortex-A：</strong></li>
</ol>
<ul>
<li>Cortex-A 是 ARM
公司设计的一系列面向高性能应用的处理器核心。这些处理器核心采用了 ARMv8
架构，并且针对不同的应用场景提供了不同的性能和功能。Cortex-A
系列处理器核心通常用于智能手机、平板电脑、服务器等高性能计算设备，以及一些嵌入式系统和物联网设备。</li>
</ul>
<p><strong>关系：</strong> ARMv8 架构定义了处理器的指令集和执行规范，而
Cortex-A 系列处理器核心是基于 ARMv8
架构设计的具体实现。换句话说，Cortex-A 处理器核心是遵循 ARMv8
指令集架构的处理器核心之一。因此，Cortex-A 处理器核心通常被称为 ARMv8
架构的一部分，它们共同构成了 ARM 公司在高性能计算领域的解决方案。</p>
<h3 id="soc">SOC</h3>
<p>目前主流的SOC有：<strong>高通骁龙（Snapdragon）</strong>,
<strong>苹果A系列</strong>，<strong>海思麒麟</strong>，<strong>联发科天玑</strong>和<strong>三星Exynos（艾克西诺斯）</strong></p>
<h4 id="高通骁龙snapdragon">高通骁龙（Snapdragon）</h4>
<p>高通骁龙（Snapdragon）系列是高通公司推出的移动处理器产品线，被广泛用于智能手机、平板电脑、智能穿戴设备、智能家居产品等移动设备和物联网设备中。</p>
<p>高通骁龙系列的一些主要特点和优势：</p>
<ol type="1">
<li><strong>高性能处理器核心：</strong></li>
</ol>
<ul>
<li>骁龙系列处理器采用了高通自主设计的 Kryo
处理器核心，具有出色的计算性能和能效。这些处理器核心通常根据型号不同分为
Prime 核心、性能核心和节能核心，以平衡性能和功耗。</li>
</ul>
<ol start="2" type="1">
<li><strong>先进的图形处理器：</strong></li>
</ol>
<ul>
<li>骁龙处理器集成了 Adreno
图形处理器，提供了出色的图形性能和游戏体验。Adreno
图形处理器具有强大的图形渲染能力、支持高帧率游戏和流畅的视频播放等特性。</li>
</ul>
<ol start="3" type="1">
<li><strong>多模式连接技术：</strong></li>
</ol>
<ul>
<li>高通骁龙处理器集成了先进的多模式连接技术，包括 LTE、5G、Wi-Fi
和蓝牙等多种连接方式，以提供高速、稳定的网络连接和无缝的通信体验。</li>
</ul>
<ol start="4" type="1">
<li><strong>人工智能加速器：</strong></li>
</ol>
<ul>
<li>最新的骁龙处理器还集成了高通的人工智能引擎（AI
Engine），包括神经处理器（NPU）和 DSP（数字信号处理器），用于加速 AI
和机器学习应用，如语音识别、图像处理等。</li>
</ul>
<ol start="5" type="1">
<li><strong>高清摄像和音频技术：</strong></li>
</ol>
<ul>
<li>高通骁龙处理器支持高清摄像和音频技术，包括多摄像头配置、高分辨率视频录制和播放、立体声音频效果等，提供了优质的多媒体体验。</li>
</ul>
<ol start="6" type="1">
<li><strong>安全和隐私保护：</strong></li>
</ol>
<ul>
<li>高通骁龙处理器集成了安全硬件模块和安全软件功能，提供了可靠的设备安全性和隐私保护，包括指纹识别、面部识别、硬件加密等功能。</li>
</ul>
<h4 id="苹果a系列">苹果A系列</h4>
<p>苹果A系列芯片拥有一系列特性，这些特性使其在性能、能效、图形处理和人工智能方面表现出色。以下是一些主要的苹果
A 系列芯片特性：</p>
<ol type="1">
<li><strong>先进的制程工艺：</strong></li>
</ol>
<ul>
<li>苹果 A 系列芯片采用先进的制程工艺，如 5 纳米或 7
纳米工艺，这有助于提高芯片的性能和能效，同时减小芯片的尺寸和功耗。</li>
</ul>
<ol start="2" type="1">
<li><strong>多核心 CPU 设计：</strong></li>
</ol>
<ul>
<li>苹果 A 系列芯片通常采用多核心的 CPU
设计，其中包括高性能核心（大核心）和节能核心（小核心）。这种设计能够在处理不同负载时平衡性能和功耗，提高了整体的能效比。</li>
</ul>
<ol start="3" type="1">
<li><strong>高性能 GPU：</strong></li>
</ol>
<ul>
<li>苹果 A
系列芯片集成了强大的图形处理器（GPU），提供了出色的图形处理性能。这些
GPU 通常采用多核心设计，并且支持最新的图形技术和特效，如 Metal
图形引擎。苹果之前使用的是Imagination(POWERVR)，但是现在苹果也在逐渐自研替代。</li>
</ul>
<ol start="4" type="1">
<li><strong>神经引擎（Neural Engine）：</strong></li>
</ol>
<ul>
<li>苹果 A
系列芯片集成了专门用于人工智能（AI）和机器学习（ML）任务的神经引擎。这些引擎能够加速图像识别、语音识别、自然语言处理等
AI 应用，提供了更快的推理速度和更高的效率。</li>
</ul>
<ol start="5" type="1">
<li><strong>高效的能耗管理：</strong></li>
</ol>
<ul>
<li>苹果 A
系列芯片采用了先进的能耗管理技术，包括动态调频、异步处理、功耗优化等，以提高芯片在不同负载下的能效比，延长设备的电池续航时间。</li>
</ul>
<ol start="6" type="1">
<li><strong>整合式芯片设计：</strong></li>
</ol>
<ul>
<li>苹果 A 系列芯片采用了整合式芯片设计，将
CPU、GPU、神经引擎等核心功能集成在一颗芯片上。这种设计能够提高系统的整体性能、减小芯片的尺寸和功耗，并简化设备的硬件布局。</li>
</ul>
<ol start="7" type="1">
<li><strong>定制化软硬件协同设计：</strong></li>
</ol>
<ul>
<li>苹果 A 系列芯片的设计与苹果自家的操作系统（如 iOS）和应用程序（如
Metal
图形引擎）进行了紧密的协同设计和优化，以提供最佳的性能和用户体验。</li>
</ul>
<h4 id="海思麒麟hisilicon-kirin">海思麒麟（HiSilicon Kirin）</h4>
<p>海思麒麟（HiSilicon
Kirin）是华为旗下的半导体设计公司海思（HiSilicon）推出的一系列移动处理器（SoC）品牌，主要用于华为和荣耀品牌的智能手机、平板电脑和其他移动设备。</p>
<p>海思麒麟芯片的特点和技术亮点：</p>
<ol type="1">
<li><strong>多核心 CPU 设计：</strong></li>
</ol>
<ul>
<li>麒麟芯片通常采用多核心的 CPU
设计，包括高性能的大核心和节能的小核心，以平衡性能和功耗。这种设计能够在不同负载下提供更好的性能和能效比。</li>
</ul>
<ol start="2" type="1">
<li><strong>强大的图形处理能力：</strong></li>
</ol>
<ul>
<li>麒麟芯片集成了强大的图形处理器（ARM Mali
GPU），提供了优秀的图形处理能力和游戏性能。这些 GPU
通常支持最新的图形技术和特效，为用户提供更好的视觉体验。</li>
</ul>
<ol start="3" type="1">
<li><strong>AI 加速器：</strong></li>
</ol>
<ul>
<li>麒麟芯片集成了专门的人工智能（AI）加速器，用于加速 AI
和机器学习（ML）任务。这些加速器能够提高图像识别、语音识别、自然语言处理等
AI 应用的性能和效率。</li>
</ul>
<ol start="4" type="1">
<li><strong>多模式连接技术：</strong></li>
</ol>
<ul>
<li>麒麟芯片集成了先进的多模式连接技术，包括 LTE、5G、Wi-Fi
和蓝牙等多种连接方式，以提供高速、稳定的网络连接和无缝的通信体验。</li>
</ul>
<ol start="5" type="1">
<li><strong>安全和隐私保护：</strong></li>
</ol>
<ul>
<li>麒麟芯片集成了安全硬件模块和安全软件功能，提供了可靠的设备安全性和隐私保护，包括指纹识别、面部识别、硬件加密等功能。</li>
</ul>
<h4 id="联发科天玑mediatek-dimensity">联发科天玑（MediaTek
Dimensity）</h4>
<p>联发科天玑（MediaTek
Dimensity）是联发科技术公司推出的一系列移动处理器（SoC）品牌，旨在为智能手机和其他移动设备提供高性能、高效能和先进的连接性能。Dimensity
系列处理器以其强大的性能、集成的 5G 连接和 AI 加速等功能而备受关注。</p>
<p>联发科天玑处理器的特点和技术亮点：</p>
<ol type="1">
<li><strong>多核心 CPU 设计：</strong></li>
</ol>
<ul>
<li>Dimensity 系列处理器采用了多核心的 CPU
设计，包括高性能核心和节能核心，以平衡性能和功耗。这种设计能够在处理不同负载时提供更好的性能和能效比。</li>
</ul>
<ol start="2" type="1">
<li><strong>集成 5G 连接：</strong></li>
</ol>
<ul>
<li>Dimensity 系列处理器集成了 5G 调制解调器，支持多模式 5G 连接，包括
SA（独立组网）和 NSA（非独立组网），以及 mmWave 和 Sub-6GHz
频段，为用户提供高速、稳定的网络连接。</li>
</ul>
<ol start="3" type="1">
<li><strong>先进的图形处理能力：</strong></li>
</ol>
<ul>
<li>Dimensity 系列处理器集成了强大的图形处理器（ARM Mali
GPU），提供了优秀的图形处理能力和游戏性能。这些 GPU
通常支持最新的图形技术和特效，为用户提供更好的视觉体验。</li>
</ul>
<ol start="4" type="1">
<li><strong>人工智能加速器：</strong></li>
</ol>
<ul>
<li>Dimensity 系列处理器集成了专门的人工智能（AI）加速器，用于加速 AI
和机器学习（ML）任务。这些加速器能够提高图像识别、语音识别、自然语言处理等
AI 应用的性能和效率。</li>
</ul>
<ol start="5" type="1">
<li><strong>多核心 ISP：</strong></li>
</ol>
<ul>
<li>Dimensity
系列处理器集成了多核心的图像信号处理器（ISP），支持多摄像头配置、高分辨率图像和视频录制、实时图像处理等功能，提供了出色的摄像和摄录体验。</li>
</ul>
<ol start="6" type="1">
<li><strong>全球导航卫星系统（GNSS）：</strong></li>
</ol>
<ul>
<li>Dimensity 系列处理器支持多种全球导航卫星系统，包括
GPS、GLONASS、Galileo、BeiDou 等，以提供精准的定位和导航服务。</li>
</ul>
<h4 id="三星exynos艾克西诺斯">三星Exynos（艾克西诺斯）</h4>
<p>三星
Exynos（艾克西诺斯）系列处理器是由三星电子公司设计和生产的一系列移动处理器（SoC），主要用于其旗下的智能手机、平板电脑和其他移动设备。Exynos
系列处理器以其强大的性能、丰富的功能和先进的技术而闻名，是三星智能设备的核心组件之一。</p>
<p>三星 Exynos 系列处理器的特点和技术亮点：</p>
<ol type="1">
<li><strong>多核心 CPU 设计：</strong></li>
</ol>
<ul>
<li>Exynos 系列处理器采用了多核心的 CPU
设计，包括高性能核心和节能核心，以平衡性能和功耗。这种设计能够在处理不同负载时提供更好的性能和能效比。</li>
</ul>
<ol start="2" type="1">
<li><strong>强大的图形处理能力：</strong></li>
</ol>
<ul>
<li>Exynos 系列处理器集成了强大的图形处理器（ARM Mali
GPU），提供了优秀的图形处理能力和游戏性能。这些 GPU
通常支持最新的图形技术和特效，为用户提供更好的视觉体验。</li>
</ul>
<ol start="3" type="1">
<li>AI 加速器：</li>
</ol>
<ul>
<li>最新的 Exynos
系列处理器通常集成了专门的人工智能（AI）加速器，用于加速 AI
和机器学习（ML）任务。这些加速器能够提高图像识别、语音识别、自然语言处理等
AI 应用的性能和效率。</li>
</ul>
<h4 id="图像处理器gpu">图像处理器（GPU）</h4>
<p>主流的手机 GPU 包括以下几种：</p>
<ol type="1">
<li><strong>Adreno GPU</strong>（由高通设计）：Adreno GPU
是目前市场上使用最广泛的 GPU 之一，广泛应用于高通 Snapdragon
系列移动处理器中。它具有出色的图形处理能力和游戏性能，在智能手机和平板电脑等移动设备上表现突出。</li>
<li><strong>Mali GPU</strong>（由 ARM 设计）：Mali GPU 是 ARM
公司设计的一系列图形处理器，被广泛用于三星 Exynos、联发科 Dimensity
等系列处理器中。Mali GPU
以其良好的能效比和优秀的图形处理性能而闻名。</li>
<li><strong>Apple GPU</strong> 苹果公司在其 A 系列处理器中采用自家设计的
GPU，以提供卓越的图形处理性能和游戏体验。虽然具体的架构和型号没有公开，但苹果
GPU 在性能和能效上表现出色。</li>
<li><strong>PowerVR GPU</strong>（由 Imagination Technologies
设计）：PowerVR GPU 曾经被苹果采用在早期的 iPhone
上，目前在一些联发科处理器中仍有使用。它具有出色的图形渲染能力和游戏性能。</li>
</ol>
<h4 id="嵌入式神经网络处理器npu">嵌入式神经网络处理器（NPU）</h4>
<h5 id="什么是-npu">什么是 NPU</h5>
<p>人工智能加速器 NPU (Neural-network Processing Unit)是一类基于 DSA
(Domain Specific Architecture)
领域专用架构技术的专用于人工智能（特别是人工神经网络、机器视觉、机器学习等）硬件加速的微处理器或计算系统。典型的应用包括机器人学、物联网等数据密集型应用或传感器驱动的任务。相比于
CPU、GPU，NPU 在硬件架构设计时便只针对于人工智能设计，举例来说，HUAWEI
Kirin DaVinci Core 集成矩阵计算单元（Cube Unit）、向量计算单元（Vector
Unit）和标量计算单元（Scalar Unit），可以通过硬件指令在一个周期内完成3D
Cube、Vector向量、Scalar标量的计算，相比于通用处理器，其算力与数据吞吐量之比有数百倍提升，同时功耗维持在较低值。</p>
<h5 id="npu的诞生">NPU的诞生</h5>
<p>　　长期以来，应用需求一直牵动着嵌入式技术、芯片技术的发展方向。随着深度学习神经网络的兴起，人工智能、大数据时代的来临，CPU
和 GPU
由于其造价高、功耗高、算力低渐渐难以满足端侧应用需要，面对日渐旺盛的需求和广大的预期市场，设计一款专门用于神经网络深度学习的高效智能处理器显得十分必要，因此NPU应运而生。
从技术角度看，基于卷积神经网络的机器学习技术实际上是一类多层大规模人工神经网络。它模仿生物神经网络而构建，由若干人工神经元结点互联而成。神经元之间通过突触两两连接，突触记录了神经元间联系的权值强弱。由于深度学习的基本操作是神经元和突触的处理，神经网络中存储和处理是一体化的，都是通过突触权重来体现，而在冯·诺伊曼结构中，存储和处理是分离的，分别由存储器和运算器来实现，二者之间存在巨大的差异。当用现有的基于冯·诺伊曼结构的经典计算机(如
X86、ARM 通用处理器和英伟达 GPU
)运行神经网络应用时，就不可避免地受到存储和处理分离式结构的制约，数据吞吐量限制算力。因此，DSA
架构的专业芯片 NPU 便应运而生。</p>
<h5 id="npu-的功能">NPU 的功能</h5>
<p>CPU (central processing unit)
是中央处理器。主要包括运算器（ALU）和控制单元（CU），还包括若干寄存器、高速缓存器和它们之间通讯的数据、控制及状态的总线。CPU
作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。它主要负责多任务管理、调度，具有很强的通用性，是计算机的核心领导部件，其计算能力并不强，更擅长逻辑控制。</p>
<p>GPU（Graphics Processing Unit）是一种图形处理器，它可以弥补 CPU
在计算能力上的天然缺陷。相对于CPU
较少的内核较多的资源而言，它采用数量众多的计算单元和超长的流水线，善于进行大量重复计算，处理图像领域的运算加速。它的基本思想是并行计算即用多个处理器来共同求解同一问题，将被求解的问题分解成若干个部分，各部分均由一个独立的处理机来并行计算。但是缺陷也很明显，即协调、管理能力弱，无法单独工作，需要
CPU 进行控制调度。虽然 GPU 用于深度学习运算时速度比 CPU
有很大提升，但对于特定应用场景其仍有功耗大，驱动逻辑复杂，性能提升不足等问题。</p>
<p>NPU
与通用处理器设计思路不同。通用处理器考虑到计算的通用性，在提升算力的同时要考虑到数据吞吐量的提升</p>
<p>NPU 针对特定领域设计，无需考虑通用应用对于内存带宽的需求。相较于 CPU
擅长处理任务和发号施令，GPU 擅长进行图像处理、并行计算算，NPU
更擅长处理人工智能任务。NPU
通过突触权重实现存储和计算一体化，从而提高运行效率。NPU
也有不足，如特定的指令集可能只满足部分机器学习的需要，而不支持的指令或多个神经网络的组合计算仍然需要回落
(Fallback) 至通用处理器计算。</p>
<h5 id="npu-的应用">NPU 的应用</h5>
<p>NPU 目前较多的在端侧应用于 AI
推理计算，在云端也有大量运用于视频编解码运算、自然语言处理、数据分析，部分NPU还能运用于
AI 的训练。</p>
<p><strong>NPU 在端侧的运用</strong> NPU 在端侧的运用较多，如
Apple、MTK、Kirin、清华紫光、瑞芯微等芯片厂商都有在其基于 ARM 架构的 Soc
内集成单独的 NPU 核心，辅助 CPU
完成异构计算；在纯微控制器（MCU）领域，STM32、Arduino、勘智等微控制器也有集成单独的
NPU
核心，方便在微控制器领域集成现代算法。具体的应用有：基于人脸识别的考勤机、基于
DHN（深度哈希网络）的掌纹识别、基于图像分类的自动垃圾分类、自动驾驶汽车、自动跟焦摄像机、监视系统等。其内嵌算法主要以卷积神经网络为主。</p>
<p><strong>NPU 在云端的应用</strong> NPU在云端的应用较少，目前主要以通用
GPU
运算为主，具体来说：百度有用于自然语言处理；华为有用于视频编解码运算；Google
将 TPU 运用于云端训练等。受限于部分 NPU
在架构设计的时候以算力功耗比为第一目标，其指令集较为精简，故用于模型训练较少，可能会遇到不支持的算子等问题。</p>
<h3 id="内存memory">内存(Memory)</h3>
<p>目前手机主力的内存技术LPDDR5X，LPDDR5X是由JEDEC于2021年6月发布，它是一种专用的同步动态随机存取存储器（SDRAM）。与之前的LPDDR5标准相比，LPDDR5X在多个方面实现了改进：</p>
<ul>
<li>在保持1.1V内核电压不变的情况下，速度从6.4Gbps提升到8.5Gbps</li>
<li>通过采用接收器均衡和发射器预加重技术，改善了信号完整性<br />
</li>
<li>全新的自适应刷新管理功能提高了可靠性</li>
<li>电池效率提高了多达20%</li>
</ul>
<h3 id="闪存flash">闪存(Flash)</h3>
<p>目前手机系统主流的存储器件有两种，一种是安卓手机使用的UFS，另外一种是苹果用的NVMe。</p>
<h4 id="ufs简介">UFS简介</h4>
<p>UFS，Universal Flash
Storage，通用闪存存储。为什么现在主流使用UFS呢？很简单，就是快。我们看下主流2lan的UFS，其顺序读的数据传输速率可以达到4.2GB/s：</p>
<figure>
<img src="/images/unity/optimization/ufs_speed.png" alt="UFS读取速度" />
<figcaption aria-hidden="true">UFS读取速度</figcaption>
</figure>
<p>UFS为什么这么快呢，对比手机以前使用的eMMC，有如下优势：</p>
<ul>
<li>UFS采用差分串行传输，而eMMC采用并行数据传输。并行最大的问题是速度上不去，因为一旦时钟频率提升，干扰就变大，信号完整性无法保证。随着时钟频率越来越高，高速串行传输的优势就很明显了。</li>
<li>支持多通道数据传输（目前是两通道），多通道可以让UFS在成本，功耗和性能之间做取舍。</li>
<li>UFS是全双工工作模式，意味着读写可以并行。而eMMC是半双工，读写是不能同时进行的。</li>
<li>UFS支持命令队列，可以异步处理命令，而eMMC无命令队列，只能进行同步处理。</li>
</ul>
<p>综合串行，多通道，全双工和异步的巨大优势，UFS流行也是大势所趋。</p>
<figure>
<img src="/images/unity/optimization/ufs_vs_emmc.png"
alt="UFS Vs eMMC" />
<figcaption aria-hidden="true">UFS Vs eMMC</figcaption>
</figure>
<p>UFS（全双工+串行）vs eMMC（半双工+并行）</p>
<h4 id="nvme简介">NVMe简介</h4>
<p>NVMe是专门为高速闪存芯片设计的协议，主要是为企业级和数据中心的PCIe
SSD设计的接口标准，来充分发挥闪存的性能。NVMe通讯协议+PCIe总线协议是实现高速SSD性能的基础，为什么这种组合可以充分发挥SSD的性能呢？</p>
<p>在NVMe之前，除了自成体系的SCSI协议（SAS
SSD），其它SSD基本用的是AHCI+SATA协议。其实AHCI和SATA是为HDD服务的，而且SATA是由PATA进化而来，也是使用到了我们前面提到的高速串行的全双工传输。奈何SSD具有更低的延迟和更高的性能，SATA已经严重制约了SSD的速度，此时就需要PCIe了。</p>
<p>相比SATA/SAS，我们先看下PCIe到底有多快： <img
src="/images/unity/optimization/sas_and_sata.png" alt="sas sata" /></p>
<p>常见的4 lan的PCIe4.0 SSD，传输速度就可达7GB/s <img
src="/images/unity/optimization/pcie.png" alt="sas sata" /></p>
<p>那么，如果把SATA换成PCIe是不是就可以了，有NVMe什么事情呢？这就需要看SATA的难兄难弟AHCI了，如果不用NVMe，老旧的AHCI同样会严重制约SSD性能。下面的对比图可以看到AHCI与NVMe的差距了：
<img src="/images/unity/optimization/ahci_vs_nvme.png"
alt="ahci_vs_nvme" /></p>
<p>讲到这里，这些协议错综复杂，大家是不是已经云里雾里了。不着急，我们用下面这张图帮助大家理解他们的关系：</p>
<p>参照SAS
SSD的协议栈，我们可以简单明了的看到，SATA和PCIe是物理接口和协议，AHCI和NVMe则是上层软件协议
<img src="/images/unity/optimization/scsi_achi_nvme.png"
alt="ahci_vs_nvme" /></p>
<h4 id="ufs与nvme比较">UFS与NVMe比较</h4>
<p>从上面的介绍可以看到，UFS拥有很好的性能，尤其是到了UFS4.0时代，2lan的顺序读可以达到4GB/s。但是，同时我们也可以看到，NVMe作为专为SSD所设计的协议，确实也有着无以伦比的性能，尤其是PCIe6.0，单lan就可以达到恐怖的8GB/s。</p>
<p>那么苹果为什么会采用NVMe而安卓还在继续使用UFS呢？孰优孰劣？从安卓各个厂家的角度来讲，为什么不采用NVMe呢？最关键的一点就是现在UFS的性能已经不比NVMe差了，根据下图，我们以iPhone
14 pro
max上的NVMe速率来看，连续读取也只有1500M/s，已经比现在的UFS4.0速度差了很多，这也是安卓厂家能够继续使用UFS的最大驱动力。</p>
<p>所以顺序读写性能：UFS4.0 &gt; NVMe = UFS 3.0 &gt; UFS 2.1 &gt; eMMC
5.1</p>
<figure>
<img src="/images/unity/optimization/emmc_ufs_nvme.png"
alt="ahci_vs_nvme" />
<figcaption aria-hidden="true">ahci_vs_nvme</figcaption>
</figure>
<h1 id="helloworld的执行过程">HelloWorld的执行过程</h1>
<p>本节的目的是分析一个程序从代码到最终执行的全部流程，其中涉及到程序的生成，程序的加载，程序的执行和程序的退出流程。经过本节的内容我们将了解的一个程序的完整生命周期。本节的内容都将基于ARMv8a指令架构的Android操作系统进行分析。</p>
<h2 id="程序的生成">程序的生成</h2>
<p>一个可执行文件或者库的生成一般会经历以下几个阶段：</p>
<ol type="1">
<li>编写源码</li>
<li>预处理</li>
<li>编译</li>
<li>链接</li>
<li>生成可执行文件或库</li>
</ol>
<p>本节将通过一个简单的程序，展示每个阶段的输出。前一个阶段的输出则是下一个阶段的输入。</p>
<h3 id="主流cc编译工具集">主流C/C++编译工具集</h3>
<p>现在主流的C/C++的编译器有：GCC, Clang/LLVM和MSVC</p>
<h4 id="gcc-gnu-compiler-collection">GCC (GNU Compiler Collection)</h4>
<p><strong>概述:</strong></p>
<p>GCC 是一个支持多种编程语言的编译器套件，包括 C, C++, Objective-C,
Fortran, Ada, 和 Go。它是开源的，并且在很多操作系统上可用，包括 Linux 和
Windows。</p>
<p><strong>特点:</strong></p>
<ul>
<li>广泛支持多种编程语言。</li>
<li>支持多种平台和体系结构。</li>
<li>强大的优化功能。</li>
<li>支持 C++ 标准（如 C++11, C++14, C++17, C++20）。</li>
</ul>
<h4 id="clangllvm">Clang/LLVM</h4>
<p><strong>概述:</strong></p>
<p>Clang 是 LLVM 项目的一部分，提供了一个类似于 GCC
的前端，但其架构更加模块化，易于扩展和嵌入。</p>
<p><strong>特点:</strong></p>
<ul>
<li>更快的编译速度。</li>
<li>更好的错误和警告信息。</li>
<li>模块化设计，易于扩展。</li>
<li>支持最新的 C++ 标准。</li>
<li>提供静态分析工具（如 Clang Static Analyzer）。</li>
</ul>
<p><strong>Clang 的组成部分</strong></p>
<ol type="1">
<li><p><strong>前端：</strong> Clang
的前端处理源代码的词法分析和语法分析。它将源代码转换为抽象语法树（AST），然后进行语义分析和优化。</p></li>
<li><p><strong>中间表示（IR）：</strong> Clang 将 AST 转换为 LLVM
中间表示（IR）。LLVM IR
是一种底层的、中间的编程语言，用于在编译过程中进行优化和代码生成。</p></li>
<li><p><strong>后端：</strong> Clang 使用 LLVM
的后端进行机器代码生成。LLVM 后端支持多种目标架构，如 x86、ARM 和
AArch64（ARM64）。</p></li>
<li><p><strong>库和工具：</strong> Clang
提供了多个库和工具，包括：</p></li>
</ol>
<ul>
<li>LibClang：一个 C 接口库，用于访问 Clang 的解析和编译功能。</li>
<li>Clang Static
Analyzer：一个静态分析工具，用于在编译时检测潜在的错误。</li>
<li>Clang-Tidy：一个基于 Clang
的代码检查工具，用于发现和修复代码中的常见问题。</li>
<li>Clang-Format：一个代码格式化工具，用于统一代码风格。</li>
</ul>
<h4 id="msvc-microsoft-visual-c">MSVC (Microsoft Visual C++)</h4>
<p><strong>概述:</strong></p>
<p>MSVC 是微软提供的 C 和 C++ 编译器，主要用于 Windows
平台上的开发。它是 Visual Studio 开发环境的一部分。</p>
<p><strong>特点:</strong></p>
<ul>
<li>与 Windows 操作系统和开发工具高度集成。</li>
<li>强大的 IDE 支持（Visual Studio）。</li>
<li>支持最新的 C++ 标准。</li>
<li>提供调试和分析工具。</li>
</ul>
<p><strong>Android和iOS都使用LLVM作为默认的编译工具集,所以本文将使用LLVM做为编译工具,并使用Android环境进行测试</strong></p>
<h3 id="源码">源码</h3>
<p>这个里我们随便写点c代码，主要看一下： 1. 函数是如何调用的; 2.
栈数据，堆数据和全局数据是如何访问的 3.
顺序，分支和循环代码对应的生成的机器指令生是什么样的;</p>
<p><strong>示例代码（test_func.c）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBAL_DATA_SIZE 10000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> globalData[GLOBAL_DATA_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomAccessTest</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问全局数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> randomNumber = rand()%GLOBAL_DATA_SIZE;</span><br><span class="line">        globalData[randomNumber] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例代码（test_main.c）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED_GLOBAL_DATA_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED_DATA_SIZE 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">RandomAccessTest</span><span class="params">(<span class="keyword">int</span> times)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用当前时间作为种子</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈上的数据</span></span><br><span class="line">    <span class="keyword">int</span> statck2[VISITED_DATA_SIZE] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> statckTotal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VISITED_DATA_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       statckTotal += statck2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问堆数据</span></span><br><span class="line">    <span class="keyword">int</span> heapDataSize = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * VISITED_DATA_SIZE;</span><br><span class="line">    <span class="keyword">int</span>* heap1 = <span class="built_in">malloc</span>(heapDataSize);</span><br><span class="line">    <span class="built_in">memset</span>(heap1, <span class="number">0</span>, heapDataSize);</span><br><span class="line">    *(heap1) = <span class="number">1</span>;</span><br><span class="line">    *(heap1+<span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> heapTotal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VISITED_DATA_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       heapTotal += heap1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分支测试</span></span><br><span class="line">    <span class="keyword">if</span> (heapTotal &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">        RandomAccessTest(VISITED_GLOBAL_DATA_SIZE);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"====HeapTotal=====:%d"</span>, heapTotal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码编写完后，我们可以直接使用一下命令生成最终的可执行文件
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -target aarch64-linux-android21 test_func.c test_main.c -o test</span><br></pre></td></tr></table></figure></p>
<p>为了更进一步的了解整个的生成过程，我们将使用不的参数来生成中间内容。</p>
<h3 id="预处理">预处理</h3>
<p>使用如下指令可以生成预处理的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -target aarch64-linux-android21 -E test_func.c -o test_func.i</span><br><span class="line">clang -target aarch64-linux-android21 -E test_main.c -o test_main.i</span><br></pre></td></tr></table></figure>
<p>预处理的作用是为了准备源代码以便后续的词法分析（Lexical
Analysis）和语法分析（Syntax Analysis）阶段。这些预处理步骤包括：</p>
<ol type="1">
<li>文件包含处理,
将"#include"包含文件插入进来（指插入需要的代码片段，不是整个文件内容贴过来）。</li>
<li>宏替换, 处理#define和#undef宏定义。</li>
<li>条件编译, 处理 #if、#ifdef、#ifndef、#elif 和 #endif
等预处理指令。</li>
<li>注释移除</li>
<li>空格处理</li>
<li>标识符处理, 处理和标识符相关的预处理指令，如 #pragma 和 #error
等，进行相应的处理或者报错</li>
<li>其他预处理指令处理, 处理其他的预处理指令，如 #line、#define、#undef
等，根据其定义执行相应的操作。</li>
</ol>
<p>预处理结果（部分），如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">double</span> <span class="title">strtod_l</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* __s, <span class="keyword">char</span>** __end_ptr, <span class="keyword">locale_t</span> __l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strtod(__s, __end_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">float</span> <span class="title">strtof_l</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* __s, <span class="keyword">char</span>** __end_ptr, <span class="keyword">locale_t</span> __l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strtof(__s, __end_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">long</span> <span class="title">strtol_l</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* __s, <span class="keyword">char</span>** __end_ptr, <span class="keyword">int</span> __base, <span class="keyword">locale_t</span> __l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strtol(__s, __end_ptr, __base);</span><br><span class="line">&#125;</span><br><span class="line"># <span class="number">277</span> <span class="string">"D:\\AndroidSDK\\ndk\\21.3.6528147\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin/../sysroot/usr/include\\stdlib.h"</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">33</span> <span class="string">"D:\\AndroidSDK\\ndk\\21.3.6528147\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin/../sysroot/usr/local/include\\stdlib.h"</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"># <span class="number">2</span> <span class="string">"test_func.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> globalData[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomAccessTest</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> randomNumber = rand()%<span class="number">10000000</span>;</span><br><span class="line">        globalData[randomNumber] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<p>编译的目的是生成一个目标文件，生成目标文件的过程大致是：</p>
<ol type="1">
<li><strong>词法分析（Lexical Analysis）：</strong></li>
</ol>
<p>编译器首先将预处理后的源文件作为输入，进行词法分析。词法分析器会将源文件中的字符序列转换成一个个的词法单元（Token），每个词法单元代表源代码中的一个基本语法结构（如关键字、标识符、运算符等）。</p>
<ol start="2" type="1">
<li><strong>语法分析（Syntax Analysis）：</strong></li>
</ol>
<p>词法分析器生成的词法单元序列将被传递给语法分析器。语法分析器根据语法规则检查这些词法单元序列的结构是否符合语言的语法规范。如果源代码符合语法规则，语法分析器将生成一个抽象语法树（Abstract
Syntax Tree, AST）。</p>
<p><strong>语义分析（Semantic Analysis）：</strong></p>
<p>编译器接着进行语义分析，这一步骤确保程序语义上的正确性。语义分析器会检查类型、作用域、变量声明等语义信息，并生成中间代码或者直接生成汇编代码。</p>
<p><strong>生成中间代码或汇编代码：</strong></p>
<p>在语义分析阶段之后，编译器会根据语义分析得到的信息，生成中间代码或者直接生成目标平台的汇编代码。如果生成中间代码，后续可能会经过优化等步骤。如果直接生成汇编代码，那么此时就得到了汇编代码文件。</p>
<p>使用如下指令生成汇编结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -target aarch64-linux-android21 -S test_func.i -o test_func.s</span><br><span class="line">clang -target aarch64-linux-android21 -S test_main.i -o test_main.s</span><br></pre></td></tr></table></figure>
<p>汇编结果(test_func.s)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.file	&quot;test_func.c&quot;</span><br><span class="line">	.globl	RandomAccessTest        &#x2F;&#x2F; -- Begin function RandomAccessTest</span><br><span class="line">	.p2align	2</span><br><span class="line">	.type	RandomAccessTest,@function</span><br><span class="line">RandomAccessTest:                       &#x2F;&#x2F; @RandomAccessTest</span><br><span class="line">&#x2F;&#x2F; %bb.0:</span><br><span class="line">	sub	sp, sp, #32             &#x2F;&#x2F; &#x3D;32</span><br><span class="line">	stp	x29, x30, [sp, #16]     &#x2F;&#x2F; 16-byte Folded Spill</span><br><span class="line">	add	x29, sp, #16            &#x2F;&#x2F; &#x3D;16</span><br><span class="line">	stur	w0, [x29, #-4]</span><br><span class="line">	str	wzr, [sp, #8]</span><br><span class="line">.LBB0_1:                                &#x2F;&#x2F; &#x3D;&gt;This Inner Loop Header: Depth&#x3D;1</span><br><span class="line">	ldr	w8, [sp, #8]</span><br><span class="line">	ldur	w9, [x29, #-4]</span><br><span class="line">	cmp	w8, w9</span><br><span class="line">	cset	w8, ge</span><br><span class="line">	tbnz	w8, #0, .LBB0_4</span><br><span class="line">&#x2F;&#x2F; %bb.2:                               &#x2F;&#x2F;   in Loop: Header&#x3D;BB0_1 Depth&#x3D;1</span><br><span class="line">	bl	rand</span><br><span class="line">	mov	w8, #38528</span><br><span class="line">	movk	w8, #152, lsl #16</span><br><span class="line">	sdiv	w9, w0, w8</span><br><span class="line">	mul	w8, w9, w8</span><br><span class="line">	subs	w8, w0, w8</span><br><span class="line">	str	w8, [sp, #4]</span><br><span class="line">	ldrsw	x10, [sp, #4]</span><br><span class="line">	mov	x11, #4</span><br><span class="line">	mul	x10, x11, x10</span><br><span class="line">	adrp	x11, globalData</span><br><span class="line">	add	x11, x11, :lo12:globalData</span><br><span class="line">	add	x10, x11, x10</span><br><span class="line">	mov	w8, #1</span><br><span class="line">	str	w8, [x10]</span><br><span class="line">&#x2F;&#x2F; %bb.3:                               &#x2F;&#x2F;   in Loop: Header&#x3D;BB0_1 Depth&#x3D;1</span><br><span class="line">	ldr	w8, [sp, #8]</span><br><span class="line">	add	w8, w8, #1              &#x2F;&#x2F; &#x3D;1</span><br><span class="line">	str	w8, [sp, #8]</span><br><span class="line">	b	.LBB0_1</span><br><span class="line">.LBB0_4:</span><br><span class="line">	mov	w0, #1</span><br><span class="line">	ldp	x29, x30, [sp, #16]     &#x2F;&#x2F; 16-byte Folded Reload</span><br><span class="line">	add	sp, sp, #32             &#x2F;&#x2F; &#x3D;32</span><br><span class="line">	ret</span><br><span class="line">.Lfunc_end0:</span><br><span class="line">	.size	RandomAccessTest, .Lfunc_end0-RandomAccessTest</span><br><span class="line">                                        &#x2F;&#x2F; -- End function</span><br><span class="line">	.type	globalData,@object      &#x2F;&#x2F; @globalData</span><br><span class="line">	.comm	globalData,40000000,4</span><br><span class="line"></span><br><span class="line">	.ident	&quot;Android (6454773 based on r365631c2) clang version 9.0.8 (https:&#x2F;&#x2F;android.googlesource.com&#x2F;toolchain&#x2F;llvm-project 98c855489587874b2a325e7a516b99d838599c6f) (based on LLVM 9.0.8svn)&quot;</span><br><span class="line">	.section	&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p><strong>优化和目标代码生成（可选步骤）：</strong></p>
<p>在一些编译器中，还会有优化器阶段，它会对中间代码或汇编代码进行优化，以提升程序的性能和效率。最终，优化后的中间代码或者汇编代码将会生成目标机器代码。</p>
<p>使用如下指令将生成汇编结果转换为最终的目标文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -target aarch64-linux-android21 -c test_func.s -o test_func.o</span><br><span class="line">clang -target aarch64-linux-android21 -c test_main.s -o test_main.o</span><br></pre></td></tr></table></figure>
<h3 id="链接生成最终可执行文件或库">链接（生成最终可执行文件或库）</h3>
<p>使用如下指令将目标文件链接成最终可执行的机器码文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -target aarch64-linux-android21 test_func.o test_main.o -o test</span><br></pre></td></tr></table></figure>
<h4 id="目标文件可执行文件或库格式">目标文件，可执行文件或库格式</h4>
<p>可执行文件或库文件格式是指计算机系统中用于存储和加载程序的特定文件格式。不同的操作系统和硬件架构可能支持不同的可执行文件格式。以下是一些常见的可执行文件格式：</p>
<p>Linux 可执行文件格式：</p>
<p>ELF (Executable and Linkable Format)：Linux 和许多其他类 Unix
操作系统上的主要可执行文件格式、共享库等。</p>
<p>ELF 文件的基本结构 ELF 文件的基本结构由三个部分组成：</p>
<ol type="1">
<li>ELF Header：描述整个文件的组织结构,
包含文件类型、机器架构、入口地址等信息。</li>
<li>Program Header
Table：描述程序的各个段（segment），仅在可执行文件和共享库中存在，描述了程序在内存中的映射，每个条目描述一个段，段包含可执行代码、数据等</li>
<li>Section Header
Table：描述文件的各个节（section），用于链接和调试。</li>
</ol>
<p>ELF文件我们在Linux内核源码中找到对应的实现，核心的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ELF Header</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];  <span class="comment">// ELF 标识, 前4个字节0x7F、e、l、f</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_type;              <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_machine;           <span class="comment">// 目标体系结构</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      e_version;           <span class="comment">// 文件版本</span></span><br><span class="line">    Elf32_Addr    e_entry;             <span class="comment">// 入口地址</span></span><br><span class="line">    Elf32_Off     e_phoff;             <span class="comment">// 程序头表偏移量</span></span><br><span class="line">    Elf32_Off     e_shoff;             <span class="comment">// 节头表偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      e_flags;             <span class="comment">// 特定处理器标志</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_ehsize;            <span class="comment">// ELF 头大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_phentsize;         <span class="comment">// 程序头表项大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_phnum;             <span class="comment">// 程序头表项数</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shentsize;         <span class="comment">// 节头表项大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shnum;             <span class="comment">// 节头表项数</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shstrndx;          <span class="comment">// 节头字符串表索引</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program Header</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 段的类型 </span></span><br><span class="line">    <span class="comment">// 0：PT_NULL, 无效段</span></span><br><span class="line">    <span class="comment">// 1：PT_LOAD, 加载段此段包含需要加载到内存中的内容，如代码段和数据段</span></span><br><span class="line">    <span class="comment">// 2: PT_DYNAMIC, 动态链接信息段，此段包含动态链接所需的信息，如动态符号表、重定位表等）</span></span><br><span class="line">    <span class="comment">// 3: PT_INTERP, 解释器段，此段包含一个字符串，指定解释器的路径（通常是动态链接器）</span></span><br><span class="line">    <span class="comment">// 4: PT_NOTE, Note 段，包含一些附加信息，如核心转储文件中的注释段。</span></span><br><span class="line">    <span class="comment">// 5: PT_SHLIB, 保留，未使用。</span></span><br><span class="line">    <span class="comment">// 6: PT_PHDR, 程序头表段，此段包含程序头表自身。</span></span><br><span class="line">    <span class="comment">// 7: PT_TLS, 线程局部存储段，此段用于线程局部存储。</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_type;   <span class="comment">// 段的类型</span></span><br><span class="line">    Elf32_Off  p_offset; <span class="comment">// 段在文件中的偏移</span></span><br><span class="line">    Elf32_Addr p_vaddr;  <span class="comment">// 段在内存中的虚拟地址</span></span><br><span class="line">    Elf32_Addr p_paddr;  <span class="comment">// 段在内存中的物理地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_filesz; <span class="comment">// 段在文件中的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_memsz;  <span class="comment">// 段在内存中的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_flags;  <span class="comment">// 段的标志, 用于标识段的权限 ( 可执行段：0x1, 可写段：0x2,  可读段：0x4) </span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_align;  <span class="comment">// 段的对齐， 2^&#123;p_align&#125;</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section Header</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 节类型</span></span><br><span class="line">    <span class="comment">// SHT_NULL (0)：无效节，不使用。</span></span><br><span class="line">    <span class="comment">// SHT_PROGBITS (1)：    程序数据段，包含程序代码和数据。</span></span><br><span class="line">    <span class="comment">// SHT_SYMTAB (2)：    符号表段，包含符号表信息，通常用于链接。</span></span><br><span class="line">    <span class="comment">// SHT_STRTAB (3)：    字符串表段，包含字符串表数据。</span></span><br><span class="line">    <span class="comment">// SHT_RELA (4)：    重定位段（带显式添加端），包含重定位条目，每个条目包含一个附加的显式值。</span></span><br><span class="line">    <span class="comment">// SHT_HASH (5)：    符号哈希表段，包含符号表的哈希表，用于快速查找符号。</span></span><br><span class="line">    <span class="comment">// SHT_DYNAMIC (6)：    动态链接信息段，包含动态链接所需的信息。</span></span><br><span class="line">    <span class="comment">// SHT_NOTE (7)：    Note 段，包含附加信息。</span></span><br><span class="line">    <span class="comment">// SHT_NOBITS (8)：    空段，不占用文件空间，但在内存中分配空间。BSS段</span></span><br><span class="line">    <span class="comment">// SHT_REL (9)：    重定位段（不带显式添加端），包含重定位条目，不带显式值。</span></span><br><span class="line">    <span class="comment">// SHT_SHLIB (10)：    保留段，未使用。</span></span><br><span class="line">    <span class="comment">// SHT_DYNSYM (11)：    动态符号表段，包含动态链接的符号表。</span></span><br><span class="line">    <span class="comment">// SHT_INIT_ARRAY (14)：    初始化函数数组段，包含指向初始化函数的指针数组。</span></span><br><span class="line">    <span class="comment">// SHT_FINI_ARRAY (15)：    终结函数数组段，包含指向终结函数的指针数组。</span></span><br><span class="line">    <span class="comment">// SHT_PREINIT_ARRAY (16)：    预初始化函数数组段，包含指向预初始化函数的指针数组。</span></span><br><span class="line">    <span class="comment">// SHT_GROUP (17)：    节组段，包含多个节的分组信息。</span></span><br><span class="line">    <span class="comment">// SHT_SYMTAB_SHNDX (18)：    符号表节索引段，包含符号表中的索引。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_name;      <span class="comment">// 节的名字(在string表中的索引)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_type;      <span class="comment">// 节的类型</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_flags;     <span class="comment">// 节的标志（0x1：该节包含在进程执行过程中可写的数据，0x2： 该节在进程执行过程中分配了内存， 0x4：该节包含可执行的机器指令）</span></span><br><span class="line">    Elf32_Addr sh_addr;    <span class="comment">// 节在内存中的虚拟地址</span></span><br><span class="line">    Elf32_Off sh_offset;   <span class="comment">// 节在文件中的偏移</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_size;      <span class="comment">// 节的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_link;      <span class="comment">// 下一个节的链接索引</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_info;      <span class="comment">// 节的附加信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_addralign; <span class="comment">// 节的对齐</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sh_entsize;   <span class="comment">// 节项的大小</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用readelf来查看ELF文件的内容：</p>
<p>ELF Header <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ELF Header:</span></span><br><span class="line">  <span class="attr">Magic:</span>   <span class="string">7f</span> <span class="number">45</span> <span class="string">4c</span> <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="attr">Class:</span>                             <span class="string">ELF64</span></span><br><span class="line">  <span class="attr">Data:</span>                              <span class="number">2</span><span class="string">'s complement, little endian  小端</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0x0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           AArch64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x176C</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file) ELF Header后紧接着就是Program Header</span></span><br><span class="line"><span class="string">  Start of section headers:          5608 (bytes into file) Section 开始位置</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)   ELF Header的大小</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)   Program Header大小</span></span><br><span class="line"><span class="string">  Number of program headers:         11           Program Header数量</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)   Section Header大小</span></span><br><span class="line"><span class="string">  Number of section headers:         27           Section Header的数量</span></span><br><span class="line"><span class="string">  Section header string table index: 25           Section Header名字在字符串表中的索引位置</span></span><br><span class="line"><span class="string">There are 27 section headers, starting at offset 0x15e8:</span></span><br></pre></td></tr></table></figure></p>
<p>Program Headers 截取片段</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">There</span> <span class="string">are</span> <span class="number">11</span> <span class="string">program</span> <span class="string">headers,</span> <span class="string">starting</span> <span class="string">at</span> <span class="string">offset</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Program Headers:</span></span><br><span class="line">  <span class="string">Type</span>           <span class="string">Offset</span>   <span class="string">VirtAddr</span>           <span class="string">PhysAddr</span>           <span class="string">FileSiz</span>  <span class="string">MemSiz</span>   <span class="string">Flg</span> <span class="string">Align</span></span><br><span class="line">  <span class="string">PHDR</span>           <span class="number">0x000040</span> <span class="number">0x0000000000000040</span> <span class="number">0x0000000000000040</span> <span class="number">0x000268</span> <span class="number">0x000268</span> <span class="string">R</span>   <span class="number">0x8</span></span><br><span class="line">  <span class="string">INTERP</span>         <span class="number">0x0002a8</span> <span class="number">0x00000000000002a8</span> <span class="number">0x00000000000002a8</span> <span class="number">0x000015</span> <span class="number">0x000015</span> <span class="string">R</span>   <span class="number">0x1</span></span><br><span class="line">      <span class="string">[Requesting</span> <span class="attr">program interpreter:</span> <span class="string">/system/bin/linker64]</span></span><br><span class="line">  <span class="string">LOAD</span>           <span class="number">0x000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x00076c</span> <span class="number">0x00076c</span> <span class="string">R</span>   <span class="number">0x1000</span></span><br><span class="line">  <span class="string">LOAD</span>           <span class="number">0x00076c</span> <span class="number">0x000000000000176c</span> <span class="number">0x000000000000176c</span> <span class="number">0x0002f4</span> <span class="number">0x0002f4</span> <span class="string">R</span> <span class="string">E</span> <span class="number">0x1000</span></span><br><span class="line">  <span class="string">LOAD</span>           <span class="number">0x000a60</span> <span class="number">0x0000000000002a60</span> <span class="number">0x0000000000002a60</span> <span class="number">0x000278</span> <span class="number">0x000278</span> <span class="string">RW</span>  <span class="number">0x1000</span></span><br><span class="line">  <span class="string">LOAD</span>           <span class="number">0x000cd8</span> <span class="number">0x0000000000003cd8</span> <span class="number">0x0000000000003cd8</span> <span class="number">0x000000</span> <span class="number">0x2625a08</span> <span class="string">RW</span>  <span class="number">0x1000</span></span><br><span class="line">  <span class="string">DYNAMIC</span>        <span class="number">0x000a90</span> <span class="number">0x0000000000002a90</span> <span class="number">0x0000000000002a90</span> <span class="number">0x0001d0</span> <span class="number">0x0001d0</span> <span class="string">RW</span>  <span class="number">0x8</span></span><br><span class="line">  <span class="string">GNU_RELRO</span>      <span class="number">0x000a60</span> <span class="number">0x0000000000002a60</span> <span class="number">0x0000000000002a60</span> <span class="number">0x000278</span> <span class="number">0x0005a0</span> <span class="string">R</span>   <span class="number">0x1</span></span><br><span class="line">  <span class="string">GNU_EH_FRAME</span>   <span class="number">0x000678</span> <span class="number">0x0000000000000678</span> <span class="number">0x0000000000000678</span> <span class="number">0x000034</span> <span class="number">0x000034</span> <span class="string">R</span>   <span class="number">0x4</span></span><br><span class="line">  <span class="string">GNU_STACK</span>      <span class="number">0x000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x000000</span> <span class="number">0x000000</span> <span class="string">RW</span>  <span class="number">0x0</span></span><br><span class="line">  <span class="string">NOTE</span>           <span class="number">0x0002c0</span> <span class="number">0x00000000000002c0</span> <span class="number">0x00000000000002c0</span> <span class="number">0x000098</span> <span class="number">0x000098</span> <span class="string">R</span>   <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">Section to Segment mapping:</span>  </span><br><span class="line">  <span class="string">Segment</span> <span class="string">Sections...</span></span><br><span class="line">   <span class="number">00</span>     </span><br><span class="line">   <span class="number">01</span>     <span class="string">.interp</span> </span><br><span class="line">   <span class="number">02</span>     <span class="string">.interp</span> <span class="string">.note.android.ident</span> <span class="string">.dynsym</span> <span class="string">.gnu.version</span> <span class="string">.gnu.version_r</span> <span class="string">.gnu.hash</span> <span class="string">.hash</span> <span class="string">.dynstr</span> <span class="string">.rela.dyn</span> <span class="string">.rela.plt</span> <span class="string">.rodata</span> <span class="string">.eh_frame_hdr</span> <span class="string">.eh_frame</span> </span><br><span class="line">   <span class="number">03</span>     <span class="string">.text</span> <span class="string">.plt</span> </span><br><span class="line">   <span class="number">04</span>     <span class="string">.preinit_array</span> <span class="string">.init_array</span> <span class="string">.fini_array</span> <span class="string">.dynamic</span> <span class="string">.got</span> <span class="string">.got.plt</span> </span><br><span class="line">   <span class="number">05</span>     <span class="string">.bss</span> </span><br><span class="line">   <span class="number">06</span>     <span class="string">.dynamic</span> </span><br><span class="line">   <span class="number">07</span>     <span class="string">.preinit_array</span> <span class="string">.init_array</span> <span class="string">.fini_array</span> <span class="string">.dynamic</span> <span class="string">.got</span> <span class="string">.got.plt</span> </span><br><span class="line">   <span class="number">08</span>     <span class="string">.eh_frame_hdr</span> </span><br><span class="line">   <span class="number">09</span>     </span><br><span class="line">   <span class="number">10</span>     <span class="string">.note.android.ident</span> </span><br><span class="line">   <span class="string">None</span>   <span class="string">.comment</span> <span class="string">.symtab</span> <span class="string">.shstrtab</span> <span class="string">.strtab</span></span><br></pre></td></tr></table></figure>
<p>Section Headers 截取片段</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">There</span> <span class="string">are</span> <span class="number">27</span> <span class="string">section</span> <span class="string">headers,</span> <span class="attr">starting at offset 0x15e8:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Section Headers:</span></span><br><span class="line">  <span class="string">[Nr]</span> <span class="string">Name</span>              <span class="string">Type</span>            <span class="string">Address</span>          <span class="string">Off</span>    <span class="string">Size</span>   <span class="string">ES</span> <span class="string">Flg</span> <span class="string">Lk</span> <span class="string">Inf</span> <span class="string">Al</span></span><br><span class="line">  <span class="string">[</span> <span class="number">0</span><span class="string">]</span>                   <span class="literal">NULL</span>            <span class="number">0000000000000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="string">[</span> <span class="number">1</span><span class="string">]</span> <span class="string">.interp</span>           <span class="string">PROGBITS</span>        <span class="string">00000000000002a8</span> <span class="string">0002a8</span> <span class="number">000015</span> <span class="number">00</span>   <span class="string">A</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">2</span><span class="string">]</span> <span class="string">.note.android.ident</span> <span class="string">NOTE</span>          <span class="string">00000000000002c0</span> <span class="string">0002c0</span> <span class="number">000098</span> <span class="number">00</span>   <span class="string">A</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  <span class="string">[</span> <span class="number">3</span><span class="string">]</span> <span class="string">.dynsym</span>           <span class="string">DYNSYM</span>          <span class="number">0000000000000358</span> <span class="number">000358</span> <span class="string">0000d8</span> <span class="number">18</span>   <span class="string">A</span>  <span class="number">8</span>   <span class="number">1</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[</span> <span class="number">4</span><span class="string">]</span> <span class="string">.gnu.version</span>      <span class="string">VERSYM</span>          <span class="number">0000000000000430</span> <span class="number">000430</span> <span class="number">000012</span> <span class="number">02</span>   <span class="string">A</span>  <span class="number">3</span>   <span class="number">0</span>  <span class="number">2</span></span><br><span class="line">  <span class="string">[</span> <span class="number">5</span><span class="string">]</span> <span class="string">.gnu.version_r</span>    <span class="string">VERNEED</span>         <span class="number">0000000000000444</span> <span class="number">000444</span> <span class="number">000020</span> <span class="number">00</span>   <span class="string">A</span>  <span class="number">8</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">  <span class="string">[</span> <span class="number">6</span><span class="string">]</span> <span class="string">.gnu.hash</span>         <span class="string">GNU_HASH</span>        <span class="number">0000000000000468</span> <span class="number">000468</span> <span class="string">00001c</span> <span class="number">00</span>   <span class="string">A</span>  <span class="number">3</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[</span> <span class="number">7</span><span class="string">]</span> <span class="string">.hash</span>             <span class="string">HASH</span>            <span class="number">0000000000000484</span> <span class="number">000484</span> <span class="number">000050</span> <span class="number">04</span>   <span class="string">A</span>  <span class="number">3</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  <span class="string">[</span> <span class="number">8</span><span class="string">]</span> <span class="string">.dynstr</span>           <span class="string">STRTAB</span>          <span class="string">00000000000004d4</span> <span class="string">0004d4</span> <span class="number">000055</span> <span class="number">00</span>   <span class="string">A</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">9</span><span class="string">]</span> <span class="string">.rela.dyn</span>         <span class="string">RELA</span>            <span class="number">0000000000000530</span> <span class="number">000530</span> <span class="number">000060</span> <span class="number">18</span>   <span class="string">A</span>  <span class="number">3</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[10]</span> <span class="string">.rela.plt</span>         <span class="string">RELA</span>            <span class="number">0000000000000590</span> <span class="number">000590</span> <span class="string">0000c0</span> <span class="number">18</span>  <span class="string">AI</span>  <span class="number">3</span>  <span class="number">21</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[11]</span> <span class="string">.rodata</span>           <span class="string">PROGBITS</span>        <span class="number">0000000000000650</span> <span class="number">000650</span> <span class="number">000026</span> <span class="number">00</span> <span class="string">AMS</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  <span class="string">[12]</span> <span class="string">.eh_frame_hdr</span>     <span class="string">PROGBITS</span>        <span class="number">0000000000000678</span> <span class="number">000678</span> <span class="number">000034</span> <span class="number">00</span>   <span class="string">A</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  <span class="string">[13]</span> <span class="string">.eh_frame</span>         <span class="string">PROGBITS</span>        <span class="string">00000000000006b0</span> <span class="string">0006b0</span> <span class="string">0000bc</span> <span class="number">00</span>   <span class="string">A</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[14]</span> <span class="string">.text</span>             <span class="string">PROGBITS</span>        <span class="string">000000000000176c</span> <span class="string">00076c</span> <span class="number">000250</span> <span class="number">00</span>  <span class="string">AX</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  <span class="string">[15]</span> <span class="string">.plt</span>              <span class="string">PROGBITS</span>        <span class="string">00000000000019c0</span> <span class="string">0009c0</span> <span class="string">0000a0</span> <span class="number">00</span>  <span class="string">AX</span>  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  <span class="string">[16]</span> <span class="string">.preinit_array</span>    <span class="string">PREINIT_ARRAY</span>   <span class="string">0000000000002a60</span> <span class="string">000a60</span> <span class="number">000010</span> <span class="number">00</span>  <span class="string">WA</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[17]</span> <span class="string">.init_array</span>       <span class="string">INIT_ARRAY</span>      <span class="string">0000000000002a70</span> <span class="string">000a70</span> <span class="number">000010</span> <span class="number">00</span>  <span class="string">WA</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[18]</span> <span class="string">.fini_array</span>       <span class="string">FINI_ARRAY</span>      <span class="string">0000000000002a80</span> <span class="string">000a80</span> <span class="number">000010</span> <span class="number">00</span>  <span class="string">WA</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[19]</span> <span class="string">.dynamic</span>          <span class="string">DYNAMIC</span>         <span class="string">0000000000002a90</span> <span class="string">000a90</span> <span class="string">0001d0</span> <span class="number">10</span>  <span class="string">WA</span>  <span class="number">8</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[20]</span> <span class="string">.got</span>              <span class="string">PROGBITS</span>        <span class="string">0000000000002c60</span> <span class="string">000c60</span> <span class="number">000020</span> <span class="number">00</span>  <span class="string">WA</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[21]</span> <span class="string">.got.plt</span>          <span class="string">PROGBITS</span>        <span class="string">0000000000002c80</span> <span class="string">000c80</span> <span class="number">000058</span> <span class="number">00</span>  <span class="string">WA</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[22]</span> <span class="string">.bss</span>              <span class="string">NOBITS</span>          <span class="string">0000000000003cd8</span> <span class="string">000cd8</span> <span class="string">2625a08</span> <span class="number">00</span>  <span class="string">WA</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[23]</span> <span class="string">.comment</span>          <span class="string">PROGBITS</span>        <span class="number">0000000000000000</span> <span class="string">000cd8</span> <span class="string">00016a</span> <span class="number">01</span>  <span class="string">MS</span>  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  <span class="string">[24]</span> <span class="string">.symtab</span>           <span class="string">SYMTAB</span>          <span class="number">0000000000000000</span> <span class="number">000e48</span> <span class="number">0004e0</span> <span class="number">18</span>     <span class="number">26</span>  <span class="number">37</span>  <span class="number">8</span></span><br><span class="line">  <span class="string">[25]</span> <span class="string">.shstrtab</span>         <span class="string">STRTAB</span>          <span class="number">0000000000000000</span> <span class="number">001328</span> <span class="string">0000fe</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  <span class="string">[26]</span> <span class="string">.strtab</span>           <span class="string">STRTAB</span>          <span class="number">0000000000000000</span> <span class="number">001426</span> <span class="string">0001c0</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="attr">Key to Flags:</span></span><br><span class="line">  <span class="string">W</span> <span class="string">(write),</span> <span class="string">A</span> <span class="string">(alloc),</span> <span class="string">X</span> <span class="string">(execute),</span> <span class="string">M</span> <span class="string">(merge),</span> <span class="string">S</span> <span class="string">(strings),</span> <span class="string">l</span> <span class="string">(large)</span></span><br><span class="line">  <span class="string">I</span> <span class="string">(info),</span> <span class="string">L</span> <span class="string">(link</span> <span class="string">order),</span> <span class="string">G</span> <span class="string">(group),</span> <span class="string">T</span> <span class="string">(TLS),</span> <span class="string">E</span> <span class="string">(exclude),</span> <span class="string">x</span> <span class="string">(unknown)</span></span><br><span class="line">  <span class="string">O</span> <span class="string">(extra</span> <span class="string">OS</span> <span class="string">processing</span> <span class="string">required)</span> <span class="string">o</span> <span class="string">(OS</span> <span class="string">specific),</span> <span class="string">p</span> <span class="string">(processor</span> <span class="string">specific)</span></span><br></pre></td></tr></table></figure>
<p>ELF文件结构图：</p>
<figure>
<img src="/images/unity/optimization/elf-file-format.png"
alt="ELF文件结构图" />
<figcaption aria-hidden="true">ELF文件结构图</figcaption>
</figure>
<p>注意：段（Segment）与节（Section）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。</p>
<p>macOS 可执行文件格式：</p>
<p>Mach-O (Mach Object)：macOS 和 iOS
系统上的可执行文件格式、共享库等。其格式和ELF原理上都是相通的，不做详细赘述。</p>
<p>Windows 可执行文件格式：</p>
<p>Portable Executable (PE)：Windows
系统上最常见的可执行文件格式，包括程序、动态链接库 (DLL)
和驱动程序等。其格式和ELF原理上都是相通的，不做详细赘述。</p>
<p>本节，我们窥探了一下Linux目标文件的格式，下面我们将多个目标文件链接成一个可执行的文件。链接的方式主要有两种：静态链接和动态链接。</p>
<h4 id="静态链接">静态链接</h4>
<p>静态链接的过程大致如下：</p>
<ol type="1">
<li>地址与空间分配（Address and Storage Allocation）</li>
<li>符号解析和重定位（Symbol Resolution and Relocation）</li>
</ol>
<p><strong>地址与空间分配</strong></p>
<p>在ELF文件结构中，我们可以看到，是由各种节（Section）组成的，每个节都会有对应的文件位置，以及分配的虚拟地址空间。合并成一个后我们要就要分配对一个的文件空间和虚拟的地址空间。</p>
<figure>
<img src="/images/unity/optimization/elf-similar-merge.png"
alt="合并" />
<figcaption aria-hidden="true">合并</figcaption>
</figure>
<p><strong>符号解析和重定位</strong></p>
<p>将每个目标文件中的符号（函数，变量等）进行地址调整。那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的
重定位表（Relocation Table）
专门用来保存这些与重定位相关的信息。对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果.text节需要被重定位，则会有一个相对应叫.rel.text的节保存了代码节的重定位表；如果.data节需要被重定位，则会有一个相对应的.rel.tdata的节保存了数据节的重定位表。</p>
<h4 id="动态链接">动态链接</h4>
<p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p>
<p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为
动态共享对象（DSO，Dynamic Shared
Objects），一般以.so为后缀；在Windows中，动态链接文件被称为
动态链接库（Dynamic Linking Library），一般以.dll为后缀。</p>
<p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在
/lib目录下，文件名为
libc.so。整个系统只保留一份C语言动态链接文件libc.so，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p>
<h2 id="程序的加载与执行">程序的加载与执行</h2>
<p>应用程序从启动到运行的过程涉及多个步骤，包括加载、准备和执行。以下是一个详细的过程描述：</p>
<p><strong>用户请求：</strong></p>
<p>用户通过命令行或图形界面（如双击图标）启动一个应用程序。这一操作向操作系统发出了一个启动应用程序的请求。</p>
<p><strong>操作系统接收请求：</strong></p>
<p>操作系统接收用户的请求，并开始启动应用程序的过程。具体步骤如下：</p>
<p><strong>查找可执行文件：</strong></p>
<p>操作系统在文件系统中查找应用程序的可执行文件。可执行文件通常包含程序的代码和数据。</p>
<p><strong>分配内存：</strong></p>
<p>操作系统为应用程序分配内存空间，包括代码段、数据段、堆、栈等。
代码段存储程序指令，数据段存储全局和静态变量，堆用于动态内存分配，栈用于函数调用和本地变量。</p>
<p><strong>加载可执行文件：</strong></p>
<p>操作系统将应用程序的可执行文件加载到分配的内存空间中。通常使用的是分页或分段机制，逐步将程序代码和数据加载到内存中。</p>
<p><strong>设置进程控制块（PCB）：</strong></p>
<p>操作系统创建一个新的进程控制块（Process Control
Block，PCB），其中包含关于新进程的信息，如进程ID（PID）、进程状态、寄存器内容、内存指针等。
PCB用于管理进程并在进程切换时保存和恢复进程状态。</p>
<p><strong>初始化进程环境：</strong></p>
<p>操作系统为新进程初始化必要的环境，包括环境变量、文件描述符（如标准输入、输出、错误）等。
设置程序入口点（通常是main函数的地址）和初始堆栈指针。</p>
<p><strong>加载动态链接库：</strong></p>
<p>如果应用程序依赖于动态链接库（DLL或共享库），操作系统会加载这些库到内存中，并将它们链接到应用程序中。这个过程通常由动态链接器（如Linux上的ld.so）完成。</p>
<p><strong>进入就绪队列：</strong></p>
<p>新进程的PCB被加入到就绪队列中，等待调度器将其分配到CPU上执行。</p>
<p><strong>调度程序调度：</strong></p>
<p>操作系统的调度程序（Scheduler）选择一个就绪进程，并将其分配到CPU上执行。选择策略可能是先来先服务（FCFS）、短作业优先（SJF）、时间片轮转（RR）等。</p>
<p><strong>切换到用户态：</strong></p>
<p>调度程序将进程的上下文信息（如寄存器、程序计数器）加载到CPU，并切换到用户态，开始执行应用程序的代码。
进程从操作系统内核态切换到用户态，正式开始执行应用程序。</p>
<p><strong>执行应用程序：</strong></p>
<p>应用程序开始运行，其主函数被调用，并开始执行其中的指令。
在运行过程中，应用程序可能会进行系统调用，以请求操作系统执行特权操作（如文件读写、网络通信等）。</p>
<p><strong>系统调用处理：</strong></p>
<p>当应用程序进行系统调用时，CPU切换到内核态，操作系统处理请求，然后返回用户态继续执行应用程序。
系统调用的处理包括参数验证、权限检查、实际操作执行等。</p>
<p><strong>进程终止：</strong></p>
<p>当应用程序执行完成或者被用户终止时，它会调用系统调用（如exit）通知操作系统。
操作系统释放进程占用的资源（如内存、文件描述符等），更新进程状态，将PCB从进程表中移除。
操作系统可能会通知父进程（如果有），并可能启动清理或回收资源的操作。</p>
<h1 id="分析工具">分析工具</h1>
<h2 id="硬件参数和访问过程">硬件参数和访问过程</h2>
<p>了解硬件的参数和访问过程，有助于我们理解分析工具中的各种参数，以及他们所代表的意义。</p>
<h3 id="闪存">闪存</h3>
<p>闪存（Flash
Memory）是一种非易失性存储器，广泛用于固态硬盘（SSD）、USB闪存驱动器、SD卡和嵌入式系统中。闪存的访问过程包括读、写和擦除操作。</p>
<h4 id="闪存基本结构">闪存基本结构</h4>
<p><strong>1.
控制器</strong>：负责管理闪存的读写操作、地址映射、坏块管理等。
<strong>2. 存储单元</strong>：由NAND或NOR闪存芯片组成，存储实际的数据。
<strong>3. 接口</strong>：例如eMMC（Embedded
MultiMediaCard）或UFS（Universal Flash Storage），负责与处理器通信。</p>
<h4 id="闪存访问过程">闪存访问过程</h4>
<p><strong>读操作</strong></p>
<p><strong>1. 主机命令：</strong></p>
<ul>
<li>手机处理器（主机）发出读命令，指定逻辑块地址（LBA），并通过接口（如eMMC或UFS）发送给闪存控制器。</li>
</ul>
<p><strong>2. 命令解析：</strong></p>
<ul>
<li>闪存控制器接收并解析读命令和LBA，将逻辑地址（LBA）转换为物理地址（PBA）。</li>
</ul>
<p><strong>3. 加载数据：</strong></p>
<ul>
<li>闪存控制器从指定的物理地址读取数据，将数据从闪存芯片加载到控制器的内部数据缓冲区。这涉及读取存储单元中的电荷状态并将其转换为数字数据。</li>
</ul>
<p><strong>4. 错误校验：</strong></p>
<ul>
<li>闪存控制器使用错误纠正码（ECC）对数据进行校验和纠错，确保数据的完整性和正确性。</li>
</ul>
<p><strong>5.数据传输：</strong></p>
<ul>
<li>数据从闪存控制器的缓冲区通过接口（如eMMC或UFS）传输到主机。</li>
</ul>
<p><strong>6. 主机接收：</strong></p>
<ul>
<li>主机接收到数据后，直接将其写入到系统内存（RAM）中。这个过程由主机的内存控制器管理，确保数据在内存中的正确存储位置。</li>
</ul>
<p><strong>写操作</strong></p>
<p><strong>1. 主机命令：</strong></p>
<ul>
<li>主机发出写命令，指定LBA和要写入的数据。</li>
</ul>
<p><strong>2. 命令解析：</strong></p>
<ul>
<li>闪存控制器解析命令并将LBA转换为PBA。</li>
</ul>
<p><strong>3. 数据传输：</strong></p>
<ul>
<li>主机通过接口将数据传输到闪存控制器的内部缓冲区。</li>
</ul>
<p><strong>4. 写入：</strong></p>
<ul>
<li>闪存芯片将缓冲区的数据写入指定的存储单元。</li>
</ul>
<p><strong>5. 错误校验：</strong></p>
<ul>
<li>使用ECC校验写入的数据。</li>
</ul>
<p><strong>6. 状态返回：</strong></p>
<ul>
<li>控制器将操作结果返回给主机。</li>
</ul>
<p><strong>擦除操作</strong></p>
<p><strong>1. 主机命令：</strong></p>
<ul>
<li>主机发出擦除命令，指定要擦除的块。</li>
</ul>
<p><strong>2. 命令解析：</strong></p>
<ul>
<li>闪存控制器解析命令并将LBA转换为PBA。</li>
</ul>
<p><strong>3. 擦除操作：</strong></p>
<ul>
<li>闪存芯片将指定块中的所有存储单元设置为初始状态。</li>
</ul>
<p><strong>4. 确认擦除：</strong></p>
<ul>
<li>控制器确认擦除完成。</li>
</ul>
<p><strong>5. 状态返回：</strong></p>
<ul>
<li>控制器将操作结果返回给主机。</li>
</ul>
<h4 id="闪存参数">闪存参数</h4>
<ol type="1">
<li><strong>读写速度：</strong>
每秒钟读/写的数据量，通常以MB/s或GB/s为单位。</li>
<li><strong>读写延迟：</strong>
执行读/写操作的时间，通常以毫秒（ms）为单位。</li>
<li><strong>IOPS（每秒输入输出操作次数）：</strong>
每秒钟执行的I/O操作次数，用于衡量存储设备的性能。</li>
<li><strong>队列深度：</strong>
同时处理的I/O操作数量，较高的队列深度可能导致更高的延迟。</li>
<li><strong>I/O大小：</strong>
每个I/O操作的数据量，通常以字节（B）、千字节（KB）或兆字节（MB）为单位。</li>
<li><strong>吞吐量：</strong>
单位时间内传输的数据量，通常以MB/s或GB/s为单位。</li>
</ol>
<h3 id="内存">内存</h3>
<h4 id="内存结构">内存结构</h4>
<p>在计算机内存（尤其是DRAM，如SDRAM、DDR等）中，内存单元以矩阵的形式组织，每个单元存储一个比特的数据。这些数据单元（存储单元）被组织成一个二维矩阵。每个单元可以通过其行地址和列地址唯一标识。这个结构类似于一个电子表格，每个单元格可以通过其行和列来确定位置。</p>
<ul>
<li><strong>行地址（Row
Address）</strong>：用于选择内存矩阵中的某一行。所有的存储单元都按行组织，因此首先需要选择包含目标单元的行。</li>
<li><strong>列地址（Column
Address）</strong>：用于选择特定行中某一列的地址。与行地址一起唯一标识内存单元的位置。</li>
</ul>
<h4 id="内存访问过程">内存访问过程</h4>
<p>内存访问是计算机系统中非常基础和关键的操作过程，它涉及多个步骤和多个组件之间的协同工作。以下是详细描述内存访问过程的步骤：</p>
<h4 id="内存访问的详细步骤">内存访问的详细步骤</h4>
<p><strong>1. 生成内存地址：</strong></p>
<ul>
<li><strong>CPU生成地址</strong>：处理器（CPU）根据当前执行的指令生成一个内存地址。这个地址可能是指令中的直接地址，或者是通过地址计算（如基地址加偏移量）生成的。</li>
<li><strong>虚拟地址转换</strong>：如果使用虚拟内存，生成的地址是虚拟地址，需要通过地址转换机制转换成物理地址。</li>
</ul>
<p><strong>2. 地址转换：</strong></p>
<ul>
<li><strong>页表查询</strong>：通过页表（Page
Table）将虚拟地址转换为物理地址。页表存储在内存中，但为了加速转换过程，常用的页表项会缓存到转换后备缓冲（TLB，Translation
Lookaside Buffer）中。</li>
<li><strong>TLB查找</strong>：处理器首先查询TLB。如果找到匹配项，直接使用转换后的物理地址。如果没有找到，则需要访问页表进行转换，并可能更新TLB。</li>
<li><strong>页表遍历</strong>：如果TLB没有命中，处理器会访问页表（可能涉及多级页表），获取物理地址。</li>
</ul>
<p><strong>3. 检查缓存：</strong></p>
<ul>
<li><strong>一级缓存（L1
Cache）查找</strong>：处理器首先查找L1缓存，如果命中，则从L1缓存中读取或写入数据。</li>
<li><strong>二级缓存（L2
Cache）查找</strong>：如果L1缓存未命中，继续查找L2缓存。</li>
<li><strong>三级缓存（L3
Cache）查找</strong>：如果L2缓存未命中，继续查找L3缓存。</li>
<li><strong>主内存访问</strong>：
如果所有缓存都未命中，则需要访问主内存（DRAM）。</li>
</ul>
<p><strong>4. 内存控制器操作：</strong></p>
<ul>
<li><p><strong>行地址选通（RAS）</strong>：内存控制器发送行地址并激活行地址选通信号（RAS），选择目标行。</p></li>
<li><p><strong>列地址选通（CAS）</strong>：内存控制器发送列地址并激活列地址选通信号（CAS），选择目标列。</p></li>
<li><p><strong>数据准备</strong>：内存控制器等待内存阵列准备好数据。</p></li>
<li><p><strong>5. 数据传输：</strong></p></li>
<li><p><strong>读取数据</strong>：如果是读操作，数据从内存传输到内存控制器，然后通过系统总线传输到处理器缓存或寄存器。</p></li>
<li><p><strong>写入数据</strong>：如果是写操作，数据从处理器传输到内存控制器，然后写入指定的内存单元。</p></li>
<li><p><strong>6. 缓存更新：</strong></p></li>
<li><p><strong>缓存写入</strong>：如果数据被写入缓存，需要相应地更新缓存内容（包括L1、L2、L3缓存）。</p></li>
<li><p><strong>缓存一致性</strong>：保持缓存一致性（如通过MESI协议）以确保数据的一致性和正确性。</p></li>
<li><p><strong>内存刷新（仅DRAM）：</strong></p></li>
<li><p>周期性刷新：DRAM需要周期性刷新操作以保持数据。刷新操作由内存控制器管理，并在后台进行，不直接影响单次内存访问，但会占用内存带宽。</p></li>
</ul>
<h4 id="内存参数">内存参数</h4>
<p><strong>1. 内存延迟（Memory Latency）</strong></p>
<ul>
<li><strong>定义</strong>：内存延迟是从处理器发出内存访问请求到第一个字节的数据开始被返回所需要的时间。内存延迟通常用纳秒（ns）来表示。由<strong>行地址传输时间</strong>，
<strong>列地址传输时间</strong>，
<strong>数据准备时间</strong>组成，主要受内存的内部架构和访问机制影响。</li>
<li><strong>意义</strong>：低内存延迟意味着处理器能够更快地访问内存数据，从而提高运行速度。</li>
</ul>
<p><strong>2. 内存访问时间（Memory Access Time）</strong></p>
<ul>
<li><strong>定义</strong>：内存访问时间是从处理器发出内存访问请求到数据完全被处理器接收的总时间，包括内存延迟和数据传输时间。它通常也是用纳秒（ns）来表示。由<strong>内存延迟</strong>和<strong>数据传输时间</strong>组成，除了内存内部架构和访问机制外，还受到数据总线速度、数据块大小和传输方式的影响。</li>
<li><strong>意义</strong>：较短的内存访问时间提高了处理器的执行效率。</li>
</ul>
<p><strong>3. 内存循环周期（Memory Cycle Time）</strong></p>
<ul>
<li><strong>定义</strong>：从开始一次内存访问（例如一次读取操作）到内存准备好进行下一次(关闭行等)访问的总时间。这个时间包括访问内存单元、传输数据以及内存准备下一个访问所需的恢复时间。由<strong>内存访问时间</strong>和<strong>恢复时间</strong>(内存在完成一次访问后，需要一定时间恢复到可以进行下一次访问的状态)组成，</li>
<li><strong>意义</strong>：较短的内存循环周期使得内存可以更频繁地进行访问操作，提高访问效率。</li>
</ul>
<p><strong>4. 内存访问频率（Memory Access Frequency）</strong></p>
<ul>
<li><strong>定义</strong>：内存访问频率指的是内存可以进行读写操作的频率，通常用MHz或GHz来表示,不同类型的内存具有不同的访问频率。常见的DDR4：频率范围在1600MHz到3200MHz之间。</li>
<li><strong>意义</strong>：较高的内存访问频率表示内存可以更频繁地进行读写操作，也意味着更高的传输速率和更高的带宽。</li>
</ul>
<p><strong>5. 内存带宽（Memory Bandwidth）</strong></p>
<ul>
<li><strong>定义</strong>：内存带宽是指在一定时间内从内存传输到处理器的数据量，通常以GB/s（每秒千兆字节）为单位。</li>
<li><strong>意义</strong>：高内存带宽意味着处理器能够更快地读取和写入数据，提高系统整体性能。带宽的计算公式如下：
<span class="math display">\[{内存带宽（GB/s）}=
{数据传输速率（MT/s）}\times {总线宽度（字节）} \times {通道数}\]</span>
例如，对于DDR4-3200内存，假设是单通道64位总线：内存带宽=3200MT/s×8B×1=25.6GB/s</li>
</ul>
<p><strong>6. 时钟周期（Clock Cycles）</strong></p>
<ul>
<li><strong>定义</strong>：内存时钟信号的一个完整周期，从一个上升沿到下一个上升沿，或从一个下降沿到下一个下降沿。在一个时钟周期内，内存会执行部分操作或完成一个完整的操作步骤。</li>
<li><strong>意义</strong>：较少的时钟周期表示更高效的内存访问。假设一个DDR4内存模块的时钟频率为3200MHz，其对应的时钟周期为：
<span class="math display">\[时钟周期= \frac{1}{时钟频率}\]</span> <span
class="math display">\[时钟周期= \frac{1}{3200 \times 10^{6}Hz} ≈ 0.3125
ns\]</span></li>
</ul>
<p>这意味着在3200MHz的频率下，每个时钟周期的时间长度约为0.3125纳秒。</p>
<p><strong>7. 数据传输率（Data Transfer Rate）</strong> -
<strong>定义</strong>：内存在一定时间内传输的数据量。它通常以每秒传输的百万次传输（MT/s）表示，并可以进一步换算成带宽（GB/s）。
-
<strong>意义</strong>：高数据传输率表示更快的数据移动速度，提高系统性能。数据传输率的计算:</p>
<p><strong>8. 内存命中率（Memory Hit Rate）</strong></p>
<ul>
<li><strong>定义</strong>：内存命中率是指缓存中的数据被请求到的比例。高命中率意味着大多数内存请求可以在缓存中找到。</li>
<li><strong>意义</strong>：高内存命中率减少了对主内存的访问次数。</li>
</ul>
<p><strong>9. 页错误率（Page Fault Rate）</strong> -
<strong>定义</strong>：页错误率是指在虚拟内存系统中，处理器试图访问未加载到物理内存中的页面时发生的错误率。
- <strong>意义</strong>：低页错误率意味着较少的磁盘访问。</p>
<p><strong>10. 队列长度（Queue Length）</strong> -
<strong>定义</strong>：内存队列长度指的是在任何给定时间内等待处理的内存请求的数量。这些请求可能是由于处理器需要读取或写入数据到内存而产生的。队列长度是一个重要的性能指标，因为它可以反映系统的负载和效率。
-
<strong>意义</strong>：较短的队列长度表示更快的请求处理时间。表示内存子系统能够有效地处理内存请求，系统运行更平稳</p>
<p><strong>11. 内存使用率（Memory Utilization）</strong> -
<strong>定义</strong>：内存使用率是指系统总内存的使用情况，通常以百分比表示。
-
<strong>意义</strong>：高内存使用率可能表示内存压力较大，需优化内存分配和使用策略。</p>
<h3 id="cpu">CPU</h3>
<p>中央处理器（CPU, Central Processing
Unit）是计算机系统的核心组件，负责执行指令和处理数据。它被称为计算机的大脑，因为它执行所有的基本计算任务。</p>
<h4 id="cpu的基本组成部分">CPU的基本组成部分</h4>
<p><strong>1. 运算逻辑单元（ALU, Arithmetic Logic Unit）：</strong></p>
<ul>
<li>执行所有的算术和逻辑操作，如加、减、乘、除以及逻辑运算（如与、或、非）。</li>
</ul>
<p><strong>2. 控制单元（CU, Control Unit）：</strong></p>
<ul>
<li>负责从内存中取指令、解释指令并执行。它控制ALU、寄存器和其他组件的操作。</li>
</ul>
<p><strong>3. 寄存器（Registers）：</strong></p>
<ul>
<li>CPU内部的高速存储单元，用于暂时存储指令、数据和地址信息。常见寄存器包括程序计数器（PC）、指令寄存器（IR）和累加器（ACC）。</li>
</ul>
<p><strong>4. 高速缓存（Cache）：</strong></p>
<ul>
<li>位于CPU和主存之间的高速存储器，用于存储频繁使用的数据和指令，减少访问主存的时间。</li>
</ul>
<p><strong>5. 总线接口单元（Bus Interface Unit）：</strong></p>
<ul>
<li>负责CPU与其他组件（如内存、输入/输出设备）之间的数据传输。</li>
</ul>
<h4 id="cpu执行代码过程">CPU执行代码过程</h4>
<p>CPU执行代码的过程是一个复杂且高度优化的操作，涉及多个阶段和不同的硬件组件。以下是详细的执行过程，分为几个主要步骤：</p>
<p><strong>1. 取指令（Fetch）</strong></p>
<ul>
<li><p><strong>过程</strong>：从内存中读取下一条指令。</p></li>
<li><p><strong>详细说明：</strong></p>
<ol type="1">
<li><strong>程序计数器（Program Counter,
PC）</strong>：指向将要执行的下一条指令的内存地址。</li>
<li><strong>取指单元（Fetch
Unit）</strong>：从内存中读取指令，并将其放入指令寄存器（Instruction
Register, IR）。</li>
</ol></li>
</ul>
<p><strong>2. 解码（Decode）</strong></p>
<ul>
<li><p><strong>过程</strong>：将取回的指令翻译成CPU能够理解的控制信号。</p></li>
<li><p><strong>详细说明：</strong></p>
<ol type="1">
<li><strong>指令解码器（Instruction
Decoder）</strong>：分析指令的操作码（Opcode）和操作数（Operands）。</li>
<li><strong>生成控制信号</strong>：根据指令的类型，生成相应的控制信号，以驱动后续的执行单元。</li>
</ol></li>
</ul>
<p><strong>3. 读取操作数（Operand Fetch）</strong></p>
<ul>
<li><p><strong>过程</strong>：从寄存器或内存中读取指令所需的数据。</p></li>
<li><p><strong>详细说明：</strong></p>
<ol type="1">
<li><strong>寄存器读取</strong>：如果操作数在寄存器中，直接从寄存器文件中读取。</li>
<li><strong>内存读取</strong>：如果操作数在内存中，CPU会发出内存读取请求，将数据从内存中加载到寄存器中。</li>
</ol></li>
</ul>
<p><strong>4. 执行（Execute）</strong></p>
<ul>
<li><p><strong>过程</strong>：根据指令类型，进行相应的计算或操作。</p></li>
<li><p><strong>详细说明：</strong></p>
<ol type="1">
<li><strong>算术逻辑单元（ALU, Arithmetic Logic
Unit）</strong>：执行算术和逻辑运算。</li>
<li><strong>浮点单元（FPU, Floating Point
Unit）</strong>：执行浮点运算。</li>
<li><strong>分支单元（Branch Unit）</strong>：处理跳转和分支指令。</li>
<li><strong>特殊指令</strong>：如加载、存储、移位等操作。</li>
</ol></li>
</ul>
<p><strong>5. 访问内存（Memory Access）</strong></p>
<ul>
<li><p><strong>过程</strong>：对于需要访问内存的指令，执行读写操作。</p></li>
<li><p><strong>详细说明：</strong></p>
<ol type="1">
<li><strong>加载指令</strong>：将数据从内存加载到寄存器。</li>
<li><strong>存储指令</strong>：将数据从寄存器存储到内存。</li>
</ol></li>
</ul>
<p><strong>6. 写回（Write Back）</strong></p>
<ul>
<li><p><strong>过程</strong>：将执行结果写回寄存器或内存。</p></li>
<li><p><strong>详细说明：</strong></p>
<ol type="1">
<li><strong>结果写回寄存器</strong>：执行结果写回到目标寄存器。</li>
<li><strong>结果写回内存</strong>：在必要时，将结果写回到内存中。</li>
</ol></li>
</ul>
<p><strong>7. 更新程序计数器（Update PC）</strong></p>
<ul>
<li><p><strong>过程</strong>：更新程序计数器，以指向下一条指令的地址。</p></li>
<li><p><strong>详细说明：</strong></p>
<ol type="1">
<li><strong>顺序执行</strong>：PC通常递增以指向下一条顺序指令。</li>
<li><strong>跳转和分支</strong>：如果是跳转或分支指令，PC会更新为目标地址。</li>
</ol></li>
</ul>
<p><strong>CPU执行指令的具体硬件组件</strong></p>
<ul>
<li><strong>寄存器（Registers）</strong>：用于存储临时数据和指令。</li>
<li><strong>缓存（Cache）</strong>：加速数据访问，减少对内存的访问延迟。</li>
<li><strong>控制单元（Control
Unit）</strong>：生成控制信号，协调各个部分的工作。</li>
<li><strong>流水线（Pipeline）</strong>：分解指令执行过程，允许多个指令同时在不同阶段执行，提高并行度和吞吐量。</li>
<li><strong>分支预测（Branch
Prediction）</strong>：预测分支指令的执行路径，减少流水线中断。</li>
</ul>
<p><strong>流水线执行过程</strong></p>
<p>现代CPU通常采用流水线技术，将指令执行过程分解为多个阶段，允许多个指令同时在不同阶段执行。典型的流水线阶段包括：</p>
<ol type="1">
<li><strong>取指（Fetch）</strong></li>
<li><strong>解码（Decode）</strong></li>
<li><strong>执行（Execute）</strong></li>
<li><strong>访存（Memory Access）</strong></li>
<li><strong>写回（Write Back）</strong></li>
</ol>
<p><strong>超标量和超线程技术</strong></p>
<ul>
<li><strong>超标量（Superscalar）</strong>：同时执行多条指令，通过多个执行单元实现。</li>
<li><strong>超线程（Hyper-Threading）</strong>：在一个物理核心上同时运行多个线程，提高并行处理能力。</li>
</ul>
<p><strong>执行流程的优化技术</strong></p>
<ul>
<li><strong>分支预测（Branch
Prediction）</strong>：减少分支指令导致的流水线中断。</li>
<li><strong>动态调度（Dynamic
Scheduling）</strong>：根据资源可用性和指令依赖关系，动态调整指令执行顺序。</li>
<li><strong>投机执行（Speculative
Execution）</strong>：在确认分支路径前，提前执行可能的指令路径。</li>
</ul>
<h4 id="cpu参数">CPU参数</h4>
<p><strong>1.时钟速度（Clock Speed）</strong></p>
<ul>
<li><strong>定义</strong>：CPU的时钟频率，通常以千兆赫兹（GHz）表示。</li>
<li><strong>作用</strong>：时钟速度直接影响CPU每秒钟可以执行的指令数。更高的时钟速度通常意味着更快的处理速度，但也需要考虑功耗和散热。</li>
</ul>
<p><strong>2. 指令每周期（IPC, Instructions Per Cycle）</strong></p>
<ul>
<li><strong>定义</strong>：CPU每个时钟周期内可以执行的指令数。</li>
<li><strong>作用</strong>：高IPC表示CPU在相同时钟速度下能够完成更多工作，反映了CPU架构的效率。</li>
</ul>
<p><strong>3. 核心数量（Number of Cores）</strong></p>
<ul>
<li><strong>定义</strong>：CPU内部的独立处理单元数量。</li>
<li><strong>作用</strong>：多核CPU能够并行处理多个任务，有助于提升多任务处理和多线程应用的性能。</li>
</ul>
<p><strong>4. 线程数量（Number of Threads）</strong></p>
<ul>
<li><strong>定义</strong>：CPU可以同时处理的线程数。</li>
<li><strong>作用</strong>：支持超线程技术（如Intel的Hyper-Threading）可以进一步提高并行处理能力，尤其是在多线程应用中。</li>
</ul>
<p><strong>5. 缓存大小（Cache Size）</strong></p>
<ul>
<li><strong>定义</strong>：CPU内部的高速缓存容量，包括L1、L2和L3缓存。</li>
<li><strong>作用</strong>：较大的缓存可以减少内存访问延迟，提高数据访问速度，从而提升整体性能。</li>
</ul>
<p><strong>6. 内存带宽（Memory Bandwidth）</strong></p>
<ul>
<li><strong>定义</strong>：CPU与系统内存之间的数据传输速率，通常以GB/s表示。</li>
<li><strong>作用</strong>：更高的内存带宽可以加快数据传输，减少内存瓶颈，尤其对数据密集型应用有重要影响。</li>
</ul>
<p><strong>7. 内存延迟（Memory Latency）</strong></p>
<ul>
<li><strong>定义</strong>：CPU从内存请求数据到接收到数据所需的时间。</li>
<li><strong>作用</strong>：较低的内存延迟可以减少等待时间，提高整体系统响应速度。</li>
</ul>
<p><strong>8. 分支预测准确率（Branch Prediction Accuracy）</strong></p>
<ul>
<li><strong>定义</strong>：CPU预测程序中分支指令（如条件跳转）的准确率。</li>
<li><strong>作用</strong>：高分支预测准确率可以减少流水线冲刷，提升指令执行效率。</li>
</ul>
<p><strong>9. 专用加速器（Dedicated Accelerators）</strong></p>
<ul>
<li><strong>定义</strong>：CPU中集成的专用硬件单元，如图形处理单元（GPU）、神经处理单元（NPU）等。</li>
<li><strong>作用</strong>：专用加速器能够显著提升特定任务的性能，如图形渲染、AI计算等。</li>
</ul>
<p><strong>10. 功耗（Power Consumption）</strong></p>
<ul>
<li><strong>定义</strong>：CPU运行时的电能消耗，通常以瓦特（W）为单位。</li>
<li><strong>作用</strong>：较低的功耗可以延长电池续航时间，减少散热需求，但可能会限制性能。</li>
</ul>
<p><strong>11. 热设计功耗（TDP, Thermal Design Power）</strong></p>
<ul>
<li><strong>定义</strong>：CPU在高负载下的最大功耗，通常以瓦特（W）表示。</li>
<li><strong>作用</strong>：TDP越高，通常意味着CPU在高负载下可以保持更高的性能，但也需要更好的散热解决方案。</li>
</ul>
<p><strong>12. 系统总线速度（System Bus Speed）</strong></p>
<ul>
<li><strong>定义</strong>：CPU与其他系统组件（如内存、I/O设备）之间的数据传输速率。</li>
<li><strong>作用</strong>：更高的总线速度可以提高数据传输效率，减少瓶颈。</li>
</ul>
<p><strong>13. 上下文切换时间（Context Switch Time）</strong></p>
<ul>
<li><strong>定义</strong>：CPU在不同任务之间切换时所需的时间。</li>
<li><strong>作用</strong>：较短的上下文切换时间可以提高多任务处理效率。</li>
</ul>
<p><strong>14. 平均负载（Average Load）</strong></p>
<ul>
<li><strong>定义</strong>：CPU在一定时间内的平均工作负载。</li>
<li><strong>作用</strong>：平均负载可以反映系统在日常使用中的性能表现，过高的平均负载可能表示系统瓶颈。</li>
</ul>
<p><strong>15. 使用率（Utilization）</strong></p>
<ul>
<li><strong>定义</strong>：CPU在特定时间段内的使用百分比。</li>
<li><strong>作用</strong>：高使用率通常表示CPU处于高负载状态，但持续的高使用率可能导致过热和性能下降。</li>
</ul>
<p><strong>16. 吞吐量（Throughput）</strong></p>
<ul>
<li><strong>定义</strong>：CPU在单位时间内可以处理的任务或数据量。</li>
<li><strong>作用</strong>：较高的吞吐量表示CPU能够高效处理大量任务，提高整体系统性能。</li>
</ul>
<p><strong>17. 延迟（Latency）</strong></p>
<ul>
<li><strong>定义</strong>：任务从发出到被处理的时间延迟。</li>
<li><strong>作用</strong>：较低的延迟表示系统响应速度快，对于实时应用尤为重要。</li>
</ul>
<h3 id="网络">网络</h3>
<p>计算机网络是由多个部分组成的复杂系统，这些部分共同工作以实现数据传输、资源共享和通信功能。</p>
<h4 id="网络组成">网络组成</h4>
<p><strong>1. 网络设备</strong></p>
<p><strong>a. 终端设备</strong></p>
<ul>
<li><strong>计算机</strong>：包括桌面计算机、笔记本电脑、服务器等，作为网络中的数据源和数据接收者。</li>
<li><strong>移动设备</strong>：如智能手机、平板电脑等，可以通过无线连接加入网络。</li>
<li><strong>其他设备</strong>：如打印机、IP电话、摄像头等，能够通过网络提供各种服务。</li>
</ul>
<p><strong>b. 中间设备</strong></p>
<ul>
<li><strong>路由器（Router）</strong>：用于连接不同网络，负责数据包的转发和路由选择。</li>
<li><strong>交换机（Switch）</strong>：在局域网（LAN）中用于连接多个设备，基于MAC地址进行数据帧转发。</li>
<li><strong>集线器（Hub）</strong>：一种早期的网络设备，广播接收到的数据帧到所有端口（已逐步被交换机取代）。</li>
<li><strong>网关（Gateway）</strong>：连接不同网络协议的设备，充当协议转换器。</li>
<li><strong>防火墙（Firewall）</strong>：用于监控和控制进出网络的数据流，提供安全防护。</li>
</ul>
<p><strong>2. 网络介质</strong></p>
<p><strong>a. 有线介质</strong></p>
<ul>
<li><strong>双绞线（Twisted Pair
Cable）</strong>：常用于以太网连接，有UTP和STP两种类型。</li>
<li><strong>同轴电缆（Coaxial
Cable）</strong>：用于有线电视和早期的以太网连接。</li>
<li><strong>光纤电缆（Fiber Optic
Cable）</strong>：通过光信号传输数据，具有高带宽和长传输距离。</li>
</ul>
<p><strong>b. 无线介质</strong></p>
<ul>
<li><strong>无线电波（Radio
Waves）</strong>：用于Wi-Fi、蓝牙等无线通信。</li>
<li><strong>微波（Microwaves）</strong>：用于远程无线通信，如卫星通信。</li>
<li><strong>红外线（Infrared）</strong>：用于短距离无线通信，如遥控器。</li>
</ul>
<p><strong>3. 网络协议</strong></p>
<p><strong>a. 应用层协议</strong></p>
<ul>
<li><strong>HTTP/HTTPS</strong>：用于Web服务的超文本传输协议。</li>
<li><strong>FTP</strong>：文件传输协议，用于文件上传和下载。</li>
<li><strong>SMTP/IMAP/POP3</strong>：用于电子邮件传输的协议。</li>
<li><strong>DNS</strong>：域名系统，用于域名解析。</li>
</ul>
<p><strong>b. 传输层协议</strong></p>
<ul>
<li><strong>TCP</strong>：传输控制协议，提供可靠的、面向连接的通信。</li>
<li><strong>UDP</strong>：用户数据报协议，提供无连接的、不可靠的通信。</li>
</ul>
<p><strong>c. 网络层协议</strong></p>
<ul>
<li><strong>IP</strong>：互联网协议，负责数据包的寻址和路由选择。</li>
<li><strong>ICMP</strong>：互联网控制报文协议，用于诊断网络连接。</li>
</ul>
<p><strong>d. 数据链路层协议</strong></p>
<ul>
<li><strong>以太网（Ethernet）</strong>：局域网中常用的链路层协议。</li>
<li><strong>PPP</strong>：点对点协议，用于拨号连接。</li>
</ul>
<p><strong>4. 网络架构</strong></p>
<p><strong>a. 拓扑结构</strong></p>
<ul>
<li><strong>星型拓扑</strong>：所有设备连接到中央交换机或集线器。</li>
<li><strong>总线型拓扑</strong>：所有设备共享一条通信介质。</li>
<li><strong>环型拓扑</strong>：设备连接成一个环，数据沿环传输。</li>
<li><strong>网状拓扑</strong>：设备之间相互连接，提供多条路径。</li>
</ul>
<p><strong>b. 网络类型</strong></p>
<ul>
<li><strong>局域网（LAN）</strong>：覆盖小范围区域，如办公室或家庭。</li>
<li><strong>广域网（WAN）</strong>：覆盖大范围区域，如城市或国家。</li>
<li><strong>城域网（MAN）</strong>：覆盖中等范围区域，如城市。</li>
<li><strong>个人区域网（PAN）</strong>：覆盖个人范围，如蓝牙设备之间的连接。</li>
</ul>
<h4 id="网络通信过程">网络通信过程</h4>
<p>一个数据包是如何从客户端到达服务器的过程是一个复杂的、多层次的过程，涉及多个网络协议和设备。以下是一个详细的步骤描述：</p>
<p><strong>1. 应用层</strong></p>
<p><strong>客户端生成请求：</strong></p>
<ul>
<li>用户在客户端应用（例如浏览器）中输入一个URL并按下回车键。</li>
<li>应用程序生成一个HTTP请求消息，并将其传递到传输层。</li>
</ul>
<p><strong>2. 传输层</strong></p>
<p><strong>封装为TCP/UDP段：</strong></p>
<ul>
<li>传输层（通常是TCP或UDP协议）接收应用层数据，将其封装成一个TCP段或UDP数据报。</li>
<li>如果使用TCP协议：
<ul>
<li>TCP段头部包含源端口、目标端口、序列号、确认号、窗口大小等信息。</li>
<li>TCP连接通过三次握手建立。</li>
</ul></li>
<li>如果使用UDP协议：
<ul>
<li>UDP数据报头部包含源端口、目标端口、长度和校验和等信息。</li>
</ul></li>
</ul>
<p><strong>3. 网络层</strong></p>
<p><strong>封装为IP数据包：</strong></p>
<ul>
<li>网络层（IP协议）接收传输层段或数据报，将其封装成一个IP数据包。</li>
<li>IP包头包含源IP地址、目标IP地址、TTL（生存时间）等信息。</li>
<li>路由选择算法确定数据包的最佳路径。</li>
</ul>
<p><strong>4. 数据链路层</strong></p>
<p><strong>封装为帧：</strong></p>
<ul>
<li>数据链路层接收IP数据包，将其封装成一个数据帧。</li>
<li>帧头部包含源MAC地址、目标MAC地址和帧校验序列（FCS）。</li>
<li>数据帧通过物理层传输到下一跳。</li>
</ul>
<p><strong>5. 物理层</strong></p>
<p><strong>传输数据：</strong></p>
<ul>
<li>物理层将数据帧转换为电信号或光信号，通过传输介质（如以太网、光纤或无线电波）发送到下一跳设备（如交换机或路由器）。</li>
</ul>
<p><strong>6. 交换机</strong></p>
<p><strong>局域网传输：</strong></p>
<ul>
<li>如果客户端和服务器在同一局域网（LAN）内，交换机会根据目标MAC地址将数据帧转发到目标服务器。</li>
<li>如果不在同一局域网内，数据帧会被转发到网关路由器。</li>
</ul>
<p><strong>7. 路由器</strong></p>
<p><strong>广域网传输：</strong></p>
<ul>
<li>路由器接收到数据帧，将其解封装为IP数据包。</li>
<li>路由器使用路由表查找目标IP地址的最佳路径，并将IP数据包封装成新的数据帧，发送到下一跳路由器。</li>
<li>此过程在多个路由器间进行，直至数据包到达目标局域网。</li>
</ul>
<p><strong>8. 目标局域网</strong></p>
<p><strong>局域网传输：</strong></p>
<ul>
<li>数据包进入目标局域网后，交换机根据目标MAC地址将数据帧转发到目标服务器。</li>
</ul>
<p><strong>9. 目标服务器</strong></p>
<p><strong>数据解封装：</strong></p>
<ul>
<li>服务器网络接口卡（NIC）接收数据帧，数据链路层解封装为IP数据包。</li>
<li>网络层将IP数据包解封装为TCP段或UDP数据报。</li>
<li>传输层根据目标端口号将数据传递到相应的应用程序。</li>
</ul>
<p><strong>10. 应用层</strong></p>
<p><strong>服务器处理请求：</strong></p>
<ul>
<li>服务器上的应用程序（例如Web服务器）接收并处理HTTP请求，生成响应消息。</li>
<li>响应消息经过相同的封装和传输过程返回给客户端。</li>
</ul>
<h4 id="网络参数">网络参数</h4>
<p><strong>1. 吞吐量（Throughput）</strong></p>
<ul>
<li><strong>定义</strong>：单位时间内成功传输的数据量，通常以比特每秒（bps）、千比特每秒（kbps）、兆比特每秒（Mbps）或千兆比特每秒（Gbps）表示。</li>
<li><strong>影响因素</strong>：网络带宽、传输协议、网络拥塞等。</li>
<li><strong>衡量方法</strong>：使用网络性能测试工具（如iPerf、Speedtest）进行测量。</li>
</ul>
<p><strong>2. 延迟（Latency）</strong></p>
<ul>
<li><strong>定义</strong>：数据从源到目的地所需的时间，通常以毫秒（ms）表示。</li>
<li><strong>影响因素</strong>：网络路径的长度和复杂性、路由器和交换机的处理时间、网络拥塞等。</li>
<li><strong>衡量方法</strong>：使用ping命令测量往返时间（RTT）。</li>
</ul>
<p><strong>3. 抖动（Jitter）</strong></p>
<ul>
<li><strong>定义</strong>：数据包之间传输延迟的变化量，通常以毫秒（ms）表示。</li>
<li><strong>影响因素</strong>：网络拥塞、路由器和交换机的处理时间波动等。</li>
<li><strong>衡量方法</strong>：使用工具（如ping、iPerf）测量连续数据包的延迟变化。</li>
</ul>
<p><strong>4. 数据包丢失率（Packet Loss Rate）</strong></p>
<ul>
<li><strong>定义</strong>：传输过程中丢失的数据包比例，通常以百分比表示。</li>
<li><strong>影响因素</strong>：网络拥塞、链路错误、硬件故障等。</li>
<li><strong>衡量方法</strong>：使用ping或其他网络诊断工具进行数据包传输测试。</li>
</ul>
<p><strong>5. 连接建立时间（Connection Establishment Time）</strong></p>
<ul>
<li><strong>定义</strong>：从发起连接请求到连接成功建立所需的时间，通常以毫秒（ms）表示。</li>
<li><strong>影响因素</strong>：服务器响应时间、网络延迟等。</li>
<li><strong>衡量方法</strong>：使用网络监控工具（如Wireshark）分析连接建立过程。</li>
</ul>
<p><strong>6. 响应时间（Response Time）</strong></p>
<ul>
<li><strong>定义</strong>：客户端发出请求到收到服务器响应的时间，通常以毫秒（ms）表示。</li>
<li><strong>影响因素</strong>：服务器处理能力、网络延迟、网络拥塞等。</li>
<li><strong>衡量方法</strong>：使用Web性能测试工具（如Pingdom、GTmetrix）进行测量。</li>
</ul>
<p><strong>7. 并发连接数（Concurrent Connections）</strong></p>
<ul>
<li><strong>定义</strong>：在同一时间段内网络上可以同时处理的连接数量。</li>
<li><strong>影响因素</strong>：服务器的处理能力、网络带宽、协议栈实现等。</li>
<li><strong>衡量方法</strong>：使用负载测试工具（如Apache
JMeter）进行测量。</li>
</ul>
<p><strong>8. 带宽利用率（Bandwidth Utilization）</strong></p>
<ul>
<li><strong>定义</strong>：实际使用的带宽与可用带宽的比例，通常以百分比表示。</li>
<li><strong>影响因素</strong>：网络应用的传输需求、网络的总带宽容量等。</li>
<li><strong>衡量方法</strong>：使用网络监控工具（如NetFlow、SNMP）进行测量。</li>
</ul>
<p><strong>9. 会话维持时间（Session Duration）</strong></p>
<ul>
<li><strong>定义</strong>：一个会话从开始到结束的时间长度，通常以秒或分钟表示。</li>
<li><strong>影响因素</strong>：应用特性、用户行为、网络稳定性等。</li>
<li><strong>衡量方法</strong>：使用应用监控工具（如Google Analytics、New
Relic）进行测量。</li>
</ul>
<p><strong>10. 错误率（Error Rate）</strong></p>
<ul>
<li><strong>定义</strong>：传输过程中发生错误的比例，通常以百分比表示。</li>
<li><strong>影响因素</strong>：网络噪声、链路错误、硬件故障等。</li>
<li><strong>衡量方法</strong>：使用网络诊断工具（如Wireshark、ping）分析数据传输错误。</li>
</ul>
<p><strong>11. 流量分析（Traffic Analysis）</strong></p>
<ul>
<li><strong>定义</strong>：分析网络上传输的数据流量，以便了解网络使用情况和发现潜在问题。</li>
<li><strong>影响因素</strong>：网络应用的类型、用户行为、网络架构等。</li>
<li><strong>衡量方法</strong>：使用网络流量分析工具（如Wireshark、NetFlow
Analyzer）进行分析。</li>
</ul>
<p><strong>12. 服务质量（Quality of Service, QoS）</strong> -
<strong>定义</strong>：衡量网络服务在传输过程中对不同类型流量的优先级管理和性能保证。
- <strong>影响因素</strong>：网络配置、QoS策略等。 -
<strong>衡量方法</strong>：使用网络监控和管理工具（如Cisco
QoS）进行测量和管理。</p>
<h2 id="性能分析工具">性能分析工具</h2>
<p>在Unity开发过程中，性能分析是确保游戏运行流畅和优化资源使用的重要步骤。市面上有很多分析工具，它们可以帮助我们识别和解决性能瓶颈。本节的主要目的是熟悉各种分析工具以及相关参数。</p>
<h3 id="unity-profiler">Unity Profiler</h3>
<p>Unity
Profiler是Unity自带的性能分析工具，功能强大，支持扩展可自定义统计数据。</p>
<h4 id="unity-profiler界面概述">Unity Profiler界面概述</h4>
<figure>
<img src="/images/unity/optimization/profiler-window-layout.png"
alt="主界面" />
<figcaption aria-hidden="true">主界面</figcaption>
</figure>
<ul>
<li>A:Profiler的模块窗口，包括CPU,GPU,Rendering,Memory,自定义等模块</li>
<li>B:工具栏，从左往右依次是：连接目标，数据记录开关，帧控制，清理，播放时清理开关，深度捕获开关，调用栈，打开profile数据，保存数据按钮，帮助按钮，设置按钮
<ul>
<li>深度捕获开关：开启后Unity将在每个函数（除Native函数）中添加捕获标记。</li>
<li>调用栈:可以在不开启深度捕获的情况下，捕获每个函数的内存分配</li>
</ul></li>
<li>C:帧图表区域，此区域显示每个模块捕获的性能数据图表。</li>
<li>D:模块详细信息，选择一个模块后，此区域显示模块的详细数据，每个模块显示的内容不一样。</li>
</ul>
<h4 id="资源模块">资源模块</h4>
<p>资源模块主要包含两个：文件访问分析模块（File Access Profiler
module）和资源加载分析模块（Asset Loading Profiler
module），如下图：</p>
<p><strong>文件访问分析模块</strong></p>
<p>此模块显示有关应用程序中文件活动的信息，例如 Unity
执行的读写操作数或打开的文件句柄数（针对特定帧或捕获的所有帧）。您可以使用此信息来帮助确定应用程序执行文件操作的效率。此模块可以捕获有关您构建的应用程序文件夹结构中任何文件的文件操作的信息，或者如果您在
Unity 编辑器中运行 Profiler，则可以捕获 Unity
项目文件夹中任何文件的文件操作的信息。</p>
<figure>
<img src="/images/unity/optimization/file_access.png"
alt="文件访问分析模块" />
<figcaption aria-hidden="true">文件访问分析模块</figcaption>
</figure>
<ul>
<li><strong>Files Opened</strong>: 此帧期间成功打开的文件总数。</li>
<li><strong>Files Closed</strong>：此帧期间成功关闭的文件总数。</li>
<li><strong>File Seeks</strong>：此帧期间修改文件指针位置的次数。</li>
<li><strong>Reads in
Flight</strong>：此帧期间正在进行的读取操作总数。</li>
<li><strong>File Handles
Open</strong>：此帧期间任何时候保持打开状态的文件句柄总数。这包括Unity在同一帧内打开和关闭的文件。</li>
</ul>
<p><strong>资源加载分析模块</strong></p>
<p>此模块显示有关应用程序如何加载资源的信息，包括按区域细分的读取操作。详细信息窗口提供了对在分析期间捕获的每个资源加载标记的深入了解。您可以使用此信息来了解应用程序加载资源的效率，并确定任何特定问题。</p>
<figure>
<img src="/images/unity/optimization/asset_loading.png"
alt="资源加载分析模块" />
<figcaption aria-hidden="true">资源加载分析模块</figcaption>
</figure>
<ul>
<li><strong>Texture Reads</strong>:
从AsyncReadManager请求加载纹理字节数。</li>
<li><strong>Virtual Texture Reads</strong>:
从AsyncReadManager请求加载虚拟纹理字节数。</li>
<li><strong>Mesh
Reads</strong>：从AsyncReadManager请求加载Mesh字节数。</li>
<li><strong>Audio
Reads</strong>：从AsyncReadManager请求音频字节数。</li>
<li><strong>Scripting
Reads</strong>：通过脚本API从AsyncReadManager请求的字节数。</li>
<li><strong>Entities Reads</strong>:
Entities包中的脚本，从AsyncReadManager请求的字节数。</li>
<li><strong>Other Reads</strong>:
除开上面的这些分类外，向AsyncReadManager请求的字节数。</li>
</ul>
<p>为了更好的理解文件的相关操作，我们通过一个简单的程序来分析文件的打开，定位，读写和关闭的操作。</p>
<h5 id="操作系统如何处理文件">操作系统如何处理文件</h5>
<p>先写一个简单的文件操作程序，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件以写入模式</span></span><br><span class="line">    FILE *file = fopen(<span class="string">"example.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"无法打开文件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一些文本到文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"This is a test file.\n"</span>, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新打开文件以读取模式</span></span><br><span class="line">    file = fopen(<span class="string">"example.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"无法打开文件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到第二个字符开始读</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(file, <span class="number">2</span>, SEEK_SET) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fseek 失败"</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取并打印文件内容</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(<span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="built_in">buffer</span>), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进程结构</strong></p>
<p>我们通过Linux源码来看一下，一个进程的大致结构，这个结构体非常大，我们看几个核心的字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>		<span class="title">thread_info</span>;</span> <span class="comment">// 线程信息</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			__state; <span class="comment">// 进程的状态</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid; <span class="comment">// 进程ID</span></span><br><span class="line">  <span class="keyword">pid_t</span> tgid; <span class="comment">// 线程组ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span> <span class="comment">// 进程启动时间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span> <span class="comment">// 真实启动时间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">// 进程的内存描述符，进程的内存布局由 struct mm_struct 管理，包含虚拟内存区域和页表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> <span class="comment">// 文件系统信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 打开的文件信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件系统信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>;</span> <span class="comment">// 根目录</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">pwd</span>;</span> <span class="comment">// 当前工作目录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件描述符表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span> <span class="comment">// 文件描述符表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span> <span class="comment">// 文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从进程的结构体中，我们可以发现 struct files_struct
*files，中存储了打开的文件信息。接下来我们去窥探一下文件的打开过程。</p>
<p><strong>打开过程</strong></p>
<p>在Linux内核中，open系统调用的核心代码位于fs/open.c文件中。open函数是用户空间程序用来打开文件的系统调用。以下是核心函数的详细说明：</p>
<ol type="1">
<li><strong>系统调用入口 (sys_open)</strong></li>
</ol>
<p><strong>概述：</strong> sys_open 是 open
系统调用的入口函数。它的作用是处理来自用户空间的 open 系统调用请求。</p>
<p><strong>代码：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(<span class="built_in">open</span>, <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, <span class="keyword">int</span>, flags, <span class="keyword">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - SYSCALL_DEFINE3 宏定义了 open
系统调用，接收三个参数：文件名、标志和模式。 - do_sys_open
函数是核心处理函数，处理具体的文件打开操作。</p>
<ol start="2" type="1">
<li><strong>核心处理函数 (do_sys_open)</strong></li>
</ol>
<p><strong>概述：</strong></p>
<p>do_sys_open
是核心处理函数，负责执行实际的文件打开操作。它处理文件路径解析、权限检查、文件描述符分配等。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">open_flags</span> <span class="title">op</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd = build_open_flags(flags, mode, &amp;op);</span><br><span class="line">    <span class="keyword">if</span> (fd)</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> do_filp_open(dfd, filename, &amp;op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>build_open_flags：解析和验证传入的标志和模式，构建 open_flags
结构体。</li>
<li>do_filp_open：执行具体的文件打开操作，并返回文件指针。</li>
</ul>
<ol start="3" type="1">
<li><strong>构建打开标志 (build_open_flags)</strong></li>
</ol>
<p><strong>概述：</strong></p>
<p>build_open_flags 函数解析并构建文件打开标志和模式。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build_open_flags</span><span class="params">(<span class="keyword">int</span> flags, <span class="keyword">umode_t</span> mode, struct open_flags *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 解析标志和模式，进行权限检查等 ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解析传入的 flags 和 mode 参数，并进行权限检查。</li>
</ul>
<ol start="4" type="1">
<li><strong>文件打开操作 (do_filp_open)</strong></li>
</ol>
<p><strong>概述：</strong></p>
<p>do_filp_open 函数处理文件路径解析、权限检查，并最终打开文件。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct file *<span class="title">do_filp_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct open_flags *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 nameidata 结构体</span></span><br><span class="line">    set_nameidata(&amp;nd, dfd, pathname);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析路径名</span></span><br><span class="line">    filp = path_openat(&amp;nd, op, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(filp))</span><br><span class="line">        <span class="keyword">return</span> filp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>set_nameidata：初始化 nameidata 结构体，用于路径解析。</li>
<li>path_openat：解析路径并执行文件打开操作。</li>
</ul>
<ol start="5" type="1">
<li><strong>路径解析和打开 (path_openat)</strong></li>
</ol>
<p><strong>概述：</strong></p>
<p>path_openat 函数解析文件路径并执行具体的打开操作。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct file *<span class="title">path_openat</span><span class="params">(struct nameidata *nd, <span class="keyword">const</span> struct open_flags *op, <span class="keyword">unsigned</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析路径</span></span><br><span class="line">    nd-&gt;flags = op-&gt;lookup_flags;</span><br><span class="line">    file = do_last(nd, file, op);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do_last：执行路径解析的最后一步，并打开文件。</li>
</ul>
<ol start="6" type="1">
<li><strong>最后一步解析和打开 (do_last)</strong></li>
</ol>
<p><strong>概述：</strong></p>
<p>do_last 函数完成路径解析的最后一步，并执行文件打开操作。</p>
<p><strong>代码：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct file *<span class="title">do_last</span><span class="params">(struct nameidata *nd, struct file *file, <span class="keyword">const</span> struct open_flags *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取目录 inode</span></span><br><span class="line">    dir = nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建或打开文件</span></span><br><span class="line">    dentry = lookup_open(nd, op, dir);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(dentry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并初始化 file 结构体</span></span><br><span class="line">    file = alloc_empty_file(op-&gt;open_flag, current_cred());</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line"></span><br><span class="line">    file-&gt;f_path = nd-&gt;path;</span><br><span class="line">    file-&gt;f_inode = dentry-&gt;d_inode;</span><br><span class="line">    file-&gt;f_op = fops_get(dentry-&gt;d_inode-&gt;i_fop);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> -
lookup_open：在目录中查找或创建文件。 - alloc_empty_file：分配并初始化
file 结构体。 - 初始化 file 结构体的各个字段，包括路径、inode
和文件操作指针。</p>
<p>通过上述代码和解释，可以看到 open 系统调用在 Linux
内核中经过了多个步骤和函数调用，包括路径解析、权限检查、文件描述符分配等。这些步骤协同工作，确保文件能够正确地被打开，并为进程提供所需的文件访问功能,
打开的文件会放在进程的struct files_struct
*files字段中。接下来我们再看一下文件指针的移动。</p>
<p><strong>定位</strong></p>
<p>定位的过程就是一个移动指针的过程，我们可以看一下struct file
结构体，它表示一个打开的文件，包含文件的状态和操作函数等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">f_path</span>;</span> <span class="comment">// 文件路径信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">f_inode</span>;</span>   <span class="comment">//结构体用于表示文件系统中每个文件或目录的索引节点。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">// 文件操作函数指针</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> f_count;  <span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> f_flags;   <span class="comment">// 文件标志</span></span><br><span class="line">    <span class="keyword">fmode_t</span> f_mode; <span class="comment">// 文件模式（读、写等）</span></span><br><span class="line">    <span class="keyword">loff_t</span> f_pos; <span class="comment">// 文件指针当前的读写位置</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义的大致流程如下：</p>
<p><strong>用户空间流程：</strong></p>
<ol type="1">
<li>fseek 函数：用户程序调用 fseek 函数。</li>
<li>调用 lseek：fseek 调用 lseek 系统调用。</li>
</ol>
<p><strong>内核空间流程：</strong></p>
<ol type="1">
<li>系统调用入口 (sys_lseek)：处理文件描述符，调用 vfs_llseek。</li>
<li>虚拟文件系统层 (vfs_llseek)：调用具体文件系统的 llseek 实现或默认
llseek 实现。</li>
<li>默认 llseek 实现 (default_llseek)：计算并更新文件指针。</li>
</ol>
<p>通过上述过程，fseek
函数实现了对文件指针的调整，从而支持文件的随机访问。内核中处理文件偏移调整的核心代码确保了这一过程的正确性和高效性。</p>
<p><strong>读</strong></p>
<p>在Linux内核中，读取的文件内容通过多个层次的缓存机制存储和管理，主要涉及以下几个关键组件和数据结构：</p>
<ol type="1">
<li><p><strong>页缓存（Page Cache）</strong></p></li>
<li><p><strong>地址空间（Address Space）</strong></p></li>
<li><p><strong>缓冲区头（Buffer Head）</strong></p></li>
<li><p><strong>页缓存（Page Cache）</strong>
页缓存是Linux内核用于缓存文件数据的主要机制。当文件被读取时，文件的内容首先会被缓存到页缓存中。页缓存是由多个内存页（通常是4KB）组成的。</p></li>
</ol>
<p><strong>相关数据结构：</strong></p>
<ul>
<li>struct page：表示一个物理内存页。</li>
<li>struct address_space：表示文件或设备的地址空间。</li>
</ul>
<p><strong>页缓存读取过程：</strong></p>
<ul>
<li>当用户进程通过系统调用（如
read）请求读取文件时，内核首先检查页缓存中是否存在请求的数据。</li>
<li>如果数据在页缓存中，则直接从页缓存返回数据。</li>
<li>如果数据不在页缓存中，则从磁盘读取数据到页缓存中，然后返回给用户进程。</li>
</ul>
<ol start="2" type="1">
<li><strong>地址空间（Address Space）</strong></li>
</ol>
<p>每个文件或设备都有一个地址空间（address_space），用于管理该文件或设备的页缓存。</p>
<p>struct address_space 结构体： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">host</span>;</span>          <span class="comment">/* 关联的 inode */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">page_tree</span>;</span>   <span class="comment">/* 用于存储页缓存的树结构 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>          tree_lock;      <span class="comment">/* 保护 page_tree 的自旋锁 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_mmap_writable; <span class="comment">/* 可写映射计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>      <span class="title">i_mmap</span>;</span>         <span class="comment">/* 区域映射的红黑树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_mmap_nonlinear</span>;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>            truncate_count; <span class="comment">/* 文件截断计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nrpages;        <span class="comment">/* 页缓存中的页数 */</span></span><br><span class="line">    <span class="keyword">pgoff_t</span>             writeback_index; <span class="comment">/* 写回索引 */</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li><strong>缓冲区头（Buffer Head）</strong></li>
</ol>
<p>在较老的文件系统中（如
ext2），缓冲区头（buffer_head）结构体用于管理磁盘块和页缓存之间的关系。现代文件系统（如
ext4）更多地依赖直接的页缓存管理。</p>
<p>struct buffer_head 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_next</span>;</span>  <span class="comment">/* 缓冲区链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;     <span class="comment">/* 逻辑块号 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short b_size;       <span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">    <span class="keyword">char</span> *b_data;                <span class="comment">/* 指向缓冲区数据的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span> <span class="comment">/* 关联的块设备 */</span></span><br><span class="line">    <span class="comment">// 其他字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从文件读取内容的典型流程，包括页缓存的使用：</p>
<ol type="1">
<li>系统调用接口：用户进程调用 read 系统调用请求读取文件。</li>
<li>文件系统层：文件系统的 read 方法处理读取请求。</li>
<li>页缓存检查：文件系统检查页缓存中是否已有请求的数据。</li>
</ol>
<ul>
<li>如果数据在页缓存中，则直接返回数据。</li>
<li>如果数据不在页缓存中，则从磁盘读取数据到页缓存，然后返回给用户进程。</li>
</ul>
<ol start="4" type="1">
<li>返回用户空间：读取的数据被拷贝到用户进程的缓冲区中。</li>
</ol>
<p><strong>关闭</strong></p>
<p>关闭文件时，内核执行的关键步骤包括：</p>
<ol type="1">
<li><strong>获取并释放文件描述符：</strong>从文件描述符表中删除对应的项。</li>
<li><strong>减少引用计数：</strong>调用 fput
减少文件指针的引用计数。</li>
<li><strong>最终清理：</strong>如果引用计数为0，调用 __fput
进行文件指针的最终清理，包括刷新数据、通知文件系统、清除
inode、释放路径、调用文件系统的 release 方法，最终释放文件结构。</li>
</ol>
<h4 id="内存模块">内存模块</h4>
<p>在Unity中，有两种方法可以分析应用程序的内存使用情况：</p>
<p><strong>内存分析器模块</strong>：内置的分析器模块，提供应用程序使用内存的基本信息。
<strong>内存分析器包</strong>：是一个可以添加到项目中的Unity包。它会向Unity编辑器添加一个额外的内存分析器窗口，然后我们可以使用它更详细地分析应用程序中的内存使用情况。也可以存储和比较快照以查找内存泄漏，或者查看内存布局以查找内存碎片问题。</p>
<p><strong>内存分析器模块</strong>会直观显示应用中分配的总内存量的计数器。可以使用内存模块查看已加载对象的数量以及每个类别中它们总共占用的内存量等信息。还可以查看每帧的GC分配数量。</p>
<p>在编辑器模式下的内存分析可能和实际的运行在目标平台上捕获到的内存存在差异，这主要是因为，当我们在编辑器中分析应用程序时，内存分析器模块报告的内存使用量比在目标设备上构建的应用程序的类似分析结果更高。这是因为Unity编辑器使用特定对象占用额外的内存，以及编辑器窗口本身使用额外的内存。
额外内存的主要原因是Unity将对象（如纹理）视为编辑器中启用的读/写功能，并在CPU上保留每个纹理的额外副本。这实际上使编辑器中报告的纹理内存使用量翻倍；为了更准确地了解纹理的内存使用情况，需要在目标平台上运行的应用程序的构建版本进行分析。</p>
<p>此外，由于Unity也无法将Profiler本身占用的内存与播放模式的内存完全分开，因此Profiler使用的内存会显示在Profiler窗口中。</p>
<p><strong>内存分析器模块</strong></p>
<figure>
<img src="/images/unity/optimization/memory_i.png"
alt="内存分析器模块" />
<figcaption aria-hidden="true">内存分析器模块</figcaption>
</figure>
<p><strong>内存分析器包</strong></p>
<figure>
<img src="/images/unity/optimization/memory_p.png"
alt="内存分析器包-概述" />
<figcaption aria-hidden="true">内存分析器包-概述</figcaption>
</figure>
<p>内存分布概述</p>
<figure>
<img src="/images/unity/optimization/memory_p_u.png"
alt="内存分析器包-Unity对象" />
<figcaption aria-hidden="true">内存分析器包-Unity对象</figcaption>
</figure>
<p>详细的Unity的对象</p>
<figure>
<img src="/images/unity/optimization/memory_p_a.png"
alt="内存分析器包-所有内存" />
<figcaption aria-hidden="true">内存分析器包-所有内存</figcaption>
</figure>
<p>所有的内存对象</p>
<p><strong>内存分析器包</strong>
可以对两次的内存快照进行比较，那确定是否有内存泄漏。</p>
<p><a
href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/index.html">内存分析器包文档</a></p>
<h5 id="操作系统如何管理内存">操作系统如何管理内存</h5>
<p>在Linux操作系统中，当进程启动时，内存分配和管理是通过多个步骤和系统调用来完成的。</p>
<ol type="1">
<li><strong>进程创建与内存分配的概述</strong></li>
</ol>
<p>当一个进程被创建时，通常是通过fork()系统调用来复制一个现有进程的内存空间。内存分配涉及到以下几个关键点：</p>
<ul>
<li>虚拟内存空间的创建</li>
<li>页表的建立与管理</li>
<li>实际物理内存的分配</li>
</ul>
<ol start="2" type="1">
<li><strong>关键的数据结构</strong></li>
</ol>
<p>2.1 <strong>进程描述符（task_struct）</strong></p>
<p>每个进程在Linux中都有一个task_struct结构体，该结构体保存了进程的所有信息，包括内存管理信息。这个结构体在include/linux/sched.h中定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">// 进程的内存描述符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.2 <strong>内存描述符（mm_struct）</strong></p>
<p>mm_struct是进程内存管理的核心结构，它描述了进程的虚拟地址空间。它在include/linux/mm_types.h中定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>  <span class="comment">// 线性区链表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data; <span class="comment">// 记录代码段，数据段，堆，栈等的内存区域</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pgd_t</span> *pgd;  <span class="comment">// 页全局目录</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>内存管理的主要流程</strong></li>
</ol>
<p>3.1 <strong>进程创建（fork()）时的内存分配</strong></p>
<ul>
<li>当 fork()
被调用时，Linux会为新进程创建一个新的task_struct以及一个新的mm_struct。</li>
<li>copy_mm() 函数被调用以复制父进程的内存管理结构。该函数在
kernel/fork.c 中定义。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mm_struct *<span class="title">copy_mm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    new_mm = allocate_mm(); <span class="comment">// 分配新的 mm_struct 结构</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        mm_dup(new_mm, oldmm);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> new_mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mm_dup()函数会复制父进程的mm_struct到子进程，同时通过copy_page_range()来复制父进程的页表。</p>
<p>3.2 <strong>虚拟内存区域（vm_area_struct）的管理</strong></p>
<p>虚拟内存区域 (vm_area_struct)
结构体描述了进程地址空间的连续区间，每个区间对应着不同的权限和用途（如代码段、数据段、堆、栈等）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>  <span class="comment">// 关联的内存描述符</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;   <span class="comment">// 起始地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;     <span class="comment">// 结束地址</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些结构在include/linux/mm_types.h中定义。</p>
<p>3.3 <strong>物理内存的分配</strong></p>
<p>实际的物理内存分配通常发生在需要访问某个页面（页缺失）的时刻。Linux使用按需分页机制，初始进程并不会立即分配所有物理内存。</p>
<p>当发生页缺失时，内核会通过 do_page_fault() 处理页缺失中断，并调用
alloc_page() 或 __get_free_pages() 来分配物理页面。alloc_page() 在
mm/page_alloc.c 中定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">alloc_page</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __alloc_pages(gfp_mask, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__alloc_pages()
是分配物理页的核心函数，负责找到合适的内存区域并标记为已分配。</p>
<h6 id="malloc和realloc实现">malloc和realloc实现</h6>
<p>malloc和realloc是用户空间内存分配函数，通常用于在C程序中动态分配和调整内存块的大小。在Linux系统中，malloc和realloc
的具体实现是通过C标准库（glibc）提供的，而不是直接由内核实现的。这些函数的底层实现涉及到内存管理函数，如brk和mmap，以便在进程的虚拟地址空间中分配内存。</p>
<ol type="1">
<li><strong>malloc的实现</strong></li>
</ol>
<p>malloc函数用于从堆中分配指定大小的内存块。其具体实现涉及以下几个步骤：</p>
<p>1.1 <strong>内存分配算法</strong></p>
<p>malloc在内部分配内存时，通常使用一些分配算法，如first fit、best fit
或 worst
fit。glibc实现通常使用binning技术，将不同大小的内存块放入不同的“垃圾桶”（bins）中，以便更快速地找到合适的内存块。</p>
<p>1.2 <strong>核心数据结构</strong></p>
<p>glibc的malloc实现使用了多个核心数据结构，其中最重要的是malloc_state和malloc_chunk：</p>
<ul>
<li>malloc_state: 代表一个分配器的状态，包括用于管理内存块的bins。</li>
<li>malloc_chunk:
表示内存块的头部，用于记录块的大小和状态（是否已使用等）。</li>
</ul>
<p>这些数据结构在glibc的malloc/malloc.c文件中定义。</p>
<p>1.3 <strong>实现细节</strong></p>
<p>当malloc被调用时，glibc会首先检查是否有合适大小的空闲内存块。如果没有，则调用sbrk()或mmap()从操作系统请求新的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr victim;</span><br><span class="line">    ...</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> chunk2mem(victim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_int_malloc是malloc的内部实现函数，它负责从适当的bin中查找或分配内存块。</p>
<ol start="2" type="1">
<li><strong>realloc的实现</strong></li>
</ol>
<p>realloc函数用于调整已分配内存块的大小。其实现相对复杂，因为它不仅需要调整内存块的大小，还可能需要将数据移动到新位置。</p>
<p>2.1 <strong>内存调整逻辑</strong></p>
<ul>
<li>如果现有的内存块足够大，则直接缩小或扩展该块。</li>
<li>如果现有的内存块无法满足要求，realloc
会分配一个新的内存块并将旧内存的数据复制到新块中。</li>
</ul>
<p>2.2 <strong>实现细节</strong></p>
<p>realloc的实现也是在glibc的malloc/malloc.c 文件中完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    mchunkptr oldp;  <span class="comment">// 指向原始块的指针</span></span><br><span class="line">    <span class="keyword">void</span> *newp;      <span class="comment">// 新分配块的指针</span></span><br><span class="line">    ...</span><br><span class="line">    newp = _int_realloc(ar_ptr, oldp, bytes);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> newp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_int_realloc是realloc的内部实现函数，它处理内存块的调整：</p>
<ul>
<li>如果新块比旧块小，直接修改块的大小。</li>
<li>如果新块比旧块大且相邻块有足够的空间，扩展现有块。</li>
<li>如果扩展不可能，则分配新块并复制数据。</li>
</ul>
<ol start="3" type="1">
<li><strong>Linux内核的支持</strong></li>
</ol>
<p>malloc和realloc的底层依赖于Linux内核的系统调用，例如：</p>
<ul>
<li>brk()：用于调整数据段的结尾，从而扩展或缩小堆。malloc在小规模内存分配时使用brk()。</li>
<li>mmap()：用于直接映射内存区域。malloc 在大规模内存分配时使用
mmap()，并且这种分配方式不受堆的限制。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    new_brk = do_brk(old_brk, increment);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do_brk在mm/mmap.c中定义，是实际执行堆扩展的函数。</p>
<h6 id="free实现">free实现</h6>
<p>free()函数在C语言中用于释放先前通过malloc()、calloc()(内存数据重置为0)、realloc()等函数分配的动态内存。它的具体实现依赖于底层的内存管理机制，并且在C标准库中通常通过glibc提供。free()的实现涉及对已分配内存块的管理、合并空闲块以及可能的内存释放回操作系统等操作。</p>
<ol type="1">
<li><strong>free()的概述</strong></li>
</ol>
<p>free()函数的主要功能是将动态分配的内存块标记为可用，并将其返回到内存分配器的空闲列表中，以供后续内存分配使用。它不会修改指针本身（即，不会将指针置为
NULL），并且不会清除内存内容，只是将内存块释放。</p>
<ol start="2" type="1">
<li><strong>free()的实现概述</strong></li>
</ol>
<p>free()的实现主要包含以下步骤：</p>
<ol type="1">
<li><p>检查指针有效性: 检查传递给 free() 的指针是否为空或无效。</p></li>
<li><p>获取内存块信息:
从指针推导出内存块的头部信息，通常通过指针减去一定的偏移量来获得内存块的头部信息。</p></li>
<li><p>合并相邻的空闲块:
如果被释放的内存块与相邻的内存块都是空闲的，内存分配器会尝试将这些块合并，以减少内存碎片。</p></li>
<li><p>更新空闲列表: 将释放的内存块插入到空闲列表或合适的 bin
中，以便在后续的内存分配请求中再次使用。</p></li>
<li><p><strong>具体实现细节</strong></p></li>
</ol>
<p>下面详细说明free()的实现，基于glibc中的malloc实现。glibc的内存分配器基于ptmalloc，它是一种基于dlmalloc的分配器。</p>
<p>3.1 <strong>核心数据结构</strong></p>
<p>glibc使用malloc_chunk结构体来描述内存块，它的定义通常在malloc.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>      prev_size;  <span class="comment">// 上一个块的大小（仅在前一个块空闲时有效）</span></span><br><span class="line">    <span class="keyword">size_t</span>      <span class="built_in">size</span>;       <span class="comment">// 当前块的大小和状态标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>  <span class="comment">// 下一个空闲块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>  <span class="comment">// 上一个空闲块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>prev_size</strong>: 如果前一个块空闲，则保存其大小。</li>
<li><strong>size</strong>:
当前块的大小及一些状态标志位（如是否空闲）。</li>
<li><strong>fd和bk</strong>: 空闲链表中的前后指针。</li>
</ul>
<p>3.2 <strong>free() 的实现</strong></p>
<p>glibc中free()的实现大致如下（在 malloc.c 中）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p;         <span class="comment">// 指向被释放块的指针</span></span><br><span class="line">    INTERNAL_SIZE_T <span class="built_in">size</span>;   <span class="comment">// 被释放块的大小</span></span><br><span class="line">    mchunkptr nextchunk; <span class="comment">// 下一个块的指针</span></span><br><span class="line">    INTERNAL_SIZE_T nextsize; <span class="comment">// 下一个块的大小</span></span><br><span class="line">    <span class="keyword">int</span> nextinuse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指针为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内存块的头部信息</span></span><br><span class="line">    p = mem2chunk(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取块的大小</span></span><br><span class="line">    <span class="built_in">size</span> = chunksize(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查该块是否为空闲块</span></span><br><span class="line">    <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">        <span class="comment">// 更新空闲列表，将当前块插入</span></span><br><span class="line">        unlink(p, bck, fwd);</span><br><span class="line">        consolidate(p);  <span class="comment">// 尝试合并相邻的空闲块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是通过 mmap 分配的块，直接释放</span></span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.3 <strong>关键函数说明</strong></p>
<ul>
<li>mem2chunk(ptr):
将用户指针转换为内存块的头部指针（即malloc_chunk结构体指针）。通常通过从ptr指针向前偏移来获得。</li>
<li>chunksize(p):
获取内存块的大小，包括头部信息。通常通过访问malloc_chunk结构体的size字段来获得。</li>
<li>unlink(p, bck, fwd):
从空闲列表中移除当前块。如果当前块已经空闲，意味着它可能被错误地多次释放或者存在内存管理上的问题。</li>
<li>consolidate(p):
尝试合并当前块与前后相邻的空闲块，以减少内存碎片。这有助于将多个小的空闲块合并成一个更大的块，从而更好地利用内存。</li>
<li>munmap_chunk(p):
如果内存块是通过mmap()分配的（通常用于分配大块内存），则直接使用munmap()释放该内存块。</li>
</ul>
<h4 id="cpu模块">CPU模块</h4>
<p>CPU使用率分析器模块包含一个图表，显示应用程序在哪些地方花费了时间。它概述了应用程序在哪些重要方面花费了时间，例如渲染、其脚本和动画。</p>
<p>模块详细信息窗口有三个视图模式： - <strong>Timeline</strong>：
显示特定帧的计时明细，以及帧长度的时间轴。这是唯一可用于同时查看所有线程的计时以及帧内发生计时的视图模式，以便您可以关联线程之间的计时（例如，作业系统工作线程在主线程上的系统对其进行调度后启动）。
- <strong>Hierarchy</strong>：
按内部层次结构对时间数据进行分组。此选项以降序列表格式显示应用程序调用的元素，默认按所用时间排序。您还可以按分配的脚本内存量
( GC Alloc )
或调用次数对信息进行排序。要更改对表格进行排序的列，请点击表格列的标题。
- <strong>Raw Hierarchy</strong>：
以与发生计时的调用堆栈类似的层次结构显示计时数据。在此模式下，Unity
会单独列出每个调用堆栈，而不是像在层次结构视图中那样合并它们。</p>
<figure>
<img src="/images/unity/optimization/cpu.png" alt="CPU分析模块" />
<figcaption aria-hidden="true">CPU分析模块</figcaption>
</figure>
<p>前面说的文件和内存资源都属于进程的资源，这些资源可以被进程中的线程进行共享访问，每个进程创建时都会相应的创建一个主线程。
从Timeline视图模式看，Unity创建多个线程，分别处理不同的任务，主要有：主线程（Main
Thread）、渲染线程（Render Thread）、工作线程（Job
Thread）和加载线程（Loading Thread）等。
下面看一下进程与线程的关系，以及线程的创建，执行和销毁相关的系统调用。</p>
<h5 id="进程与线程">进程与线程</h5>
<p>在Linux操作系统中，进程管理线程的方式、线程的创建、执行和销毁是通过一系列系统调用和内核机制实现的。这些操作涉及到Linux内核的调度器、进程控制块（PCB）、线程控制块（TCB）等关键概念。</p>
<ol type="1">
<li><strong>进程与线程的关系</strong>
在Linux中，线程可以被视为一种特殊的进程，称为“轻量级进程”（Lightweight
Process,
LWP）。多个线程共享同一个进程的资源（如内存空间、文件描述符等），但每个线程有自己独立的<strong>栈</strong>、<strong>寄存器</strong>和<strong>线程控制块（TCB）</strong>。</li>
</ol>
<ul>
<li><strong>进程</strong>：在Linux中，进程是资源分配的基本单位。</li>
<li><strong>线程</strong>：线程是调度的基本单位，它们共享进程的资源，但可以独立执行。
Linux内核将线程和进程统一管理，线程本质上是通过clone()系统调用创建的一个进程，只是它共享了父进程的某些资源。</li>
</ul>
<ol start="2" type="1">
<li><strong>线程的创建</strong></li>
</ol>
<p>线程的创建主要依赖于clone()系统调用，它在Linux内核中是创建新进程或线程的核心机制。线程可以通过pthread_create()函数或直接使用
clone()系统调用来创建。</p>
<p>2.1 <strong>clone()系统调用</strong></p>
<p>clone()是Linux中创建新进程或线程的核心系统调用。它允许新创建的进程/线程共享其父进程的资源，如内存地址空间、文件描述符、信号处理等。clone()的行为由传递的标志位（flags）决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *child_stack, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fn: 新线程执行的函数。</li>
<li>child_stack: 新线程的栈指针。</li>
<li>flags: 指定资源共享的标志，如
CLONE_VM（共享内存空间），CLONE_FS（共享文件系统信息）等。</li>
<li>arg: 传递给线程函数的参数。</li>
</ul>
<p>2.2 <strong>do_fork() 函数</strong></p>
<p>clone()调用内核中的do_fork()函数来实际创建新线程（或进程）。do_fork()负责创建新的task_struct，并初始化线程的各种资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size, <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> __user *child_tidptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> tls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size, child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.3 <strong>copy_process()函数</strong></p>
<p>copy_process()是创建新线程的核心函数。它复制父进程的task_struct并进行必要的初始化，包括设置线程的状态、分配内核栈、处理信号等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">copy_process</span><span class="params">(struct pid *pid, <span class="keyword">int</span> trace, <span class="keyword">int</span> node, struct kernel_clone_args *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">retval</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    p = dup_task_struct(current, node);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 共享或分配资源</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM)</span><br><span class="line">        p-&gt;mm = current-&gt;mm;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置栈指针</span></span><br><span class="line">    p-&gt;<span class="built_in">stack</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)child_stack;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dup_task_struct(): 复制当前进程的 task_struct。</li>
<li>p-&gt;mm = current-&gt;mm: 如果 CLONE_VM
标志设置，子线程与父线程共享内存空间。</li>
</ul>
<ol start="3" type="1">
<li><strong>线程的执行</strong></li>
</ol>
<p>线程创建后，内核调度器将其放入就绪队列，等待调度器分配CPU执行。线程的执行过程与普通进程相同。</p>
<p>3.1 <strong>调度器</strong></p>
<p>Linux调度器是内核负责分配CPU时间给线程的组件。调度器决定哪个线程获得CPU执行，并处理线程的上下文切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    next = pick_next_task(rq, prev);</span><br><span class="line">    ...</span><br><span class="line">    context_switch(rq, prev, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pick_next_task(): 选择下一个要执行的线程。</li>
<li>context_switch():
执行上下文切换，保存当前线程的状态并加载下一个线程的状态。</li>
</ul>
<p>3.2 <strong>上下文切换</strong></p>
<p>上下文切换涉及保存当前线程的CPU寄存器、程序计数器等状态，并加载要执行的线程的状态。Linux通过switch_to()函数完成上下文切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(prev, next, last)                   \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                  \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">prev</span> = (<span class="title">prev</span>);</span>              \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">next</span> = (<span class="title">next</span>);</span>              \</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"push %%rbp\n\t"</span> <span class="comment">// 保存栈基址寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 ...</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="string">"jmp __switch_to\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 ...</span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"=a"</span> (last) : <span class="string">"S"</span> (__prev), <span class="string">"D"</span> (__next))</span></span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>switch_to(): 完成实际的上下文切换，将 CPU 执行权转移到 next
线程。</li>
</ul>
<ol start="4" type="1">
<li><strong>线程的销毁</strong></li>
</ol>
<p>线程的销毁发生在线程完成其任务并退出时。线程的销毁涉及资源的释放、状态的更新和通知父线程。</p>
<p>4.1 <strong>do_exit()函数</strong></p>
<p>do_exit()是线程或进程退出时调用的核心函数。它负责清理线程的资源，将线程标记为僵尸状态，并通知父线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 清理线程资源</span></span><br><span class="line">    exit_mm(tsk);</span><br><span class="line">    exit_files(tsk);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将线程状态设置为 TASK_DEAD</span></span><br><span class="line">    tsk-&gt;state = TASK_DEAD;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通知父进程</span></span><br><span class="line">    notify_parent(tsk, tsk-&gt;exit_signal);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 进行最后的上下文切换</span></span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>exit_mm(): 释放内存资源。</li>
<li>exit_files(): 关闭打开的文件。</li>
<li>notify_parent(): 通知父进程线程已经退出。</li>
</ul>
<p>4.2 <strong>release_task()函数</strong></p>
<p>release_task()负责最终清理僵尸线程的资源，并将其从系统中移除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从任务链表中移除</span></span><br><span class="line">    list_del_rcu(&amp;p-&gt;tasks);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 释放 task_struct 结构体</span></span><br><span class="line">    free_task_struct(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>list_del_rcu(): 将任务从链表中删除。</li>
<li>free_task_struct(): 释放 task_struct 相关资源。</li>
</ul>
<h4 id="渲染模块">渲染模块</h4>
<p>显示渲染统计数据以及有关CPU和GPU渲染内容的信息，我们可以通过这些统计数据来衡量场景中不同区域的资源强度，这对于优化很有帮助。</p>
<p>该图表显示应用程序渲染的批次（Batches）、SetPass调用、三角形和顶点的数量。下方窗口显示更多渲染统计数据。</p>
<figure>
<img src="/images/unity/optimization/rendering.png" alt="渲染模块" />
<figcaption aria-hidden="true">渲染模块</figcaption>
</figure>
<p>为了更好的理解上面的这些参数，我们将以伪代码的方式说明一下Unity渲染对象的流程。</p>
<p>在Unity中，渲染流程涉及多个步骤和概念，其中包括SetPass Calls、Draw
Calls和Batches。理解这些概念及其在渲染流程中的作用，对优化Unity项目的性能至关重要。</p>
<ol type="1">
<li><strong>渲染流程简述</strong></li>
</ol>
<ul>
<li><strong>场景处理</strong>:
Unity根据摄像机的视角，计算出当前帧内所有可见的物体（Renderers）。</li>
<li><strong>SetPass Calls</strong>:
针对每个不同材质的物体，Unity会发起一次SetPass
Call，将材质（Shader，参数和贴图等）绑定到GPU。</li>
<li><strong>Draw Calls</strong>:
对每个可见物体，Unity向GPU发送渲染指令，通过Draw Call绘制物体。</li>
<li><strong>Batching</strong>: Unity尝试通过合批技术(动态，静态，GPU
Instancing等)，将多个Draw Calls合并为一个，以减少开销。</li>
</ul>
<ol start="2" type="1">
<li><strong>SetPass Calls</strong></li>
</ol>
<ul>
<li><strong>定义</strong>: SetPass
Call是指在渲染管线中，Unity将材质（Material）和着色器（Shader）切换到GPU的过程。每次需要更换材质或着色器时，都会产生一次SetPass
Call。</li>
<li><strong>源码分析</strong>: 在Unity内部，SetPass
Call通常是通过调用Material.SetPass()来实现的。这会将当前材质的渲染状态绑定到GPU，从而为后续的Draw
Call做好准备。</li>
<li><strong>性能影响</strong>: SetPass
Calls相对昂贵，因为它们涉及GPU状态的切换，频繁的SetPass
Calls会显著增加渲染开销。</li>
<li><strong>优化:</strong>
<ul>
<li>合并相同材质的对象以减少SetPass Calls。</li>
<li>使用图集（Texture Atlas）来减少材质切换。</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><strong>Draw Calls</strong></li>
</ol>
<ul>
<li><strong>定义</strong>: Draw
Call是指从CPU向GPU发出的一次渲染指令，用于绘制一个或多个三角形。每次调用Graphics.DrawMesh或Renderer.Render等渲染函数时都会产生Draw
Call。</li>
<li><strong>源码分析</strong>: 在Unity的渲染过程中，Draw
Call通常是通过以下流程产生的： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码说明Draw Call的处理流程</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> renderer <span class="keyword">in</span> visibleRenderers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (renderer.isVisible)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 准备材质和Shader</span></span><br><span class="line">        renderer.material.SetPass(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 触发一个绘制</span></span><br><span class="line">        Graphics.DrawMesh(renderer.mesh, renderer.transform.localToWorldMatrix, renderer.material, renderer.gameObject.layer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>性能影响</strong>: Draw
Calls是Unity渲染流程中的核心部分，过多的Draw
Calls会导致CPU和GPU之间的通信瓶颈。</li>
<li><strong>优化</strong>:
<ul>
<li>使用动态合批（Dynamic Batching）和静态合批（Static Batching）。</li>
<li>合并网格（Mesh）以减少Draw Calls。</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><strong>Batches</strong></li>
</ol>
<ul>
<li><strong>定义</strong>: Batches是指将多个Draw
Calls合并为一个，以减少CPU与GPU之间的通信次数。在Unity中，合批技术可以分为静态合批（Static
Batching）、动态合批（Dynamic Batching）和GPU Instancing。</li>
<li><strong>源码分析</strong>:
<ul>
<li>静态合批:
当多个静态对象使用相同的材质时，Unity会将它们的网格合并为一个以减少Draw
Calls。</li>
<li>动态合批:
适用于动态对象，小型网格的对象在满足一定条件时会被合并为一个Draw
Call。</li>
<li>GPU Instancing:
适用于同一个网格实例的多次渲染，将同一网格对象的多个实例合并为一个Draw
Call。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GPU Instanceing</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instanceCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    matrixArray[i] = Matrix4x4.TRS(positions[i], Quaternion.identity, Vector3.one);</span><br><span class="line">&#125;</span><br><span class="line">materialPropertyBlock.SetMatrixArray(<span class="string">"_Matrices"</span>, matrixArray);</span><br><span class="line">Graphics.DrawMeshInstanced(mesh, <span class="number">0</span>, material, matrixArray, instanceCount, materialPropertyBlock);</span><br></pre></td></tr></table></figure></li>
<li><strong>性能影响</strong>: 合批可以显著减少Draw
Calls的数量，从而提高渲染性能。</li>
<li><strong>优化</strong>:
<ul>
<li>对于静态物体，启用静态合批。</li>
<li>确保动态物体使用相同的材质和网格，以便动态合批生效。</li>
<li>使用GPU Instancing渲染大量相同的对象。</li>
</ul></li>
</ul>
<h4 id="ui模块">UI模块</h4>
<p>UI和UI细节分析器模块提供有关Unity在应用程序中布局和渲染用户界面所花费的时间和资源的信息。我们可以使用此模块了解Unity如何处理应用程序的UI批处理，包括批处理对象的原因和方式。我们可以使用此模块找出UI的哪个部分导致性能缓慢，或者在拖动时间轴时预览UI。</p>
<figure>
<img src="/images/unity/optimization/ui.png" alt="UI模块" />
<figcaption aria-hidden="true">UI模块</figcaption>
</figure>
<ul>
<li><strong>Layout</strong>:
Unity执行UI布局过程所花费的时间。这包括Horizo​​ntalLayoutGroup、VerticalLayoutGroup和GridLayoutGroup所做的计算。</li>
<li><strong>Render</strong>:
UI花费多少时间完成其渲染部分。这是直接渲染到图形设备或渲染到主渲染队列的成本。</li>
<li><strong>Batches</strong>: 显示批处理在一起的绘制调用总数。</li>
<li><strong>Vertices</strong>: 用于渲染UI部分的总顶点数。</li>
<li><strong>Markers</strong>:
显示事件标记。Unity会在用户与UI交互时记录标记（例如，单击按钮或更改滑块值），然后将其绘制为图表上的垂直线和标签。</li>
</ul>
<p><strong>模块详细信息面板</strong></p>
<ul>
<li><p><strong>Object</strong>：在分析期间，应用程序使用的UI画布列表。双击某一行可突出显示匹配的对象场景。</p></li>
<li><p><strong>Self Batch Count</strong>：
Unity为画布生成了多少个批次。</p></li>
<li><p><strong>Cumulative Batch
Count</strong>：Unity为画布及其所有嵌套画布生成了多少个批次</p></li>
<li><p><strong>Self Vertex
Count</strong>：该画布正在渲染多少个顶点。</p></li>
<li><p><strong>Cumulative Vertex
Count</strong>：此画布和嵌套画布正在渲染多少个顶点</p></li>
<li><p><strong>Batch Breaking
Reason</strong>：Unity拆分批次的原因。有时Unity可能无法将对象一起进行批处理。常见原因包括：</p>
<ol type="1">
<li><strong>不与Canvas共面</strong>，批处理需要对象的矩形变换与画布共面（未旋转）。CanvasInjectionIndex
，其中存在</li>
<li><strong>CanvasInjectionIndex</strong>，
组件并强制进行新批次，例如当它在其余组件之上显示组合框的下拉列表时。</li>
<li><strong>不同的材质实例、矩形裁剪、纹理或A8TextureUsage</strong>，其中Unity只能将具有相同材质、遮罩、纹理和纹理通道等完全相同的对象进行批处理。</li>
</ol></li>
<li><p><strong>GameObject Count</strong>：此批次中有多少个
GameObject</p></li>
<li><p><strong>GameObjects</strong>：批次中的游戏对象列表。</p></li>
</ul>
<p>UGUI的绘制过程，参见<a
href="https://www.zhangwei.press/2021/08/04/Unity/UI/UGUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">UGUI源码分析</a></p>
<h4 id="物理模块2d3d">物理模块(2D/3D)</h4>
<p>物理学分析器模块显示物理系统在项目中处理的物理信息。这些信息可以帮助您诊断和解决与项目场景中的物理相关的性能问题或意外差异。</p>
<p>直接上2张图吧，这个内容比较直观，手游项目中也不重度使用物理系统，官方文档<a
href="https://docs.unity3d.com/Manual/ProfilerPhysics.html">Physics
Profiler module</a>。 <strong>3D物理模块</strong></p>
<figure>
<img src="/images/unity/optimization/physics.png" alt="物理模块" />
<figcaption aria-hidden="true">物理模块</figcaption>
</figure>
<p><strong>2D物理模块</strong></p>
<figure>
<img src="/images/unity/optimization/physics2d.png" alt="2D物理模块" />
<figcaption aria-hidden="true">2D物理模块</figcaption>
</figure>
<p>Unity的3D物理系统使用的是NVIDIA的PhysX，2D物理系统使用的是开源的Box2D。</p>
<h4 id="自定模块">自定模块</h4>
<p>Unity为我们提供了自定捕获性能的接口，并可以在Unity
Profiler窗口中进行查看，也可以根据内建的Counter和自定义的Counter创建自定Profiler模块，并且可以自定义详细面板，也为Native代码提供接口收集性能数据和监听Profiler中触发的事件。</p>
<figure>
<img src="/images/unity/optimization/Profiler_Tank_details.png"
alt="自定义模块" />
<figcaption aria-hidden="true">自定义模块</figcaption>
</figure>
<h5 id="核心概念">核心概念</h5>
<p>自定义模块中主要有三个概念：记录(Recorder)、标记(Marker)和计数器(Counter)。</p>
<ul>
<li><strong>记录(Recorder)</strong>,
记录(Recorder)是用于记录标记(Marker)或计数器(Counter)产生的测量数据。</li>
<li><strong>标记(Marker)</strong>,
在需要捕获性能的代码块中创建Marker，可以捕获代码块的执行时间，可以在Profiler的CPU模块中查看器性能参数。</li>
<li><strong>计数器(Counter)</strong>,
计数的主要用于统计每帧中次数，比如:对象创建的数量，执行的操作次数等。</li>
</ul>
<h5 id="api接口">API接口</h5>
<p>Unity性能分析API, 主要分为两个部分： - <strong>Native API</strong>，
Native
API在Unity.Profiling包中，是对C++API的直接封装。核心类是ProfilerUnsafeUtility，通过它可以直接创建标记(Marker)和计数器(Counter)，返回的是一个对象的指针IntPtr。
- <strong>C# API</strong>， C#的API是对Native
API的再次封装，方便使用，主要有两个：一个在UnityEngine.Profiling包中，另一个是个外部包Unity
Profiling Core。</p>
<p><strong>记录(Recorder)</strong></p>
<ul>
<li><strong>ProfilerRecorderHandle</strong>,
记录(Recorder)的句柄，通过此类的ProfilerRecorderHandle.GetAvailable可以获取所有可用的记录句柄，并且可以通过ProfilerRecorderHandle.GetDescription函数获取所有句柄的描述信息。</li>
<li><strong>ProfilerRecorder</strong>，
记录的原始数据，可以通过此类获取自定义标记（Marker）和计数器（Counter）的采样数据。</li>
<li><strong>ProfilerRecorderSample</strong>， 记录里存储的值。</li>
<li><strong>Recorder</strong>，和<strong>ProfilerRecorder</strong>一样，感觉是为了兼容以前的接口而保留的类。</li>
</ul>
<p><strong>标记(Marker)</strong></p>
<ul>
<li><strong>ProfilerMarker</strong>，
是封装了对标记（Marker）相关的操作，ProfilerMarker内部直接调用ProfilerUnsafeUtility.CreateMarker创建标记（Marker）,并管理返回的指针IntPtr。</li>
<li><strong>ProfilerMarker&lt;T...&gt;</strong>, 是由外部包Unity
Profiling
Core提供，与Unity内部的ProfilerMarker区别是可以在采用的时记录Meta数据，模板T就是记录的数据类型，内部也是对ProfilerUnsafeUtility的直接调用。</li>
<li><strong>CustomSampler</strong>，
和<strong>ProfilerMarker</strong>一样，功能几乎一样，感觉是为了兼容以前的接口而保留的类。</li>
</ul>
<p><strong>计数器(Counter)</strong></p>
<ul>
<li><strong>ProfilerCounter</strong>,
是一个计数器类，它将计数值，直接通过Marker的Meta数据存储</li>
<li><strong>ProfilerCounterValue</strong>,
此类也是一个计数器，它的不同之处在于，不依赖Marker,直接通过ProfilerUnsafeUtility.CreateCounterValue创建，并记录了数据的地址，内部直接使用*m_Value
= value，
m_Value是ProfilerUnsafeUtility.CreateCounterValue返回的地址。但是本质上还是存在Marker的Meta数据中。</li>
</ul>
<p><strong>其他类</strong></p>
<ul>
<li><strong>Profiler</strong>，此类设计的目标是表示Profiler本身的，虽然，现在基本上都用上面讨论的这些类来记录性能数据，但是此类里面记录了一些内存统计信息，可以方便我们在任何使用访问，因为Unity内部管理的着这些内存所有本身不存在统计开销。不要使用这里面的BeginSample和EndSample等，开销比上述的內开销大。也可以通过此类将性能分析器的数据以日志的方式输出到指定文件中。输出的问题可以直接通过Unity的Profiler工具打开查看和直接捕获的数据一致。</li>
</ul>
<h5 id="创建marker和counter">创建Marker和Counter</h5>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCode</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Marker</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ProfilerMarker _marker;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ProfilerMarker&lt;<span class="keyword">int</span>&gt; _markerParam;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CustomSampler _customSampler;</span><br><span class="line">  <span class="comment">// Counter</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ProfilerCounter&lt;<span class="keyword">int</span>&gt; _profilerCounter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ProfilerCounterValue&lt;<span class="keyword">int</span>&gt; _profilerCounterValue;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      _marker = <span class="keyword">new</span> ProfilerMarker(ProfilerCategory.Scripts, <span class="string">"TestMarker"</span>);</span><br><span class="line">      _markerParam = <span class="keyword">new</span> ProfilerMarker&lt;<span class="keyword">int</span>&gt;(ProfilerCategory.Scripts, <span class="string">"TestMarkerParam"</span>, <span class="string">"Param1"</span>);</span><br><span class="line">      _customSampler = CustomSampler.Create(<span class="string">"CustomMarker"</span>, <span class="literal">true</span>);</span><br><span class="line">      _profilerCounter = <span class="keyword">new</span> ProfilerCounter&lt;<span class="keyword">int</span>&gt;(ProfilerCategory.Scripts, <span class="string">"Counter"</span>, ProfilerMarkerDataUnit.Count);</span><br><span class="line">      _profilerCounterValue = <span class="keyword">new</span> ProfilerCounterValue&lt;<span class="keyword">int</span>&gt;(ProfilerCategory.Scripts, <span class="string">"CounterValue"</span>, ProfilerMarkerDataUnit.Count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      TestMarker();</span><br><span class="line">      TestCounter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">TestMarker</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;   </span><br><span class="line">      <span class="comment">// ProfilerUnsafeUtility.BeginSample(markerHandle);</span></span><br><span class="line">      <span class="comment">// using (_markerParam.Auto(50))</span></span><br><span class="line">      <span class="comment">// using (_marker.Auto("test"))</span></span><br><span class="line">      _customSampler.Begin();</span><br><span class="line">      _marker.Begin(<span class="string">"testValue"</span>);</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1400000</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              total += i;</span><br><span class="line">          &#125;    </span><br><span class="line">      &#125;</span><br><span class="line">      _marker.End();</span><br><span class="line">      _customSampler.End();</span><br><span class="line">      <span class="comment">// ProfilerUnsafeUtility.EndSample(markerHandle);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestCounter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      _profilerCounter.Sample(Time.frameCount);</span><br><span class="line">      _profilerCounterValue.Value = Time.frameCount;</span><br><span class="line">      _profilerCounterValue.Sample();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取记录recorder数据">获取记录(Recorder)数据</h5>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCode</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IntPtr markerHandle;</span><br><span class="line">  <span class="keyword">private</span> ProfilerCategory myCategory;</span><br><span class="line">  <span class="keyword">private</span> ProfilerRecorder myMarkerRecorder;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">string</span> statsText;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="comment">//枚举所有记录</span></span><br><span class="line">      EnumerateProfilerStats();</span><br><span class="line">      <span class="keyword">unsafe</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">string</span> categoryName = <span class="string">"CategoryName"</span>;</span><br><span class="line">          <span class="comment">// fixed (char* p = categoryName)</span></span><br><span class="line">          &#123;</span><br><span class="line">              myCategory = <span class="keyword">new</span> ProfilerCategory(categoryName);<span class="comment">// ProfilerUnsafeUtility.CreateCategory(p, categoryName.Length, ProfilerCategoryColor.Scripts);</span></span><br><span class="line">              markerHandle = ProfilerUnsafeUtility.CreateMarker(<span class="string">"MyMarker"</span>, myCategory, MarkerFlags.Default, <span class="number">0</span>);</span><br><span class="line">              myMarkerRecorder = ProfilerRecorder.StartNew(myCategory, <span class="string">"MyMarker"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 查看Profiler的统计信息</span></span><br><span class="line">      TestProfiler()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;   </span><br><span class="line">      <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">500</span>);</span><br><span class="line">      sb.AppendLine(<span class="string">$"MyMarker: <span class="subst">&#123;myMarkerRecorder.LastValue&#125;</span>"</span>);</span><br><span class="line">      statsText = sb.ToString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      GUI.TextArea(<span class="keyword">new</span> Rect(<span class="number">10</span>, <span class="number">30</span>, <span class="number">250</span>, <span class="number">50</span>), statsText);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Recorder</span></span><br><span class="line">  <span class="keyword">struct</span> StatInfo</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> ProfilerCategory Cat;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">      <span class="keyword">public</span> ProfilerMarkerDataUnit Unit;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 枚举Profiler记录</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">EnumerateProfilerStats</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">var</span> availableStatHandles = <span class="keyword">new</span> List&lt;ProfilerRecorderHandle&gt;();</span><br><span class="line">      ProfilerRecorderHandle.GetAvailable(availableStatHandles);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> availableStats = <span class="keyword">new</span> List&lt;StatInfo&gt;(availableStatHandles.Count);</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> h <span class="keyword">in</span> availableStatHandles)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">var</span> statDesc = ProfilerRecorderHandle.GetDescription(h);</span><br><span class="line">          <span class="keyword">var</span> statInfo = <span class="keyword">new</span> StatInfo()</span><br><span class="line">          &#123;</span><br><span class="line">              Cat = statDesc.Category,</span><br><span class="line">              Name = statDesc.Name,</span><br><span class="line">              Unit = statDesc.UnitType</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">if</span> (statInfo.Name == <span class="string">"MyMarker"</span> || (statInfo.Name ==<span class="string">"MyCounterValue"</span>))</span><br><span class="line">              Debug.LogError(<span class="string">"找到了MyMarker"</span>);</span><br><span class="line">          availableStats.Add(statInfo);</span><br><span class="line">      &#125;</span><br><span class="line">      availableStats.Sort((a, b) =&gt;</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">var</span> result = <span class="keyword">string</span>.Compare(a.Cat.ToString(), b.Cat.ToString());</span><br><span class="line">          <span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">string</span>.Compare(a.Name, b.Name);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Available stats:\n"</span>);</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> availableStats)</span><br><span class="line">      &#123;</span><br><span class="line">          sb.AppendLine(<span class="string">$"<span class="subst">&#123;(<span class="keyword">int</span>)s.Cat&#125;</span>\t\t - <span class="subst">&#123;s.Name&#125;</span>\t\t - <span class="subst">&#123;s.Unit&#125;</span>"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Debug.Log(sb.ToString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查看Profiler的统计信息</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">TestProfiler</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.supported:<span class="subst">&#123;Profiler.supported&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.enabled:<span class="subst">&#123;Profiler.enabled&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.areaCount:<span class="subst">&#123;Profiler.areaCount&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.logFile:<span class="subst">&#123;Profiler.logFile&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.enableAllocationCallstacks:<span class="subst">&#123;Profiler.enableAllocationCallstacks&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.enableBinaryLog:<span class="subst">&#123;Profiler.enableBinaryLog&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.maxUsedMemory:<span class="subst">&#123;Profiler.maxUsedMemory / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.usedHeapSizeLong:<span class="subst">&#123;Profiler.usedHeapSizeLong / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetCategoriesCount:<span class="subst">&#123;Profiler.GetCategoriesCount()&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetTempAllocatorSize:<span class="subst">&#123;Profiler.GetTempAllocatorSize() / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      <span class="comment">// Debug.LogError($"Profiler.GetTempAllocatorSize:&#123;Profiler.GetTotalFragmentationInfo()&#125;");</span></span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetMonoHeapSizeLong:<span class="subst">&#123;Profiler.GetMonoHeapSizeLong() / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetMonoUsedSizeLong:<span class="subst">&#123;Profiler.GetMonoUsedSizeLong() / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetRuntimeMemorySizeLong:<span class="subst">&#123;Profiler.GetRuntimeMemorySizeLong(<span class="keyword">this</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetTotalAllocatedMemoryLong:<span class="subst">&#123;Profiler.GetTotalAllocatedMemoryLong() / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetTotalReservedMemoryLong:<span class="subst">&#123;Profiler.GetTotalReservedMemoryLong() / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetAllocatedMemoryForGraphicsDriver:<span class="subst">&#123;Profiler.GetAllocatedMemoryForGraphicsDriver() / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">      Debug.LogError(<span class="string">$"Profiler.GetTotalUnusedReservedMemoryLong:<span class="subst">&#123;Profiler.GetTotalUnusedReservedMemoryLong() / (<span class="number">1024</span>*<span class="number">1024</span>)&#125;</span>"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建自定profiler模块">创建自定Profiler模块</h5>
<p>主要有两个部分组成： 1. Profiler模块 2. 模块详细界面</p>
<p>Profiler模块,代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Profiling;</span><br><span class="line"><span class="keyword">using</span> Unity.Profiling.Editor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line">[<span class="meta">ProfilerModuleMetadata(<span class="meta-string">"Tank Effects"</span>)</span>] </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomProfilerModule</span> : <span class="title">ProfilerModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> ProfilerCounterDescriptor[] k_Counters = <span class="keyword">new</span> ProfilerCounterDescriptor[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> ProfilerCounterDescriptor(GameStats.TankTrailParticleCountName, GameStats.TanksCategory),</span><br><span class="line">        <span class="keyword">new</span> ProfilerCounterDescriptor(GameStats.ShellExplosionParticleCountName, GameStats.TanksCategory),</span><br><span class="line">        <span class="keyword">new</span> ProfilerCounterDescriptor(GameStats.TankExplosionParticleCountName, GameStats.TanksCategory),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保ProfilerCategory.Scripts和ProfilerCategory.Memory分类在此模块激活时自动激活</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] k_AutoEnabledCategoryNames = <span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        ProfilerCategory.Scripts.Name,</span><br><span class="line">        ProfilerCategory.Memory.Name</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomProfilerModule</span>(<span class="params"></span>) :</span></span><br><span class="line"><span class="function">        <span class="title">base</span>(<span class="params">k_Counters, ProfilerModuleChartType.Line, k_AutoEnabledCategoryNames</span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ProfilerModuleViewController <span class="title">CreateDetailsViewController</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomDetailsViewController(ProfilerWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块详细界面，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Profiling.Editor;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEditorInternal;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UIElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomDetailsViewController</span> : <span class="title">ProfilerModuleViewController</span></span><br><span class="line">&#123;   </span><br><span class="line">    Label m_TankTrailParticleCountLabel;</span><br><span class="line">    Label m_ShellExpCountLabel;</span><br><span class="line">    Label m_TankExpCountLabel;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomDetailsViewController</span>(<span class="params">ProfilerWindow profilerWindow</span>) : <span class="title">base</span>(<span class="params">profilerWindow</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> VisualElement <span class="title">CreateView</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> view = <span class="keyword">new</span> VisualElement();</span><br><span class="line">        m_TankTrailParticleCountLabel = <span class="keyword">new</span> Label() &#123; style = &#123; paddingTop = <span class="number">8</span>, paddingLeft = <span class="number">8</span> &#125; &#125;;</span><br><span class="line">        view.Add(m_TankTrailParticleCountLabel);</span><br><span class="line">        </span><br><span class="line">        m_ShellExpCountLabel = <span class="keyword">new</span> Label() &#123; style = &#123; paddingTop = <span class="number">8</span>, paddingLeft = <span class="number">8</span> &#125; &#125;;</span><br><span class="line">        view.Add(m_ShellExpCountLabel);</span><br><span class="line">        </span><br><span class="line">        m_TankExpCountLabel = <span class="keyword">new</span> Label() &#123; style = &#123; paddingTop = <span class="number">8</span>, paddingLeft = <span class="number">8</span> &#125; &#125;;</span><br><span class="line">        view.Add(m_TankExpCountLabel);</span><br><span class="line">        </span><br><span class="line">        ReloadData();</span><br><span class="line">        </span><br><span class="line">        ProfilerWindow.SelectedFrameIndexChanged += OnSelectedFrameIndexChanged;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposing)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ProfilerWindow.SelectedFrameIndexChanged -= OnSelectedFrameIndexChanged;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">base</span>.Dispose(disposing);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReloadData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> selectedFrameIndexInt32 = System.Convert.ToInt32(ProfilerWindow.selectedFrameIndex);</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">value</span> = ProfilerDriver.GetFormattedCounterValue(selectedFrameIndexInt32, GameStats.TanksCategory.Name, GameStats.TankTrailParticleCountName);</span><br><span class="line">        m_TankTrailParticleCountLabel.text = <span class="string">$"The value of '<span class="subst">&#123;GameStats.TankTrailParticleCountName&#125;</span>' in the selected frame is <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>."</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">value</span> = ProfilerDriver.GetFormattedCounterValue(selectedFrameIndexInt32, GameStats.TanksCategory.Name, GameStats.ShellExplosionParticleCountName);</span><br><span class="line">        m_ShellExpCountLabel.text = <span class="string">$"The value of '<span class="subst">&#123;GameStats.ShellExplosionParticleCountName&#125;</span>' in the selected frame is <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>."</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">value</span> = ProfilerDriver.GetFormattedCounterValue(selectedFrameIndexInt32, GameStats.TanksCategory.Name, GameStats.TankExplosionParticleCountName);</span><br><span class="line">        m_TankExpCountLabel.text = <span class="string">$"The value of '<span class="subst">&#123;GameStats.TankExplosionParticleCountName&#125;</span>' in the selected frame is <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnSelectedFrameIndexChanged</span>(<span class="params"><span class="keyword">long</span> selectedFrameIndex</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ReloadData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="native代码的支持">Native代码的支持</h5>
<p>Native接口可以让C/C++代码调用Profiler的接口，以及在C/C++中接受Profiler发送的事件，实例代码入下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IUnityLog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IUnityProfiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IUnityProfilerCallbacks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> FILE* s_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> UnityProfilerMarkerDesc* s_MyPluginMarker = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> IUnityProfiler* s_UnityProfiler;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> s_IsDevelopmentBuild;</span><br><span class="line"><span class="keyword">static</span> IUnityProfilerCallbacks* s_UnityProfilerCallbacks = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> IUnityLog* s_unityLogger = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerCreateMarkerCallback</span><span class="params">(<span class="keyword">const</span> UnityProfilerMarkerDesc* markerDesc, <span class="keyword">void</span>* userData)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerEventCallback</span><span class="params">(<span class="keyword">const</span> UnityProfilerMarkerDesc* markerDesc, UnityProfilerMarkerEventType eventType, <span class="keyword">unsigned</span> short eventDataCount, <span class="keyword">const</span> UnityProfilerMarkerData* eventData, <span class="keyword">void</span>* userData)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerPushMarker</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerPopMarker</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在插件加载时，Unity调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API <span class="title">UnityPluginLoad</span><span class="params">(IUnityInterfaces * unityInterfaces)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_file = fopen(<span class="string">"_output_.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span> (s_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"无法打开文件\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送到Unity</span></span><br><span class="line">    s_unityLogger = unityInterfaces-&gt;Get&lt;IUnityLog&gt;();</span><br><span class="line">    s_UnityProfiler = unityInterfaces-&gt;Get&lt;IUnityProfiler&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s_UnityProfiler == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    s_IsDevelopmentBuild = s_UnityProfiler-&gt;IsAvailable() != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unity发送过来</span></span><br><span class="line">    s_UnityProfilerCallbacks = unityInterfaces-&gt;Get&lt;IUnityProfilerCallbacks&gt;();</span><br><span class="line">    s_UnityProfilerCallbacks-&gt;RegisterCreateMarkerCallback(&amp;MyProfilerCreateMarkerCallback, <span class="literal">NULL</span>);</span><br><span class="line">    s_UnityProfiler-&gt;CreateMarker(&amp;s_MyPluginMarker, <span class="string">"NativeCallUnity"</span>, kUnityProfilerCategoryOther, kUnityProfilerMarkerFlagDefault, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在插件卸载时，Unity调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API <span class="title">UnityPluginUnload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_file != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(s_file);</span><br><span class="line">        s_file = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s_unityLogger = <span class="literal">nullptr</span>;</span><br><span class="line">    s_UnityProfiler = <span class="literal">nullptr</span>;</span><br><span class="line">    s_UnityProfilerCallbacks-&gt;UnregisterCreateMarkerCallback(&amp;MyProfilerCreateMarkerCallback, <span class="literal">NULL</span>);</span><br><span class="line">    s_UnityProfilerCallbacks-&gt;UnregisterMarkerEventCallback(<span class="literal">NULL</span>, &amp;MyProfilerEventCallback, <span class="literal">NULL</span>);</span><br><span class="line">    s_UnityProfilerCallbacks = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Unity</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">UINT64 UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API <span class="title">NativeCallUnity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_IsDevelopmentBuild)</span><br><span class="line">        s_UnityProfiler-&gt;BeginSample(s_MyPluginMarker);</span><br><span class="line"></span><br><span class="line">    UINT64 sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s_IsDevelopmentBuild)</span><br><span class="line">        s_UnityProfiler-&gt;EndSample(s_MyPluginMarker);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unity Profiler发送到Native的事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerEventCallback</span><span class="params">(<span class="keyword">const</span> UnityProfilerMarkerDesc* markerDesc, UnityProfilerMarkerEventType eventType, <span class="keyword">unsigned</span> short eventDataCount, <span class="keyword">const</span> UnityProfilerMarkerData* eventData, <span class="keyword">void</span>* userData)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (eventType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> kUnityProfilerMarkerEventTypeBegin:</span><br><span class="line">        &#123;</span><br><span class="line">            MyProfilerPushMarker(markerDesc-&gt;name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kUnityProfilerMarkerEventTypeEnd:</span><br><span class="line">        &#123;</span><br><span class="line">            MyProfilerPopMarker(markerDesc-&gt;name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerCreateMarkerCallback</span><span class="params">(<span class="keyword">const</span> UnityProfilerMarkerDesc* markerDesc, <span class="keyword">void</span>* userData)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    s_UnityProfilerCallbacks-&gt;RegisterMarkerEventCallback(markerDesc, &amp;MyProfilerEventCallback, <span class="literal">NULL</span>);</span><br><span class="line">    UNITY_LOG_ERROR(s_unityLogger, markerDesc-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerPushMarker</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本地记录Marker采样开始(调用Log会死递归)</span></span><br><span class="line">    <span class="comment">//UNITY_LOG_ERROR(s_unityLogger,  "==============MyProfilerPushMarker");</span></span><br><span class="line">    <span class="built_in">fprintf</span>(s_file, <span class="string">"Push Name:%s \n"</span>, name);</span><br><span class="line">    fflush(s_file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> UNITY_INTERFACE_API <span class="title">MyProfilerPopMarker</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本地记录Marker采样结束</span></span><br><span class="line">    <span class="comment">//UNITY_LOG_ERROR(s_unityLogger, "==============MyProfilerPopMarker");</span></span><br><span class="line">    <span class="built_in">fprintf</span>(s_file, <span class="string">"Pop Name:%s \n"</span>, name);</span><br><span class="line">    fflush(s_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lua-profiler">Lua Profiler</h3>
<p>Lua
Profiler是一个开源的Lua性能分析工具，提供了CPU和内存情况的统计和分析。</p>
<p>LuaProfiler捕获性能数据的基本原理是在Lua函数中插入采样代码，通过Hook技术截获luaL_loadbuffer函数，在加载出来的lua代码中调用InsertSample函数插入采样代码，核心代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span> LOCAL_PROFILER =</span><br><span class="line">    <span class="string">"local BeginMikuSample = require('MikuLuaProfiler').LuaProfiler.BeginSample "</span></span><br><span class="line">    + <span class="string">"local EndMikuSample = require('MikuLuaProfiler').LuaProfiler.EndSample "</span> + <span class="string">"local miku_unpack_return_value = require('miku_unpack_return_value') local MikuMainChunkFun = function(...) "</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">region</span> parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">InsertSample</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">value</span>, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LLex l = <span class="keyword">new</span> LLex(<span class="keyword">new</span> StringLoadInfo(<span class="keyword">value</span>), name);</span><br><span class="line">    <span class="keyword">string</span> sampleStr = <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;BeginMikuSample(\"[lua]:require &#123;1&#125;,&#123;1&#125;&amp;line:1\")"</span>, LOCAL_PROFILER, name);</span><br><span class="line">    l.InsertString(<span class="number">0</span>, sampleStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nextPos = l.pos;</span><br><span class="line">    l.Next();</span><br><span class="line">    <span class="keyword">int</span> tokenType = l.Token.TokenType;</span><br><span class="line"></span><br><span class="line">    lastPos = nextPos;</span><br><span class="line">    nextPos = l.pos;</span><br><span class="line"></span><br><span class="line">    InsertSample(l, <span class="keyword">ref</span> lastPos, <span class="keyword">ref</span> nextPos, tokenType, <span class="literal">false</span>);</span><br><span class="line">    l.InsertString(l.Length, <span class="string">"\n end return MikuMainChunkFun(...)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l.code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的操作对于使用者来说时透明的，在开始记录数据时，正常运行游戏就可以在函数中插入采用代码了。有时我们也需要查看某个函数中特定部分代码的性能数据，可以通过如下代码插入自定义的采样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LuaProfiler = MikuLuaProfiler.LuaProfiler</span><br><span class="line">LuaProfiler.BeginSampleCustom(<span class="string">"profiler name"</span>)</span><br><span class="line"><span class="comment">-- your code</span></span><br><span class="line">LuaProfiler.EndSampleCustom()</span><br></pre></td></tr></table></figure>
<h3 id="snapdragon-profiler">Snapdragon Profiler</h3>
<p>Snapdragon
Profiler是高通官方开发的性能分析工具，它可以帮助我们分析CPU, GPU, DSP,
内存, 电量, 热量和网络数据，以便我们可以查找并修复性能瓶颈。Snapdragon
Profiler主要有四种数据捕获模式：</p>
<ul>
<li><strong>实时(Realtime)</strong>,
实时视图可以轻松地在时间线上关联系统资源使用情况。提供了22个类别的150多种不同的硬件性能计数器。</li>
<li><strong>踪迹捕获(Trace Capture)</strong>,
跟踪捕获模式允许您在时间线上可视化内核和系统事件，以分析 CPU、GPU 和 DSP
中的低级系统事件。查看 CPU 调度和 GPU
阶段数据，以了解您的应用程序将时间花在何处。</li>
<li><strong>快照捕捉(Snapshot Capture)</strong>,
快照捕获模式允许您从OpenGL
ES或Vulkan应用程序捕获和调试渲染的帧。可以查看和编辑shader并实时在设备上预览，查看和调试像素历史记录。<strong>如果不能看到Shader，需要清理一下App的缓存，下载资源不用清</strong></li>
<li><strong>采样捕获(Sampling Capture)</strong>,
采样捕获模式允许您记录应用程序的调用栈图以分析消耗的CPU时间。调用栈图以火焰图的形式可视化。此模式必须要配置NDK13及以上，在AndroidManifest.xml中android:debuggable必须为true(Root除外)</li>
</ul>
<p>基本的操作和面板说明，可以看Snapdragon Profiler手册。</p>
<p><strong>Snapdragon
Profiler不仅可以用来分析性能，也可以捕捉其他游戏的帧，根据帧的绘制情况可以很容易分析出其设计，包括Shader源码都可以获取到</strong></p>
<p><strong>参数说明：</strong></p>
<ol type="1">
<li><strong>CPU Core Load</strong>，
是指CPU每个核心的工作负载或使用情况的百分比。CPU是多核心处理器，通常一个CPU会包含多个核心，每个核心可以独立执行指令和处理任务。CPU
Core Load代表了每个核心在特定时间内执行工作的强度。</li>
<li><strong>CPU Core Frequency</strong>， CPU Core Frequency（CPU
核心频率）是指CPU每个核心在每秒钟内执行指令的速度，通常以GHz（千兆赫兹）或
MHz（兆赫兹）为单位。核心频率越高，处理指令的速度就越快。</li>
<li><strong>CPU Core Utilization</strong>， CPU Core Utilization（CPU
核心利用率）是指每个CPU核心在特定时间段内被实际使用的百分比，表示该核心的繁忙程度。它反映了系统的任务在某个核心上执行的效率，以及该核心处理资源的利用率。与“Core
Load”相比“Core
Load”更侧重于当前任务对核心的实际占用，而“Utilization”一般指的是一段时间内的平均使用率。</li>
<li><strong>GPU Bus Busy</strong>， GPU Bus Busy 是指
GPU（图形处理单元）与其他组件（如 CPU
和内存）之间的数据总线的繁忙程度，通常以百分比表示。这一指标反映了 GPU
数据总线在特定时间内用于数据传输的活跃程度。</li>
<li><strong>Avg bytes/Fragment（平均每个片段的字节数）</strong>，
是一个性能指标，用于衡量在图形渲染等上下文中，传输的每个数据片段的平均字节大小。</li>
<li><strong>Avg Bytes/Vertex（每个顶点的平均字节数）</strong>，
是GPU内存统计中的一个重要指标，用于衡量在图形渲染过程中，每个顶点的数据大小。这一指标通常应用于3D图形处理，特别是在处理顶点缓冲区时。</li>
<li><strong>Avg Frame Time（平均帧时间）</strong>，
表示在特定时间段内，生成和显示一帧图像所需的平均时间，通常以毫秒（ms）为单位表示。</li>
<li><strong>Clocks/Second（每秒钟时钟周期数）</strong>，
是一个用于描述GPU性能的重要指标。它表示GPU在一秒钟内可以执行的时钟周期数，通常以赫兹（Hz）为单位表示。</li>
<li><strong>Read Total (Bytes/sec)</strong>， 用于衡量 GPU
从内存中读取数据的总速率，单位为字节每秒（Bytes/sec）。这个指标可以帮助评估
GPU 的内存带宽和性能。</li>
<li><strong>SP Memory Read (Bytes/Second)</strong>，
是一个专门用于衡量GPU中的 Shader
Processor（着色器处理器）从内存中读取数据的速率的性能指标，单位为字节每秒（Bytes/sec）。这个指标反映了着色器在处理图形和计算任务时，从内存获取数据的效率。</li>
<li><strong>Texture Memory Read BW (Bytes/Second)</strong>，
是一个用于衡量GPU从纹理内存
中读取数据的带宽的性能指标，单位为字节每秒（Bytes/sec）。这个指标专门关注
GPU 在图形渲染过程中访问纹理数据的效率。</li>
<li><strong>Vertex Memory Read (Bytes/Second)</strong>， 是一个用于衡量
GPU 从 顶点内存
中读取数据的速率的性能指标，单位为字节每秒（Bytes/sec）。这个指标专注于
GPU 在处理图形渲染时访问顶点数据的效率。</li>
<li><strong>Write Total (Bytes/sec)</strong>， 是一个用于衡量 GPU
向内存写入数据的总速率的性能指标，单位为字节每秒（Bytes/sec）。这个指标反映了
GPU
在处理图形渲染或计算任务时，将数据写入内存的效率。这包括所有写入操作，比如更新纹理、缓冲区和其他资源。</li>
<li><strong>Avg Preemption Delay（平均抢占延迟）</strong>，
是一个用于衡量GPU任务被抢占后，恢复执行所需平均时间的性能指标，通常以毫秒（ms）为单位表示。这一指标对于理解
GPU 的抢占机制和性能表现至关重要。</li>
<li><strong>Preemption/Second</strong>， 是一个用于衡量 GPU
每秒发生的抢占事件数量的性能指标。这一指标有助于评估 GPU
任务调度的频率和效率。</li>
<li><strong>Prims Clipped</strong>， 是一个用于衡量 GPU
在图形渲染过程中被裁剪的图元（Primitives）数量的性能指标。图元通常指的是基本的几何体，如点、线和三角形。</li>
<li><strong>Prims Trivially Rejected</strong>， 是一个用于衡量 GPU
在图形渲染过程中被简单拒绝的图元（Primitives）数量的性能指标。这些图元在被处理之前就被识别为不需要进一步处理。简单拒绝指的是
GPU
在早期阶段判断某些图元（例如点、线、三角形）在渲染过程中不影响最终图像，因而直接拒绝这些图元，而无需进行更复杂的计算。这种拒绝通常基于图元的边界框与视口的关系。</li>
<li><strong>Average Polygon
Area</strong>，（平均多边形面积）是一个用于衡量渲染过程中所处理的多边形的平均面积的性能指标。该指标通常以像素为单位，反映了在图形渲染中，GPU
处理的多边形的大小和复杂性。</li>
<li><strong>Average
Vertices/Polygon（平均每个多边形的顶点数）</strong>，
是一个用于衡量在图形渲染过程中，每个多边形（通常是三角形或其他类型的多边形）平均包含的顶点数量的性能指标。这个指标有助于理解场景的几何复杂性和GPU处理的效率。</li>
<li><strong>Pre-clipped Polygon/Second</strong>， 是一个用于衡量 GPU
在图形渲染过程中每秒处理的预裁剪多边形（Polygons）的数量的性能指标。该指标主要反映了
GPU 在进行图元处理前，经过初步裁剪的多边形数量，通常用于评估 GPU
的处理能力和渲染效率。预裁剪是指在多边形进入完整的渲染管线之前，GPU
对其进行初步的裁剪。这通常基于多边形与视口（viewport）或其他裁剪区域的关系，以确定哪些多边形是可见的，哪些是可以被丢弃的。</li>
<li><strong>Reused Vertices/Second</strong>，是一个用于衡量 GPU
在图形渲染过程中每秒重新使用的顶点（Vertices）数量的性能指标。该指标反映了
GPU
在处理图元（如三角形、线段等）时，能够重复利用已存在顶点的效率。</li>
<li><strong>Anisotropic
Filtered</strong>，是一个用于衡量在图形渲染过程中，应用各向异性过滤的纹理像素（Texels）数量的性能指标。该指标通常用于评估
GPU 在处理纹理时的效果，尤其是在处理倾斜表面时的图像质量。</li>
<li><strong>Non-Base Level Textures</strong>，
是一个用于衡量在图形渲染过程中，使用的非基础级别(非一层)纹理数量的性能指标。这个指标主要反映了
GPU 在处理纹理时，涉及的不同层级的纹理数据。</li>
<li><strong>Shader ALU Capacity Utilized</strong>， 是一个用于衡量 GPU
在图形渲染过程中，着色器算术逻辑单元（ALU）的利用率的性能指标。这个指标反映了
GPU
在执行着色器程序时，算术逻辑单元的实际使用情况与其最大处理能力之间的比率。</li>
<li><strong>Shader Busy</strong>， 是一个用于衡量 GPU
在图形渲染过程中，着色器处于忙碌状态的时间占总时间的比例的性能指标。这个指标反映了
GPU 着色器执行任务的效率和资源利用情况。</li>
<li><strong>Shader Stalled</strong>， 是一个用于衡量 GPU
着色器在执行过程中因各种原因而处于等待或阻塞状态的时间比例的性能指标。这个指标反映了
GPU 着色器执行效率的下降及其可能受到的限制。</li>
<li><strong>Texture Pipes Busy</strong>， Texture Pipes Busy
是一个用于衡量 GPU 纹理处理管道（Texture
Pipes）在图形渲染过程中忙碌状态的时间占总时间比例的性能指标。这个指标反映了
GPU 在处理纹理采样和纹理过滤操作时的效率和利用情况。</li>
<li><strong>Time ALUs Working</strong>， 是一个用于衡量 GPU
着色器中的算术逻辑单元（ALUs）实际执行计算任务的时间的性能指标。该指标反映了
GPU 在图形渲染过程中 ALU 的利用效率。</li>
<li><strong>Time Compute</strong>， 是一个用于衡量 GPU
在图形渲染过程中用于计算操作的总时间的性能指标。这个指标反映了 GPU
执行着色器计算任务的时间开销，尤其是在处理复杂的计算着色器（Compute
Shaders）时。</li>
<li><strong>Time EFUs Working</strong>， 是一个用于衡量 GPU
中的执行功能单元（Execution Functional Units,
EFUs）实际用于执行计算任务的时间的性能指标。该指标反映了 GPU
在处理着色器程序时，EFUs 的利用效率。EFUs 是 GPU
中专门用于执行各种类型运算的单元，包括整数运算、浮点运算和其他特定功能的计算。EFUs
可以被视为 ALUs 的更广泛类别，负责处理着色器中的各种计算任务。</li>
<li><strong>Time Shading Fragments</strong>， 是一个用于衡量 GPU
在处理和渲染片段（Fragment）时所花费的总时间的性能指标。这个指标主要反映了
GPU 在片段着色阶段的计算效率和性能。</li>
<li><strong>Time Shading Vertices</strong>， 是一个用于衡量 GPU
在处理和渲染顶点（Vertex）时所花费的总时间的性能指标。这个指标主要反映了
GPU 在顶点着色阶段的计算效率和性能。</li>
<li><strong>Wave Context Occupancy</strong>， 是一个用于衡量 GPU
在执行着色器程序时，波前（Wavefront 或
Warp）上下文占用的效率指标。该指标反映了 GPU
在处理并发执行的着色器线程时，资源的利用情况和计算效率。</li>
</ol>
<ul>
<li><strong>波前（Wavefront/Warp）</strong>：在现代 GPU
中，计算通常是以波前或 Warp 的形式进行的。一个波前包含多个线程（通常是
32 个或 64
个），这些线程同时执行相同的指令，但可以在不同的数据上操作。波前的并行处理能够提高计算效率。</li>
<li><strong>上下文占用：Wave Context Occupancy</strong>
指的是在某一时间段内，实际活动的波前线程数量与理论上可以支持的最大线程数量的比率。这个值通常以百分比表示，反映了
GPU 在执行着色器时的并行利用程度。</li>
</ul>
<ol start="34" type="1">
<li><strong>ALU/Fragment</strong>，
是一个用于衡量每个片段（Fragment）处理所需的算术逻辑单元（ALUs）操作数量的性能指标。这个指标反映了在片段着色阶段中计算的复杂性和资源的利用程度。</li>
<li><strong>Fragment ALU Instructions/Sec</strong>， 是一个用于衡量 GPU
每秒钟处理的片段着色器中的算术逻辑单元（ALU）指令数量的性能指标。这个指标反映了
GPU 在片段着色阶段的计算性能和吞吐量。</li>
<li><strong>Fragments Shaded</strong>， 是一个用于衡量 GPU
在特定时间段内处理和着色的片段（Fragment）数量的性能指标。这个指标反映了
GPU 在片段着色阶段的工作负载和效率。</li>
<li><strong>Textures/Fragment</strong>，
是一个用于衡量在片段着色过程中，每个片段所涉及的纹理样本（Texture
Samples）数量的性能指标。这个指标反映了片段着色器在处理图形时对纹理的访问频率和复杂性。</li>
<li><strong>Textures/Vertex</strong>，
是一个用于衡量在顶点着色过程中，每个顶点所涉及的纹理样本（Texture
Samples）数量的性能指标。这个指标反映了顶点着色器在处理图形时对纹理的访问频率和复杂性。</li>
<li><strong>Vertex Instructions/Second</strong>， 是一个用于衡量 GPU
每秒钟处理的顶点着色器中的指令数量的性能指标。这个指标反映了 GPU
在顶点处理阶段的计算性能和吞吐量。</li>
<li><strong>Vertices Shaded/Second</strong>， 是一个用于衡量 GPU
每秒钟处理和着色的顶点（Vertices）数量的性能指标。这个指标反映了 GPU
在顶点着色阶段的工作负载和效率。</li>
<li><strong>Instruction Cache Miss</strong>， 是一个用于衡量 GPU
在执行指令时缓存未命中（Cache
Miss）的次数的性能指标。这一指标反映了指令缓存的效率，以及对 GPU
性能的潜在影响。</li>
<li><strong>Stalled on System Memory</strong>， 是一个用于衡量 GPU
在执行过程中由于访问系统内存而导致的停顿（Stall）次数或持续时间的性能指标。这一指标反映了
GPU 访问系统内存时的延迟和瓶颈程度。</li>
<li><strong>Texture Fetch Stall</strong>， 是一个用于衡量 GPU
在进行纹理获取（Texture
Fetch）时由于等待纹理数据而导致的停顿（Stall）次数或持续时间的性能指标。这一指标反映了纹理访问过程中的延迟和可能的瓶颈。</li>
<li><strong>Texture L1 Miss</strong>， 是一个用于衡量 GPU
在访问一级纹理缓存（L1
Cache）时未命中的次数的性能指标。这个指标反映了纹理访问过程中的缓存效率，以及可能对
GPU 性能造成的影响。</li>
<li><strong>Vertex Fetch Stall</strong>， 是一个用于衡量 GPU
在进行顶点获取（Vertex
Fetch）时由于等待顶点数据而导致的停顿（Stall）次数或持续时间的性能指标。这一指标反映了顶点访问过程中的延迟和潜在的瓶颈。</li>
<li><strong>L1 Texture Cache Miss Per Pixel</strong>，
是一个用于衡量每个像素的 L1
纹理缓存未命中（Miss）次数。这一指标反映了在图形渲染过程中，GPU
在处理每个像素时从 L1 纹理缓存未命中的情况，进而影响渲染效率。</li>
<li><strong>Rx Bytes (TCP)</strong>， 是一个用于衡量通过 TCP
协议接收的字节数的性能指标。这个指标反映了系统在一段时间内通过网络接收的
TCP 数据量。Rx: Receive（接收）</li>
<li><strong>Tx Bytes (TCP)</strong>， 是一个用于衡量通过 TCP
协议发送的字节数的性能指标。这个指标反映了系统在一段时间内通过网络发送的
TCP 数据量。Tx: Transmit（发送）</li>
</ol>
<h3 id="xcode-instruments">Xcode Instruments</h3>
<p>Xcode Instruments
是一个功能强大的性能分析和调试工具，广泛用于iOS和macOS应用的开发过程。它提供多种工具来帮助开发者分析应用的性能、内存占用、能源使用等。Instruments主要有以下几个模块：</p>
<ol type="1">
<li><strong>Time Profiler</strong></li>
</ol>
<ul>
<li>功能：分析代码的执行时间，定位性能瓶颈。</li>
<li>主要参数：
<ul>
<li>CPU Usage: 显示 CPU 的使用情况。</li>
<li>Call Tree: 展示方法调用的层级结构。</li>
<li>Self (%): 每个方法自身消耗的 CPU 时间百分比。</li>
<li>Total (%): 包括调用链中所有方法消耗的总时间百分比。</li>
<li>Hide System Libraries: 隐藏系统方法，仅显示用户代码。</li>
</ul></li>
<li>Sampling Interval: 设置采样间隔时间，默认值通常为 1ms。</li>
</ul>
<ol start="2" type="1">
<li><strong>Allocations</strong></li>
</ol>
<ul>
<li>功能：跟踪内存分配，帮助发现内存泄漏和高内存消耗。</li>
<li>主要参数：
<ul>
<li>Persistent Bytes: 持久占用的内存字节数。</li>
<li>Transient Bytes: 瞬时分配的内存字节数。</li>
<li>Heap Growth: 堆内存增长趋势。</li>
<li>Address: 内存分配的地址。</li>
<li>Category: 内存分配的类型（如堆分配、栈分配等）。</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><strong>Leaks</strong></li>
</ol>
<ul>
<li>功能：检测内存泄漏，定位泄漏的对象。</li>
<li>主要参数：
<ul>
<li>Leaked Bytes: 泄漏的内存字节数。</li>
<li>Responsible Frame: 泄漏对象的调用栈。</li>
<li>Process: 泄漏发生的进程。</li>
</ul></li>
</ul>
<ol start="4" type="1">
<li><strong>Energy Log</strong></li>
</ol>
<ul>
<li>功能：分析应用的能源使用情况，优化电量消耗。</li>
<li>主要参数：
<ul>
<li>Energy Impact: 显示应用的能源影响得分（数值越高越耗电）。</li>
<li>CPU Activity: 处理器活动状态。</li>
<li>Network Activity: 网络使用情况。</li>
<li>Disk I/O: 磁盘读写操作。</li>
</ul></li>
</ul>
<ol start="5" type="1">
<li><strong>Core Animation</strong></li>
</ol>
<ul>
<li>功能：分析界面渲染性能，优化动画效果。</li>
<li>主要参数：
<ul>
<li>FPS (Frames Per Second): 显示当前帧率，理想值为 60 FPS。</li>
<li>Animation Jank: 记录动画的卡顿次数。</li>
<li>Render Server: 图形渲染服务的资源消耗。</li>
</ul></li>
</ul>
<ol start="6" type="1">
<li><strong>System Trace</strong></li>
</ol>
<ul>
<li>功能：全系统级别的性能分析，包括
CPU、GPU、内存和线程的使用情况。</li>
<li>主要参数：
<ul>
<li>Thread State: 每个线程的状态（如运行中、等待中）。</li>
<li>CPU Load: 显示每个核的负载情况。</li>
<li>System Calls: 系统调用的次数和耗时。</li>
</ul></li>
</ul>
<ol start="7" type="1">
<li><strong>Network</strong></li>
</ol>
<ul>
<li>功能：分析网络请求和响应，优化网络使用。</li>
<li>主要参数：
<ul>
<li>Request Duration: 网络请求的持续时间。</li>
<li>Response Size: 响应的数据大小。</li>
<li>Domain: 请求的域名。</li>
<li>Protocol: 网络协议（如 HTTP、HTTPS）。</li>
</ul></li>
</ul>
<ol start="8" type="1">
<li><strong>Disk I/O</strong></li>
</ol>
<ul>
<li>功能：分析磁盘读写性能，定位高频读写操作。</li>
<li>主要参数：
<ul>
<li>Read/Write Operations: 读写操作的数量。</li>
<li>Bytes Read/Written: 读写的数据字节数。</li>
<li>File Path: 文件路径。</li>
</ul></li>
</ul>
<ol start="9" type="1">
<li><strong>Threads</strong></li>
</ol>
<ul>
<li>功能：分析线程的活动，优化多线程使用。</li>
<li>主要参数：
<ul>
<li>Active Threads: 活跃线程的数量。</li>
<li>Blocked Threads: 阻塞线程的数量。</li>
<li>Thread Name: 线程的名称。</li>
<li>Context Switches: 线程上下文切换的次数。</li>
</ul></li>
</ul>
<ol start="10" type="1">
<li><strong>Metal System Trace</strong></li>
</ol>
<ul>
<li>功能
<ul>
<li>分析 Metal API 的调用链及执行效率。</li>
<li>监控 GPU 和 CPU 在渲染管道中的任务分配。</li>
<li>优化命令缓冲区（Command Buffer）及绘制调用（Draw Calls）。</li>
</ul></li>
<li>主要参数
<ol type="1">
<li>Command Buffers</li>
</ol>
<ul>
<li>显示每个命令缓冲区的执行时间和内容。</li>
<li>Start/End Time：缓冲区的执行起止时间。</li>
<li>Execution Time：缓冲区执行所用的时间。</li>
<li>Command Encoder：命令编码器的类型（如渲染、计算、拷贝）。</li>
</ul>
<ol start="2" type="1">
<li>GPU Activity</li>
</ol>
<ul>
<li>Active Time：GPU 执行命令的活跃时间。</li>
<li>Idle Time：GPU 空闲时间，用于识别是否存在 GPU 瓶颈。</li>
</ul>
<ol start="3" type="1">
<li>Draw Calls</li>
</ol>
<ul>
<li>每帧的绘制调用次数。</li>
<li>绘制调用越多，GPU 处理负担越重，需尽量减少。</li>
</ul>
<ol start="4" type="1">
<li>Shader Execution</li>
</ol>
<ul>
<li>Vertex Shader Time：顶点着色器的执行时间。</li>
<li>Fragment Shader Time：片段着色器的执行时间。</li>
<li>Compute Shader Time：计算着色器的执行时间。</li>
</ul>
<ol start="5" type="1">
<li>Resource Usage</li>
</ol>
<ul>
<li>Texture Bindings：绑定到渲染管道的纹理数量。</li>
<li>Buffer Uploads：上传到 GPU 的缓冲区大小。</li>
<li>Heap Allocation：Metal 堆内存分配情况。</li>
</ul></li>
<li>优化建议
<ul>
<li>合并绘制调用（Batching），减少 Draw Calls 的次数。</li>
<li>使用压缩纹理格式（如 ASTC）优化 GPU 内存和带宽。</li>
<li>优化着色器代码，避免复杂的动态分支（如 if 和 for）。</li>
<li>减少命令缓冲区的频繁切换。</li>
</ul></li>
</ul>
<ol start="11" type="1">
<li><strong>GPU Driver</strong></li>
</ol>
<ul>
<li>功能
<ul>
<li>分析 GPU 渲染任务的耗时。</li>
<li>检测 Metal 应用的 GPU 瓶颈，如高频的纹理切换或缓冲区更新。</li>
<li>识别帧延迟（Frame Latency）问题。</li>
</ul></li>
<li>主要参数
<ol type="1">
<li>Frame Latency</li>
</ol>
<ul>
<li>每一帧从命令提交到 GPU 渲染完成的延迟时间。</li>
<li>较高的延迟可能表示资源竞争或命令缓冲区堵塞。</li>
</ul>
<ol start="2" type="1">
<li>GPU Load</li>
</ol>
<ul>
<li>GPU 的利用率，用于识别是否存在过载。</li>
<li>如果 GPU 长时间负载接近 100%，需优化渲染任务。</li>
</ul>
<ol start="3" type="1">
<li>Fragment Processing Time</li>
</ol>
<ul>
<li>片段着色器的处理时间，用于分析像素级渲染任务。</li>
</ul>
<ol start="4" type="1">
<li>Vertex Processing Time</li>
</ol>
<ul>
<li>顶点着色器的处理时间，通常用于分析模型的复杂性。</li>
</ul>
<ol start="5" type="1">
<li>Resource Binding</li>
</ol>
<ul>
<li>Texture Binding Count：绑定的纹理数量。</li>
<li>Buffer Binding Count：绑定的缓冲区数量。</li>
</ul></li>
<li>优化建议
<ul>
<li>控制纹理和缓冲区的动态切换频率，尽量复用资源。</li>
<li>减少复杂的几何数据，优化顶点和索引缓冲区。</li>
<li>提前上传资源到 GPU，减少渲染时的内存访问延迟。</li>
</ul></li>
</ul>
<ol start="12" type="1">
<li><strong>OpenGL ES Analyzer</strong></li>
</ol>
<ul>
<li>功能：
<ul>
<li>捕获 OpenGL API 调用并分析调用性能。</li>
<li>检测渲染管道中的瓶颈。</li>
</ul></li>
<li>主要参数：
<ul>
<li>Draw Calls: 渲染调用的次数。</li>
<li>Shader Compilation Time: 着色器编译的耗时。</li>
<li>State Changes: OpenGL 状态切换的次数。</li>
<li>Framebuffer Switches: 帧缓冲区切换的次数。</li>
</ul></li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a
href="https://github.com/hitdn110/docs/tree/master">电脑110</a></li>
<li><a
href="https://dlcdnets.asus.com/pub/ASUS/mb/LGA1700/TUF_GAMING_B760M-PLUS_WIFI_D4/C21295_TUF_GAMING_B760M-PLUS_WIFI_D4_UM_12P_WEB.pdf?model=tuf%20gaming%20b760m-plus%20wifi%20d4">华硕B760主板说明书</a></li>
<li><a
href="https://diy.zol.com.cn/830/8301698.html">主板北桥芯片为何消失了？南桥消失了也不奇怪</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/108469658">【从零开始：现代PC】第三章：主板</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/684562857">浅谈智能手机硬件原理与常识一：性能篇</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/353619898">手机硬件科普</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/511106919">10分钟掌握手机配置知识（纯干货）</a></li>
<li><a href="https://www.youtube.com/watch?v=kNjjPU-OErE" target="_blank" rel="noopener">小米14
Pro拆解</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/419093227">掌中核心——手机SOC基础知识科普</a></li>
<li><a
href="https://www.qualcomm.com/products/mobile/snapdragon/smartphones/snapdragon-8-series-mobile-platforms/snapdragon-8-gen-3-mobile-platform">Snapdragon
8 Gen 3 Mobile Platform</a></li>
<li><a
href="https://www.zhihu.com/question/563144459">如何看待ARM将要求使用ARM
CPU后必须绑捆使用其它ARM产品（GPU、NPU、ISP等）？</a></li>
<li><a
href="https://blog.csdn.net/qq_42008430/article/details/128117499">人们常说的ARM究竟是什么意思？</a></li>
<li><a
href="https://blog.51cto.com/u_16099251/6737147">手机Gpu参数和架构
手机gpu型号排名</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1949326" target="_blank" rel="noopener">嵌入式
NPU 发展概况</a></li>
<li><a
href="https://blog.csdn.net/feelabclihu/article/details/133956571">手机主流存储器件的分析与发展</a></li>
<li><a
href="https://blog.unity.com/cn/games/tackling-profiling-for-mobile-games-with-unity-and-arm">了解如何使用
Unity 和 Arm 分析工具解决移动端游戏性能问题</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/505663168">【技术精讲】游戏CPU性能分析及工具</a></li>
<li><a
href="https://testsigma.com/blog/mobile-app-performance-testing/">Mobile
App Performance Testing: Tools and Checklist</a></li>
<li><a
href="https://armv8-doc.readthedocs.io/en/latest/index.html">Armv8/armv9架构入门指南</a></li>
<li><a
href="https://developer.arm.com/documentation/dui0473/m?lang=en">ARM
Compiler armasm User Guide</a></li>
<li><a href="https://developer.arm.com/documentation/101897/0302" target="_blank" rel="noopener">Arm
GPU Best Practices Developer Guide</a></li>
<li><a href="https://tomcl.github.io/visual2.github.io/guide.html" target="_blank" rel="noopener">ARM
UAL Guide</a></li>
<li><a href="https://www.ti.com/lit/ug/spnu118u/spnu118u.pdf" target="_blank" rel="noopener">ARM
Assembly Language Tools</a></li>
<li><a
href="https://personal.utdallas.edu/~pervin/RPiA/RPiA.pdf">RASPBERRY PI
ASSEMBLER</a></li>
<li><a
href="https://refspecs.linuxfoundation.org/elf/gabi4+/contents.html">System
V Application Binary Interface - DRAFT - 24 April 2001</a></li>
<li><a href="https://developer.android.com/ndk/guides?hl=zh-cn" target="_blank" rel="noopener">NDK
使用入门</a></li>
<li><a href="https://llvm.org/docs/GettingStarted.html" target="_blank" rel="noopener">Getting Started
with the LLVM System</a></li>
<li><a
href="https://www.51cto.com/article/630677.html">详解三大编译器：gcc、llvm
和 clang</a></li>
<li><a
href="http://m.blog.itpub.net/70024923/viewspace-2951103/">人人都应该知道的CPU缓存运行效率</a></li>
<li><a href="https://juejin.cn/post/7024319941289607175" target="_blank" rel="noopener">ARM
版的Clang的使用</a></li>
<li><a
href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">Linux
内核源码</a></li>
<li><a
href="https://chuquan.me/2018/05/21/elf-introduce/">计算机那些事(4)——ELF文件结构</a></li>
<li><a
href="https://docs.unity3d.com/2022.3/Documentation/Manual/analysis.html">Unity
Manual - Analysis</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E4%BC%98%E5%8C%96/" rel="tag"><i class="fa fa-tag"></i> 优化</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2024/04/21/Unity/Graphics/%E6%B8%B8%E6%88%8F%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C/" rel="next" title="游戏后处理效果">
                  <i class="fa fa-chevron-left"></i> 游戏后处理效果
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2024/10/26/Unity/Optimization/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-CPU/" rel="prev" title="性能优化-CPU">
                  性能优化-CPU <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#组成原理"><span class="nav-number">1.</span> <span class="nav-text">组成原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pc"><span class="nav-number">1.1.</span> <span class="nav-text">PC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主板-motherboard"><span class="nav-number">1.1.1.</span> <span class="nav-text">主板 (Motherboard)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bios"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">BIOS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">总线</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#协议"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接口"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#芯片组"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">芯片组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中央处理器-cpu"><span class="nav-number">1.1.2.</span> <span class="nav-text">中央处理器 (CPU)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存-ram"><span class="nav-number">1.1.3.</span> <span class="nav-text">内存 (RAM)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图形处理器-gpu"><span class="nav-number">1.1.4.</span> <span class="nav-text">图形处理器 (GPU)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储设备-storage"><span class="nav-number">1.1.5.</span> <span class="nav-text">存储设备 (Storage)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手机"><span class="nav-number">1.2.</span> <span class="nav-text">手机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arm结构"><span class="nav-number">1.2.1.</span> <span class="nav-text">ARM结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#soc"><span class="nav-number">1.2.2.</span> <span class="nav-text">SOC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高通骁龙snapdragon"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">高通骁龙（Snapdragon）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#苹果a系列"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">苹果A系列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#海思麒麟hisilicon-kirin"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">海思麒麟（HiSilicon Kirin）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联发科天玑mediatek-dimensity"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">联发科天玑（MediaTek
Dimensity）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三星exynos艾克西诺斯"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">三星Exynos（艾克西诺斯）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图像处理器gpu"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">图像处理器（GPU）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌入式神经网络处理器npu"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">嵌入式神经网络处理器（NPU）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是-npu"><span class="nav-number">1.2.2.7.1.</span> <span class="nav-text">什么是 NPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#npu的诞生"><span class="nav-number">1.2.2.7.2.</span> <span class="nav-text">NPU的诞生</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#npu-的功能"><span class="nav-number">1.2.2.7.3.</span> <span class="nav-text">NPU 的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#npu-的应用"><span class="nav-number">1.2.2.7.4.</span> <span class="nav-text">NPU 的应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存memory"><span class="nav-number">1.2.3.</span> <span class="nav-text">内存(Memory)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闪存flash"><span class="nav-number">1.2.4.</span> <span class="nav-text">闪存(Flash)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ufs简介"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">UFS简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nvme简介"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">NVMe简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ufs与nvme比较"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">UFS与NVMe比较</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#helloworld的执行过程"><span class="nav-number">2.</span> <span class="nav-text">HelloWorld的执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序的生成"><span class="nav-number">2.1.</span> <span class="nav-text">程序的生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主流cc编译工具集"><span class="nav-number">2.1.1.</span> <span class="nav-text">主流C&#x2F;C++编译工具集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gcc-gnu-compiler-collection"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">GCC (GNU Compiler Collection)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clangllvm"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">Clang&#x2F;LLVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#msvc-microsoft-visual-c"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">MSVC (Microsoft Visual C++)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码"><span class="nav-number">2.1.2.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预处理"><span class="nav-number">2.1.3.</span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译"><span class="nav-number">2.1.4.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接生成最终可执行文件或库"><span class="nav-number">2.1.5.</span> <span class="nav-text">链接（生成最终可执行文件或库）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标文件可执行文件或库格式"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">目标文件，可执行文件或库格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态链接"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态链接"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">动态链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序的加载与执行"><span class="nav-number">2.2.</span> <span class="nav-text">程序的加载与执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分析工具"><span class="nav-number">3.</span> <span class="nav-text">分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件参数和访问过程"><span class="nav-number">3.1.</span> <span class="nav-text">硬件参数和访问过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闪存"><span class="nav-number">3.1.1.</span> <span class="nav-text">闪存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#闪存基本结构"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">闪存基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闪存访问过程"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">闪存访问过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闪存参数"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">闪存参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存"><span class="nav-number">3.1.2.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存结构"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">内存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存访问过程"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">内存访问过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存访问的详细步骤"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">内存访问的详细步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存参数"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">内存参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu"><span class="nav-number">3.1.3.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu的基本组成部分"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">CPU的基本组成部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu执行代码过程"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">CPU执行代码过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu参数"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">CPU参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络"><span class="nav-number">3.1.4.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络组成"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">网络组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络通信过程"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">网络通信过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络参数"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">网络参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能分析工具"><span class="nav-number">3.2.</span> <span class="nav-text">性能分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unity-profiler"><span class="nav-number">3.2.1.</span> <span class="nav-text">Unity Profiler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unity-profiler界面概述"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">Unity Profiler界面概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源模块"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">资源模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#操作系统如何处理文件"><span class="nav-number">3.2.1.2.1.</span> <span class="nav-text">操作系统如何处理文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存模块"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">内存模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#操作系统如何管理内存"><span class="nav-number">3.2.1.3.1.</span> <span class="nav-text">操作系统如何管理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#malloc和realloc实现"><span class="nav-number">3.2.1.3.1.1.</span> <span class="nav-text">malloc和realloc实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#free实现"><span class="nav-number">3.2.1.3.1.2.</span> <span class="nav-text">free实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu模块"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">CPU模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程与线程"><span class="nav-number">3.2.1.4.1.</span> <span class="nav-text">进程与线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#渲染模块"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">渲染模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ui模块"><span class="nav-number">3.2.1.6.</span> <span class="nav-text">UI模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理模块2d3d"><span class="nav-number">3.2.1.7.</span> <span class="nav-text">物理模块(2D&#x2F;3D)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定模块"><span class="nav-number">3.2.1.8.</span> <span class="nav-text">自定模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#核心概念"><span class="nav-number">3.2.1.8.1.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#api接口"><span class="nav-number">3.2.1.8.2.</span> <span class="nav-text">API接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建marker和counter"><span class="nav-number">3.2.1.8.3.</span> <span class="nav-text">创建Marker和Counter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取记录recorder数据"><span class="nav-number">3.2.1.8.4.</span> <span class="nav-text">获取记录(Recorder)数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建自定profiler模块"><span class="nav-number">3.2.1.8.5.</span> <span class="nav-text">创建自定Profiler模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#native代码的支持"><span class="nav-number">3.2.1.8.6.</span> <span class="nav-text">Native代码的支持</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lua-profiler"><span class="nav-number">3.2.2.</span> <span class="nav-text">Lua Profiler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#snapdragon-profiler"><span class="nav-number">3.2.3.</span> <span class="nav-text">Snapdragon Profiler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xcode-instruments"><span class="nav-number">3.2.4.</span> <span class="nav-text">Xcode Instruments</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张卫"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">张卫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/zw514159799" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;zw514159799" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Divad1111?tab=repositories" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Divad1111?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/qilezaitu" title="博客园 &amp;rarr; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;qilezaitu" rel="noopener" target="_blank"><i class="fa fa-fw fa-cnblogs"></i>博客园</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张卫</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">542k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:13</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

  

</body>
</html>
