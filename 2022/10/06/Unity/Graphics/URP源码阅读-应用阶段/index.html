<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="通用渲染管线（URP）是Unity官方创建的可编程渲染管线（SRP）。URP提供了艺术家友好的工作流程，能够快速且简单创建跨平台的图形，从移动端到高端控制台和PC。SRP的内容可以参见:Unity渲染管线介绍。 Unity将渲染管线的代码分为了几个包，分别如下：  com.unity.render-pipelines.core 此包包含了一些公共的可重用代码，URP和HDRP都会使用此包。 com">
<meta property="og:type" content="article">
<meta property="og:title" content="URP源码阅读-应用阶段">
<meta property="og:url" content="http://yoursite.com/2022/10/06/Unity/Graphics/URP%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5/index.html">
<meta property="og:site_name" content="张卫的博客">
<meta property="og:description" content="通用渲染管线（URP）是Unity官方创建的可编程渲染管线（SRP）。URP提供了艺术家友好的工作流程，能够快速且简单创建跨平台的图形，从移动端到高端控制台和PC。SRP的内容可以参见:Unity渲染管线介绍。 Unity将渲染管线的代码分为了几个包，分别如下：  com.unity.render-pipelines.core 此包包含了一些公共的可重用代码，URP和HDRP都会使用此包。 com">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-06T06:44:58.000Z">
<meta property="article:modified_time" content="2025-04-26T11:06:24.130Z">
<meta property="article:author" content="张卫">
<meta property="article:tag" content="Rendering">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2022/10/06/Unity/Graphics/URP%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>URP源码阅读-应用阶段 | 张卫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张卫的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Done is better than perfect</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/06/Unity/Graphics/URP%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="张卫">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张卫的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          URP源码阅读-应用阶段
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-06 14:44:58" itemprop="dateCreated datePublished" datetime="2022-10-06T14:44:58+08:00">2022-10-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-26 19:06:24" itemprop="dateModified" datetime="2025-04-26T19:06:24+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index">
                    <span itemprop="name">Unity</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>通用渲染管线（URP）是Unity官方创建的可编程渲染管线（SRP）。URP提供了艺术家友好的工作流程，能够快速且简单创建跨平台的图形，从移动端到高端控制台和PC。SRP的内容可以参见:<a href="/2021/11/05/Unity/Graphics/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" title="Unity渲染管线介绍">Unity渲染管线介绍</a>。</p>
<p>Unity将渲染管线的代码分为了几个包，分别如下：</p>
<ul>
<li>com.unity.render-pipelines.core
此包包含了一些公共的可重用代码，URP和HDRP都会使用此包。</li>
<li>com.unity.render-pipelines.high-definition-config HDRP配置包。</li>
<li>com.unity.render-pipelines.high-definition HDRP的核心包。</li>
<li>com.unity.render-pipelines.universal URP的核心包。</li>
</ul>
<h1 id="应用阶段">应用阶段</h1>
<p>从名字我们可以看出，这个阶段是由我们的应用主导的，因此通常由CPU负责实现。换句话说，我们这些开发者具有这个阶段的绝对控制权。
在这阶段中，开发者有3个主要任务：</p>
<ol type="1">
<li>我们要准备好场景数据，例如摄像机的位置、视椎体、场景中包含了哪些模型、使用了哪些光源等等；</li>
<li>为了渲染性能，我们往往需要做一个粗粒度剔除（culling）工作,以把哪些不可见的物体踢出去，这样就不需要再移交给几何阶段进行处理；</li>
<li>最后我们要设置好每个模型的渲染状态，这些渲染状态包括但不限于它们使用的材质（漫反射颜色、高光反色颜色）、使用的纹理、使用的Shader等。</li>
</ol>
<p>这一阶段最重要的输出是渲染所需的几何信息，即<strong>渲染图元（rendering
primitives）</strong>。通俗来讲，渲染图元可以是点、线、三角面等。这些渲染图元将会被传递给下一个阶段——几何阶段。</p>
<a id="more"></a>
<h1 id="urp渲染管线">URP渲染管线</h1>
<h2 id="renderpipelinemanager">RenderPipelineManager</h2>
<p>RenderPipelineManager主要管理管线的创建和切换，以及一些渲染循环中的事件。</p>
<p><strong>渲染入口RenderPipelineManager.DoRenderLoop_Internal,
此后函数是Unity Native Code调用的</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unity Native Code每帧调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoRenderLoop_Internal</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  RenderPipelineAsset pipe,</span></span></span><br><span class="line"><span class="function"><span class="params">  IntPtr loopPtr,</span></span></span><br><span class="line"><span class="function"><span class="params">  List&lt;Camera.RenderRequest&gt; renderRequests,</span></span></span><br><span class="line"><span class="function"><span class="params">  AtomicSafetyHandle safety</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 检查并通过渲染管线资源创建创建渲染管线对象（RenderPipeline）</span></span><br><span class="line">  RenderPipelineManager.PrepareRenderPipeline(pipe);</span><br><span class="line">  <span class="comment">// 没有创建成功则返回</span></span><br><span class="line">  <span class="keyword">if</span> (RenderPipelineManager.currentPipeline == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建与底层渲染接口交互的对象</span></span><br><span class="line">  ScriptableRenderContext context = <span class="keyword">new</span> ScriptableRenderContext(loopPtr, safety);</span><br><span class="line">  <span class="comment">// 清除相机列表（重复利用此List,避免GC）</span></span><br><span class="line">  RenderPipelineManager.s_Cameras.Clear();</span><br><span class="line">  <span class="comment">// 通过底层渲染接口获取场景中的相机</span></span><br><span class="line">  context.GetCameras(RenderPipelineManager.s_Cameras);</span><br><span class="line">  <span class="comment">// 是否是单独的渲染请求，不是则按标准流程，所有相机进行渲染，否则就用第一相机执行单独的渲染请求</span></span><br><span class="line">  <span class="keyword">if</span> (renderRequests == <span class="literal">null</span>)</span><br><span class="line">    RenderPipelineManager.currentPipeline.InternalRender(context, RenderPipelineManager.s_Cameras);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    RenderPipelineManager.currentPipeline.InternalRenderWithRequests(context, RenderPipelineManager.s_Cameras, renderRequests);</span><br><span class="line">  <span class="comment">// 渲染完后把相机从列表中清除</span></span><br><span class="line">  RenderPipelineManager.s_Cameras.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>渲染循环事件：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始渲染</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;ScriptableRenderContext, List&lt;Camera&gt;&gt; beginContextRendering; <span class="comment">//2021.1及以后的版本用此，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;ScriptableRenderContext, Camera[]&gt; beginFrameRendering; <span class="comment">// 之前的版本，监听其中一个即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始一个相机的渲染</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;ScriptableRenderContext, Camera&gt; beginCameraRendering;</span><br><span class="line"><span class="comment">// 一个相机的渲染结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;ScriptableRenderContext, Camera&gt; endCameraRendering;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;ScriptableRenderContext, List&lt;Camera&gt;&gt; endContextRendering; <span class="comment">//2021.1及以后的版本用此</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;ScriptableRenderContext, Camera[]&gt; endFrameRendering; <span class="comment">// 之前的版本，监听其中一个即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管线类型改变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action activeRenderPipelineTypeChanged;</span><br></pre></td></tr></table></figure>
<h2 id="renderpipeline">RenderPipeline</h2>
<p>RenderPipeline的作用主要是提供了Render抽象函数（渲染的入口）以及提供渲染循环事件函数并调用到RenderPipelineManager中的对应事件。渲染循环事件函数提供给子类调用，避免每个子类写重复的代码。</p>
<p><strong>核心函数：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数由RenderPipelineManager.DoRenderLoop_Internal调用而来</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">InternalRender</span>(<span class="params">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 销毁了，不应该调用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.disposed)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ObjectDisposedException(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125; has been disposed. Do not call Render on disposed a RenderPipeline."</span>, (<span class="keyword">object</span>) <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用抽象的Render函数，派生的渲染管线必须实现此函数</span></span><br><span class="line">  <span class="keyword">this</span>.Render(context, cameras);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="universalrenderpipeline">UniversalRenderPipeline</h2>
<p>UniversalRenderPipeline继承至RenderPipeline，并实现了Render函数，当然此类的核心函数就是Render。</p>
<p><strong>核心函数：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, List&lt;Camera&gt; cameras</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录一次渲染循环的消耗</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, ProfilingSampler.Get(URPProfileId.UniversalRenderTotal));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始上下文渲染的消耗</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.beginContextRendering))</span><br><span class="line">    &#123;</span><br><span class="line">        BeginContextRendering(renderContext, cameras);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相关配置</span></span><br><span class="line">    GraphicsSettings.lightsUseLinearIntensity = (QualitySettings.activeColorSpace == ColorSpace.Linear);</span><br><span class="line">    GraphicsSettings.lightsUseColorTemperature = <span class="literal">true</span>;</span><br><span class="line">    GraphicsSettings.useScriptableRenderPipelineBatching = asset.useSRPBatcher;</span><br><span class="line">    GraphicsSettings.defaultRenderingLayerMask = k_DefaultRenderingLayerMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置环境光和天空盒子颜色到shader属性（Lighting窗口下的Environment页签下的参数）</span></span><br><span class="line">    SetupPerFrameShaderConstants();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据相机的depth排序</span></span><br><span class="line">    SortCameras(cameras);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历排序后的相机，并渲染</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cameras.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 是Game窗口的相机？</span></span><br><span class="line">        <span class="keyword">var</span> camera = cameras[i];</span><br><span class="line">        <span class="keyword">if</span> (IsGameCamera(camera))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 渲染相机栈</span></span><br><span class="line">            RenderCameraStack(renderContext, camera);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 捕获BeginCameraRendering回调函数的性能消耗</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.beginCameraRendering))</span><br><span class="line">            &#123;</span><br><span class="line">                BeginCameraRendering(renderContext, camera);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VISUAL_EFFECT_GRAPH_0_0_1_OR_NEWER</span></span><br><span class="line">            <span class="comment">// GPU版的粒子系统，此函数更新VisualEffect内部使用的材质，但不执行任何渲染命令。要执行渲染命令，请调用VFXManager.ProcessCamera。再剔除之前调用</span></span><br><span class="line">            VFX.VFXManager.PrepareCamera(camera);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 更新后处理参数</span></span><br><span class="line">            UpdateVolumeFramework(camera, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 渲染单个相机</span></span><br><span class="line">            RenderSingleCamera(renderContext, camera);</span><br><span class="line">            <span class="comment">// 捕获EndCameraRendering回调函数的性能消耗</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.endCameraRendering))</span><br><span class="line">            &#123;</span><br><span class="line">                EndCameraRendering(renderContext, camera);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获EndContextRendering回调函数的性能消耗</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.endContextRendering))</span><br><span class="line">    &#123;</span><br><span class="line">        EndContextRendering(renderContext, cameras);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UniversalRenderPipeline.RenderCameraStack，渲染Base相机，以及Base相机的相机栈，此函数调用UniversalRenderPipeline.RenderSingleCamera函数来渲染单个相机:</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCameraStack</span>(<span class="params">ScriptableRenderContext context, Camera baseCamera</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 性能统计</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, ProfilingSampler.Get(URPProfileId.RenderCameraStack));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取相机附加数据</span></span><br><span class="line">    baseCamera.TryGetComponent&lt;UniversalAdditionalCameraData&gt;(<span class="keyword">out</span> <span class="keyword">var</span> baseCameraAdditionalData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay相机，在渲染Base相机的时候渲染</span></span><br><span class="line">    <span class="keyword">if</span> (baseCameraAdditionalData != <span class="literal">null</span> &amp;&amp; baseCameraAdditionalData.renderType == CameraRenderType.Overlay)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查渲染器是否支持相机栈，并获取相机栈中的相机对象</span></span><br><span class="line">    <span class="keyword">var</span> renderer = baseCameraAdditionalData?.scriptableRenderer;</span><br><span class="line">    <span class="keyword">bool</span> supportsCameraStacking = renderer != <span class="literal">null</span> &amp;&amp; renderer.SupportsCameraStackingType(CameraRenderType.Base);</span><br><span class="line">    List&lt;Camera&gt; cameraStack = (supportsCameraStacking) ? baseCameraAdditionalData?.cameraStack : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相机是否支持后处理</span></span><br><span class="line">    <span class="keyword">bool</span> anyPostProcessingEnabled = baseCameraAdditionalData != <span class="literal">null</span> &amp;&amp; baseCameraAdditionalData.renderPostProcessing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找Base相机，相机栈中的相机，Base相机中有激活的Overlay相机，且渲染器和Base相机相同则需要进行相机栈的渲染</span></span><br><span class="line">    <span class="keyword">int</span> lastActiveOverlayCameraIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cameraStack != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取Base相机的渲染器类型</span></span><br><span class="line">        <span class="keyword">var</span> baseCameraRendererType = baseCameraAdditionalData?.scriptableRenderer.GetType();</span><br><span class="line">        <span class="keyword">bool</span> shouldUpdateCameraStack = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历相机栈的相机</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cameraStack.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Base相机栈中有空的，则需要更新一下栈，将栈中空的移除</span></span><br><span class="line">            Camera currCamera = cameraStack[i];</span><br><span class="line">            <span class="keyword">if</span> (currCamera == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                shouldUpdateCameraStack = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前相机是激活的</span></span><br><span class="line">            <span class="keyword">if</span> (currCamera.isActiveAndEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取当前栈中的相机数据</span></span><br><span class="line">                currCamera.TryGetComponent&lt;UniversalAdditionalCameraData&gt;(<span class="keyword">out</span> <span class="keyword">var</span> data);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查是否与Base相机的渲染器相同</span></span><br><span class="line">                <span class="keyword">var</span> currCameraRendererType = data?.scriptableRenderer.GetType();</span><br><span class="line">                <span class="keyword">if</span> (currCameraRendererType != baseCameraRendererType)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.LogWarning(<span class="string">"Only cameras with compatible renderer types can be stacked. "</span> +</span><br><span class="line">                                      <span class="string">$"The camera: <span class="subst">&#123;currCamera.name&#125;</span> are using the renderer <span class="subst">&#123;currCameraRendererType.Name&#125;</span>, "</span> +</span><br><span class="line">                                      <span class="string">$"but the base camera: <span class="subst">&#123;baseCamera.name&#125;</span> are using <span class="subst">&#123;baseCameraRendererType.Name&#125;</span>. Will skip rendering"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查当前相机是否支持相机栈化</span></span><br><span class="line">                <span class="keyword">var</span> overlayRenderer = data.scriptableRenderer;</span><br><span class="line">                <span class="keyword">if</span> ((overlayRenderer.SupportedCameraStackingTypes() &amp; <span class="number">1</span> &lt;&lt; (<span class="keyword">int</span>)CameraRenderType.Overlay) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.LogWarning(<span class="string">$"The camera: <span class="subst">&#123;currCamera.name&#125;</span> is using a renderer of type <span class="subst">&#123;renderer.GetType().Name&#125;</span> which does not support Overlay cameras in it's current state."</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 相机类型不是Overlay,也不能栈话</span></span><br><span class="line">                <span class="keyword">if</span> (data == <span class="literal">null</span> || data.renderType != CameraRenderType.Overlay)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.LogWarning(<span class="string">$"Stack can only contain Overlay cameras. The camera: <span class="subst">&#123;currCamera.name&#125;</span> "</span> +</span><br><span class="line">                                      <span class="string">$"has a type <span class="subst">&#123;data.renderType&#125;</span> that is not supported. Will skip rendering."</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 栈中的相机是否支持后处理</span></span><br><span class="line">                anyPostProcessingEnabled |= data.renderPostProcessing;</span><br><span class="line">                <span class="comment">// 记录栈中最后一个激活的相机</span></span><br><span class="line">                lastActiveOverlayCameraIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新相机栈，将空的，从List中移除</span></span><br><span class="line">        <span class="keyword">if</span> (shouldUpdateCameraStack)</span><br><span class="line">        &#123;</span><br><span class="line">            baseCameraAdditionalData.UpdateCameraStack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLES2 不支持后处理</span></span><br><span class="line">    anyPostProcessingEnabled &amp;= SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base相机栈中一旦有一个激活的Overlay相机，则可以进行相机栈渲染</span></span><br><span class="line">    <span class="keyword">bool</span> isStackedRendering = lastActiveOverlayCameraIndex != <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 统计相机开始渲染回调消耗</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.beginCameraRendering))</span><br><span class="line">    &#123;</span><br><span class="line">        BeginCameraRendering(context, baseCamera);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新后处理参数</span></span><br><span class="line">    UpdateVolumeFramework(baseCamera, baseCameraAdditionalData);</span><br><span class="line">    <span class="comment">// 初始化相机数据</span></span><br><span class="line">    InitializeCameraData(baseCamera, baseCameraAdditionalData, !isStackedRendering, <span class="keyword">out</span> <span class="keyword">var</span> baseCameraData);</span><br><span class="line">    <span class="comment">// 初始化相机中创建或从相机的RenderTarget中获取的</span></span><br><span class="line">    RenderTextureDescriptor originalTargetDesc = baseCameraData.cameraTargetDescriptor;</span><br><span class="line">    <span class="comment">// 是否启用了GPU粒子系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VISUAL_EFFECT_GRAPH_0_0_1_OR_NEWER</span></span><br><span class="line">    VFX.VFXManager.PrepareCamera(baseCamera);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 渲染单个相机（Base相机）</span></span><br><span class="line">    RenderSingleCamera(context, baseCameraData, anyPostProcessingEnabled);</span><br><span class="line">    <span class="comment">// 统计相机结束渲染回调消耗</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.endCameraRendering))</span><br><span class="line">    &#123;</span><br><span class="line">        EndCameraRendering(context, baseCamera);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此Base相机需要栈化渲染，则渲染Base相机中相机栈列表中的相机</span></span><br><span class="line">    <span class="keyword">if</span> (isStackedRendering)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历栈中相机列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cameraStack.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有启用的相机不管</span></span><br><span class="line">            <span class="keyword">var</span> currCamera = cameraStack[i];</span><br><span class="line">            <span class="keyword">if</span> (!currCamera.isActiveAndEnabled)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前相机数据</span></span><br><span class="line">            currCamera.TryGetComponent&lt;UniversalAdditionalCameraData&gt;(<span class="keyword">out</span> <span class="keyword">var</span> currCameraData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相机是Overlay并启用了，则准备渲染Overly相机</span></span><br><span class="line">            <span class="keyword">if</span> (currCameraData != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将上面初始化的Base相机的相机数据拷贝到Overlay相机数据中（CameraData是个结构体）</span></span><br><span class="line">                CameraData overlayCameraData = baseCameraData;</span><br><span class="line">                <span class="comment">// 检查是否是最后一个Overlay相机，是的话，需要将结果直接渲染到相机目标中</span></span><br><span class="line">                <span class="keyword">bool</span> lastCamera = i == lastActiveOverlayCameraIndex;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 统计相机开始渲染回调消耗</span></span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.beginCameraRendering))</span><br><span class="line">                &#123;</span><br><span class="line">                    BeginCameraRendering(context, currCamera);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VISUAL_EFFECT_GRAPH_0_0_1_OR_NEWER</span></span><br><span class="line">                <span class="comment">// 是否启用了GPU粒子系统</span></span><br><span class="line">                VFX.VFXManager.PrepareCamera(currCamera);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="comment">// 更新后处理参数</span></span><br><span class="line">                UpdateVolumeFramework(currCamera, currCameraData);</span><br><span class="line">                <span class="comment">// 初始化附加相机数据</span></span><br><span class="line">                InitializeAdditionalCameraData(currCamera, currCameraData, lastCamera, <span class="keyword">ref</span> overlayCameraData);</span><br><span class="line">                <span class="comment">// 渲染单个相机（Overlay相机）</span></span><br><span class="line">                RenderSingleCamera(context, overlayCameraData, anyPostProcessingEnabled);</span><br><span class="line">                <span class="comment">// 统计相机结束渲染回调消耗</span></span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.endCameraRendering))</span><br><span class="line">                &#123;</span><br><span class="line">                    EndCameraRendering(context, currCamera);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UniversalRenderPipeline.UpdateVolumeFramework，此函数用于更新后处理参数，主要是计算多个Volume之间插值后的最终参数值:</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UpdateVolumeFramework</span>(<span class="params">Camera camera, UniversalAdditionalCameraData additionalCameraData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, ProfilingSampler.Get(URPProfileId.UpdateVolumeFramework));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scene相机，Game相机中启用了每帧更新或在编辑器下且不是在运行时才需要更新</span></span><br><span class="line">    <span class="keyword">bool</span> shouldUpdate = camera.cameraType == CameraType.SceneView;</span><br><span class="line">    shouldUpdate |= additionalCameraData != <span class="literal">null</span> &amp;&amp; additionalCameraData.requiresVolumeFrameworkUpdate;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    shouldUpdate |= Application.isPlaying == <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当禁用了每帧更新</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldUpdate &amp;&amp; additionalCameraData)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果没有后处理栈，则创建一个（只有在第一帧的时候会到这来）</span></span><br><span class="line">        <span class="keyword">if</span> (additionalCameraData.volumeStack == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            camera.UpdateVolumeStack(additionalCameraData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置为当前的后处理栈</span></span><br><span class="line">        VolumeManager.instance.stack = additionalCameraData.volumeStack;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当我们想要每帧更新的时候，则将相机数据对象上的后处理栈销毁，从新再创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (additionalCameraData &amp;&amp; additionalCameraData.volumeStack != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        camera.DestroyVolumeStack(additionalCameraData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取后处理作用的Layer，以及Trigger器的框定的范围</span></span><br><span class="line">    camera.GetVolumeLayerMaskAndTrigger(additionalCameraData, <span class="keyword">out</span> LayerMask layerMask, <span class="keyword">out</span> Transform trigger);</span><br><span class="line">    <span class="comment">// 将当前的后处理栈，设置为默认的</span></span><br><span class="line">    VolumeManager.instance.ResetMainStack();</span><br><span class="line">    <span class="comment">// 然后根据Layer和Trigger框定的范围去查找范围内的Volume组件，并对组件上的相同参数进行插值混合。</span></span><br><span class="line">    VolumeManager.instance.Update(trigger, layerMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UniversalRenderPipeline.InitializeCameraData,
初始化相机设置（包括相机的基础参数和渲染目标描述器）大部分设置继承至Base相机的设置:</strong>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeCameraData</span>(<span class="params">Camera camera, UniversalAdditionalCameraData additionalCameraData, <span class="keyword">bool</span> resolveFinalTarget, <span class="keyword">out</span> CameraData cameraData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.initializeCameraData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建CameraData</span></span><br><span class="line">    cameraData = <span class="keyword">new</span> CameraData();</span><br><span class="line">    <span class="comment">// 初始化相机的公共数据（Base和Overlay后会有的）</span></span><br><span class="line">    InitializeStackedCameraData(camera, additionalCameraData, <span class="keyword">ref</span> cameraData);</span><br><span class="line">    <span class="comment">// 初始化各种相机单独数据</span></span><br><span class="line">    InitializeAdditionalCameraData(camera, additionalCameraData, resolveFinalTarget, <span class="keyword">ref</span> cameraData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备渲染目标描述器(Descriptor)需要的参数</span></span><br><span class="line">    <span class="comment">// 获取MSSA级别</span></span><br><span class="line">    <span class="keyword">var</span> renderer = additionalCameraData?.scriptableRenderer;</span><br><span class="line">    <span class="keyword">bool</span> rendererSupportsMSAA = renderer != <span class="literal">null</span> &amp;&amp; renderer.supportedRenderingFeatures.msaa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> msaaSamples = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (camera.allowMSAA &amp;&amp; asset.msaaSampleCount &gt; <span class="number">1</span> &amp;&amp; rendererSupportsMSAA)</span><br><span class="line">        msaaSamples = (camera.targetTexture != <span class="literal">null</span>) ? camera.targetTexture.antiAliasing : asset.msaaSampleCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要Alpha通道？</span></span><br><span class="line">    <span class="keyword">bool</span> needsAlphaChannel = Graphics.preserveFramebufferAlpha;</span><br><span class="line">    <span class="comment">// 创建渲染目标描述器(Descriptor)</span></span><br><span class="line">    cameraData.cameraTargetDescriptor = CreateRenderTextureDescriptor(camera, cameraData.renderScale,</span><br><span class="line">        cameraData.isHdrEnabled, msaaSamples, needsAlphaChannel, cameraData.requiresOpaqueTexture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>UniversalRenderPipeline.InitializeStackedCameraData,
初始相机栈中相机的公共设置参数，特定相机特有参数设置参见InitializeAdditionalCameraData函数:</strong>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeStackedCameraData</span>(<span class="params">Camera baseCamera, UniversalAdditionalCameraData baseAdditionalCameraData, <span class="keyword">ref</span> CameraData cameraData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.initializeStackedCameraData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从相机获取targetTexture和cameraType</span></span><br><span class="line">    <span class="keyword">var</span> settings = asset;</span><br><span class="line">    cameraData.targetTexture = baseCamera.targetTexture;</span><br><span class="line">    cameraData.cameraType = baseCamera.cameraType;</span><br><span class="line">    <span class="keyword">bool</span> isSceneViewCamera = cameraData.isSceneViewCamera;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">    <span class="comment">// 环境和后处理设置                                                /</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">    <span class="keyword">if</span> (isSceneViewCamera)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.volumeLayerMask = <span class="number">1</span>; <span class="comment">// "Default"</span></span><br><span class="line">        cameraData.volumeTrigger = <span class="literal">null</span>;</span><br><span class="line">        cameraData.isStopNaNEnabled = <span class="literal">false</span>;</span><br><span class="line">        cameraData.isDitheringEnabled = <span class="literal">false</span>;</span><br><span class="line">        cameraData.antialiasing = AntialiasingMode.None;</span><br><span class="line">        cameraData.antialiasingQuality = AntialiasingQuality.High;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (baseAdditionalCameraData != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.volumeLayerMask = baseAdditionalCameraData.volumeLayerMask;</span><br><span class="line">        cameraData.volumeTrigger = baseAdditionalCameraData.volumeTrigger == <span class="literal">null</span> ? baseCamera.transform : baseAdditionalCameraData.volumeTrigger;</span><br><span class="line">        cameraData.isStopNaNEnabled = baseAdditionalCameraData.stopNaN &amp;&amp; SystemInfo.graphicsShaderLevel &gt;= <span class="number">35</span>; <span class="comment">// 将shader中Nan/Inf的值用黑色像素替代</span></span><br><span class="line">        cameraData.isDitheringEnabled = baseAdditionalCameraData.dithering;     <span class="comment">// 应用一个8位的抖动值，防止颜色条带的产生</span></span><br><span class="line">        cameraData.antialiasing = baseAdditionalCameraData.antialiasing; <span class="comment">// 抗锯齿模式（FXAA和MSAA）</span></span><br><span class="line">        cameraData.antialiasingQuality = baseAdditionalCameraData.antialiasingQuality; <span class="comment">// 抗锯齿质量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.volumeLayerMask = <span class="number">1</span>; <span class="comment">// "Default"</span></span><br><span class="line">        cameraData.volumeTrigger = <span class="literal">null</span>;</span><br><span class="line">        cameraData.isStopNaNEnabled = <span class="literal">false</span>;</span><br><span class="line">        cameraData.isDitheringEnabled = <span class="literal">false</span>;</span><br><span class="line">        cameraData.antialiasing = AntialiasingMode.None;</span><br><span class="line">        cameraData.antialiasingQuality = AntialiasingQuality.High;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">    <span class="comment">// 控制相机输出的设置                                              /</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">    <span class="comment">//HDR是否启用</span></span><br><span class="line">    cameraData.isHdrEnabled = baseCamera.allowHDR &amp;&amp; settings.supportsHDR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相机输出大小</span></span><br><span class="line">    Rect cameraRect = baseCamera.rect;</span><br><span class="line">    cameraData.pixelRect = baseCamera.pixelRect;</span><br><span class="line">    cameraData.pixelWidth = baseCamera.pixelWidth;</span><br><span class="line">    cameraData.pixelHeight = baseCamera.pixelHeight;</span><br><span class="line">    cameraData.aspectRatio = (<span class="keyword">float</span>)cameraData.pixelWidth / (<span class="keyword">float</span>)cameraData.pixelHeight;</span><br><span class="line">    cameraData.isDefaultViewport = (!(Math.Abs(cameraRect.x) &gt; <span class="number">0.0f</span> || Math.Abs(cameraRect.y) &gt; <span class="number">0.0f</span> ||</span><br><span class="line">        Math.Abs(cameraRect.width) &lt; <span class="number">1.0f</span> || Math.Abs(cameraRect.height) &lt; <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染缩放</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> kRenderScaleThreshold = <span class="number">0.05f</span>;</span><br><span class="line">    cameraData.renderScale = (Mathf.Abs(<span class="number">1.0f</span> - settings.renderScale) &lt; kRenderScaleThreshold) ? <span class="number">1.0f</span> : settings.renderScale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定最后使用的放大过滤器</span></span><br><span class="line">    cameraData.upscalingFilter = ResolveUpscalingFilterSelection(<span class="keyword">new</span> Vector2(cameraData.pixelWidth, cameraData.pixelHeight), cameraData.renderScale, settings.upscalingFilter);</span><br><span class="line">    <span class="comment">// 渲染缩放大于1则在最终渲染时，需要向下采样，否则向上采样</span></span><br><span class="line">    <span class="keyword">if</span> (cameraData.renderScale &gt; <span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.imageScalingMode = ImageScalingMode.Downscaling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((cameraData.renderScale &lt; <span class="number">1.0f</span>) || (cameraData.upscalingFilter == ImageUpscalingFilter.FSR))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启用 FSR 后，我们仍将 100% 渲染比例视为放大操作。</span></span><br><span class="line">        <span class="comment">//超分辨率（Super-resolution），有时候又称作放大（upscale, upsize），是一类提高视频或图像分辨率和质量的算法。在视频编辑和图像处理领域，超分辨率非常常见，比如监控视频的处理以及移动设备高分辨率摄像的需求，还有老照片、老电影的高清修复，都会用到超分辨率的技术。而在游戏领域，随着4K/8K分辨率的应用和光线追踪技术的引入，使用原生分辨率渲染图像对于硬件设备的压力确实较高，这时如果使用低分辨率渲染游戏，再通过超分辨率技术使之适应如今高分辨率的屏幕，那么仅会产生少量的画质损失，却能换来可观的帧率提升，必然会成为次时代高画质游戏扩大销量的有效手段之一。</span></span><br><span class="line">        cameraData.imageScalingMode = ImageScalingMode.Upscaling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.imageScalingMode = ImageScalingMode.None;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FSR 参数用于控制FSR的锐化强度的</span></span><br><span class="line">    cameraData.fsrOverrideSharpness = settings.fsrOverrideSharpness;</span><br><span class="line">    cameraData.fsrSharpness = settings.fsrSharpness;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染对象顺序规则</span></span><br><span class="line">    <span class="keyword">var</span> commonOpaqueFlags = SortingCriteria.CommonOpaque;</span><br><span class="line">    <span class="keyword">var</span> noFrontToBackOpaqueFlags = SortingCriteria.SortingLayer | SortingCriteria.RenderQueue | SortingCriteria.OptimizeStateChanges | SortingCriteria.CanvasOrder;</span><br><span class="line">    <span class="keyword">bool</span> hasHSRGPU = SystemInfo.hasHiddenSurfaceRemovalOnGPU;</span><br><span class="line">    <span class="keyword">bool</span> canSkipFrontToBackSorting = (baseCamera.opaqueSortMode == OpaqueSortMode.Default &amp;&amp; hasHSRGPU) || baseCamera.opaqueSortMode == OpaqueSortMode.NoDistanceSort;</span><br><span class="line"></span><br><span class="line">    cameraData.defaultOpaqueSortFlags = canSkipFrontToBackSorting ? noFrontToBackOpaqueFlags : commonOpaqueFlags;</span><br><span class="line">    cameraData.captureActions = CameraCaptureBridge.GetCaptureActions(baseCamera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>UniversalRenderPipeline.InitializeAdditionalCameraData,
初始化相机栈中相机特有参数:</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeAdditionalCameraData</span>(<span class="params">Camera camera, UniversalAdditionalCameraData additionalCameraData, <span class="keyword">bool</span> resolveFinalTarget, <span class="keyword">ref</span> CameraData cameraData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.initializeAdditionalCameraData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> settings = asset;</span><br><span class="line">    cameraData.camera = camera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化阴影参数</span></span><br><span class="line">    <span class="keyword">bool</span> anyShadowsEnabled = settings.supportsMainLightShadows || settings.supportsAdditionalLightShadows;</span><br><span class="line">    cameraData.maxShadowDistance = Mathf.Min(settings.shadowDistance, camera.farClipPlane);</span><br><span class="line">    cameraData.maxShadowDistance = (anyShadowsEnabled &amp;&amp; cameraData.maxShadowDistance &gt;= camera.nearClipPlane) ? cameraData.maxShadowDistance : <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在编辑器时，要设置预览相机的背景颜色</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="keyword">if</span> (cameraData.camera.cameraType == CameraType.Preview)</span><br><span class="line">    &#123;</span><br><span class="line">        camera.backgroundColor = CoreRenderPipelinePreferences.previewBackgroundColor;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scene相机</span></span><br><span class="line">    <span class="keyword">bool</span> isSceneViewCamera = cameraData.isSceneViewCamera;</span><br><span class="line">    <span class="keyword">if</span> (isSceneViewCamera)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.renderType = CameraRenderType.Base;</span><br><span class="line">        cameraData.clearDepth = <span class="literal">true</span>;</span><br><span class="line">        cameraData.postProcessEnabled = CoreUtils.ArePostProcessesEnabled(camera);</span><br><span class="line">        cameraData.requiresDepthTexture = settings.supportsCameraDepthTexture;</span><br><span class="line">        cameraData.requiresOpaqueTexture = settings.supportsCameraOpaqueTexture;</span><br><span class="line">        cameraData.renderer = asset.scriptableRenderer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (additionalCameraData != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.renderType = additionalCameraData.renderType;</span><br><span class="line">        cameraData.clearDepth = (additionalCameraData.renderType != CameraRenderType.Base) ? additionalCameraData.clearDepth : <span class="literal">true</span>;</span><br><span class="line">        cameraData.postProcessEnabled = additionalCameraData.renderPostProcessing;</span><br><span class="line">        cameraData.maxShadowDistance = (additionalCameraData.renderShadows) ? cameraData.maxShadowDistance : <span class="number">0.0f</span>;</span><br><span class="line">        cameraData.requiresDepthTexture = additionalCameraData.requiresDepthTexture;</span><br><span class="line">        cameraData.requiresOpaqueTexture = additionalCameraData.requiresColorTexture;</span><br><span class="line">        cameraData.renderer = additionalCameraData.scriptableRenderer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.renderType = CameraRenderType.Base;</span><br><span class="line">        cameraData.clearDepth = <span class="literal">true</span>;</span><br><span class="line">        cameraData.postProcessEnabled = <span class="literal">false</span>;</span><br><span class="line">        cameraData.requiresDepthTexture = settings.supportsCameraDepthTexture;</span><br><span class="line">        cameraData.requiresOpaqueTexture = settings.supportsCameraOpaqueTexture;</span><br><span class="line">        cameraData.renderer = asset.scriptableRenderer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在GLes2中禁用后处理</span></span><br><span class="line">    cameraData.postProcessEnabled &amp;= SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2;</span><br><span class="line"></span><br><span class="line">    cameraData.requiresDepthTexture |= isSceneViewCamera;</span><br><span class="line">    cameraData.postProcessingRequiresDepthTexture |= CheckPostProcessForDepth(cameraData);</span><br><span class="line">    cameraData.resolveFinalTarget = resolveFinalTarget; <span class="comment">// 是否绘制到最终的目标（相机栈中最后一个相机才需要绘制到最终目标上）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于Overlay相机应该禁用深度和颜色拷贝，应当将它们添加到渲染器中，以避免相机栈化后打断渲染器的执行</span></span><br><span class="line">    <span class="keyword">bool</span> isOverlayCamera = (cameraData.renderType == CameraRenderType.Overlay);</span><br><span class="line">    <span class="keyword">if</span> (isOverlayCamera)</span><br><span class="line">    &#123;</span><br><span class="line">        cameraData.requiresDepthTexture = <span class="literal">false</span>;</span><br><span class="line">        cameraData.requiresOpaqueTexture = <span class="literal">false</span>;</span><br><span class="line">        cameraData.postProcessingRequiresDepthTexture = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Overlay相机与Base相机的视口大小不同时，需要修正投影矩阵</span></span><br><span class="line">    Matrix4x4 projectionMatrix = camera.projectionMatrix;</span><br><span class="line">    <span class="keyword">if</span> (isOverlayCamera &amp;&amp; !camera.orthographic &amp;&amp; cameraData.pixelRect != camera.pixelRect)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m00 = (cotangent / aspect), 因此 m00 * aspect = cotangent.</span></span><br><span class="line">        <span class="keyword">float</span> cotangent = camera.projectionMatrix.m00 * camera.aspect;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过除以Base相机的aspectRatio获得新的m00</span></span><br><span class="line">        <span class="keyword">float</span> newCotangent = cotangent / cameraData.aspectRatio;</span><br><span class="line">        projectionMatrix.m00 = newCotangent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cameraData.SetViewAndProjectionMatrix(camera.worldToCameraMatrix, projectionMatrix);</span><br><span class="line"></span><br><span class="line">    cameraData.worldSpaceCameraPos = camera.transform.position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相机数据初始化完后，就调用UniversalRenderPipeline.RenderSingleCamera函数进行单个相机的渲染：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderSingleCamera</span>(<span class="params">ScriptableRenderContext context, CameraData cameraData, <span class="keyword">bool</span> anyPostProcessingEnabled</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Camera camera = cameraData.camera;</span><br><span class="line">    <span class="comment">// 相机使用的渲染器</span></span><br><span class="line">    <span class="keyword">var</span> renderer = cameraData.renderer;</span><br><span class="line">    <span class="keyword">if</span> (renderer == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="keyword">string</span>.Format(<span class="string">"Trying to render &#123;0&#125; with an invalid renderer. Camera rendering will be skipped."</span>, camera.name));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取相机的剔除参数</span></span><br><span class="line">    <span class="keyword">if</span> (!TryGetCullingParameters(cameraData, <span class="keyword">out</span> <span class="keyword">var</span> cullingParameters))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前渲染器</span></span><br><span class="line">    ScriptableRenderer.current = renderer;</span><br><span class="line">    <span class="keyword">bool</span> isSceneViewCamera = cameraData.isSceneViewCamera;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从池里拿一个CommandBuffer</span></span><br><span class="line">    CommandBuffer cmd = CommandBufferPool.Get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取性能采样器</span></span><br><span class="line">    ProfilingSampler sampler = Profiling.TryGetOrAddCameraSampler(camera);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmdScope, sampler)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清除color， depth缓冲区</span></span><br><span class="line">        renderer.Clear(cameraData.renderType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置相机剔除参数</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.Renderer.setupCullingParameters))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在设置剔除参数之前调用渲染器的OnPreCullRenderPasses,此函数会路由到渲染特性中</span></span><br><span class="line">            renderer.OnPreCullRenderPasses(<span class="keyword">in</span> cameraData);</span><br><span class="line">            renderer.SetupCullingParameters(<span class="keyword">ref</span> cullingParameters, <span class="keyword">ref</span> cameraData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.ExecuteCommandBuffer(cmd); <span class="comment">// 发送在CommandBuffer中的所有命令到ScriptableRenderContext上下文</span></span><br><span class="line">        cmd.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据剔除参数，调用ScriptableRenderContext的剔除函数进行剔除，并返回剔除结果</span></span><br><span class="line">        <span class="keyword">var</span> cullResults = context.Cull(<span class="keyword">ref</span> cullingParameters);</span><br><span class="line">        <span class="comment">// 根据剔除结果和其他参数初始化渲染数据(灯光，阴影和后处理数据等，具体参见RenderingData结构)</span></span><br><span class="line">        InitializeRenderingData(asset, <span class="keyword">ref</span> cameraData, <span class="keyword">ref</span> cullResults, anyPostProcessingEnabled, <span class="keyword">out</span> <span class="keyword">var</span> renderingData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安排各种Pass和RenderFeature</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.Renderer.setup))</span><br><span class="line">        &#123;</span><br><span class="line">            renderer.Setup(context, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用渲染器内的的Execute执行安排的Pass和RenderFeature</span></span><br><span class="line">        renderer.Execute(context, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        <span class="comment">// 清理灯数据</span></span><br><span class="line">        CleanupLightData(<span class="keyword">ref</span> renderingData.lightData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送在CommandBuffer中的所有命令到ScriptableRenderContext上下文</span></span><br><span class="line">    context.ExecuteCommandBuffer(cmd); </span><br><span class="line">    <span class="comment">// CommandBuffer发送后，放回池里</span></span><br><span class="line">    CommandBufferPool.Release(cmd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将发送到ScriptableRenderContext的命令提交到底层执行</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.Context.submit))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (renderer.useRenderPassEnabled &amp;&amp; !context.SubmitForRenderPassValidation())</span><br><span class="line">        &#123;</span><br><span class="line">            renderer.useRenderPassEnabled = <span class="literal">false</span>;</span><br><span class="line">            CoreUtils.SetKeyword(cmd, ShaderKeywordStrings.RenderPassEnabled, <span class="literal">false</span>);</span><br><span class="line">            Debug.LogWarning(<span class="string">"Rendering command not supported inside a native RenderPass found. Falling back to non-RenderPass rendering path"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        context.Submit(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除当前渲染器</span></span><br><span class="line">    ScriptableRenderer.current = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在渲染单个相机之前，需要对渲染数据进行初始化，UniversalRenderPipeline.InitializeRenderingData：</strong>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeRenderingData</span>(<span class="params">UniversalRenderPipelineAsset settings, <span class="keyword">ref</span> CameraData cameraData, <span class="keyword">ref</span> CullingResults cullResults,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> anyPostProcessingEnabled, <span class="keyword">out</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.Pipeline.initializeRenderingData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相机剔除后，对此次渲染有影响的灯光</span></span><br><span class="line">    <span class="keyword">var</span> visibleLights = cullResults.visibleLights;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主灯光（如果Light窗口指定了太阳光（sun）,则主光将是此太阳光，否则将获取亮度最强的方向光）</span></span><br><span class="line">    <span class="keyword">int</span> mainLightIndex = GetMainLightIndex(settings, visibleLights);</span><br><span class="line">    <span class="keyword">bool</span> mainLightCastShadows = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> additionalLightsCastShadows = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要阴影</span></span><br><span class="line">    <span class="keyword">if</span> (cameraData.maxShadowDistance &gt; <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 主灯光投射阴影?</span></span><br><span class="line">        mainLightCastShadows = (mainLightIndex != <span class="number">-1</span> &amp;&amp; visibleLights[mainLightIndex].light != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            visibleLights[mainLightIndex].light.shadows != LightShadows.None);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐像素灯光才能投射阴影</span></span><br><span class="line">        <span class="keyword">if</span> (settings.additionalLightsRenderingMode == LightRenderingMode.PerPixel)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visibleLights.Length; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == mainLightIndex)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                Light light = visibleLights[i].light;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 附加方向光目前不支持投射阴影</span></span><br><span class="line">                <span class="keyword">if</span> ((visibleLights[i].lightType == LightType.Spot || visibleLights[i].lightType == LightType.Point) &amp;&amp; light != <span class="literal">null</span> &amp;&amp; light.shadows != LightShadows.None)</span><br><span class="line">                &#123;</span><br><span class="line">                    additionalLightsCastShadows = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderingData.cullResults = cullResults;</span><br><span class="line">    renderingData.cameraData = cameraData;</span><br><span class="line">    <span class="comment">// 初始化灯光数据</span></span><br><span class="line">    InitializeLightData(settings, visibleLights, mainLightIndex, <span class="keyword">out</span> renderingData.lightData);</span><br><span class="line">    <span class="comment">// 初始化阴影数据</span></span><br><span class="line">    InitializeShadowData(settings, visibleLights, mainLightCastShadows, additionalLightsCastShadows &amp;&amp; !renderingData.lightData.shadeAdditionalLightsPerVertex, <span class="keyword">out</span> renderingData.shadowData);</span><br><span class="line">    <span class="comment">// 初始化后处理数据</span></span><br><span class="line">    InitializePostProcessingData(settings, <span class="keyword">out</span> renderingData.postProcessingData);</span><br><span class="line">    <span class="comment">// 其他渲染数据初始化</span></span><br><span class="line">    renderingData.supportsDynamicBatching = settings.supportsDynamicBatching;</span><br><span class="line">    renderingData.perObjectData = GetPerObjectLightFlags(renderingData.lightData.additionalLightsCount);</span><br><span class="line">    renderingData.postProcessingEnabled = anyPostProcessingEnabled;</span><br><span class="line"></span><br><span class="line">    CheckAndApplyDebugSettings(<span class="keyword">ref</span> renderingData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="urp渲染器">URP渲染器</h1>
<p>一个渲染管线中可以包含多个渲染器，不同的相机可以使用不同的渲染器进行渲染。</p>
<h2 id="scriptablerenderer">ScriptableRenderer</h2>
<p>ScriptableRenderer是所有渲染器的基类，提供了基础的功能，比如：设置相机矩阵，Shader中用的到一些变量，执行渲染器中的RendererFeature和Pass等。</p>
<p><strong>1. 首先清除color，
depth缓冲区，ScriptableRenderer.Clear：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params">CameraRenderType cameraType</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 激活的颜色缓冲区</span></span><br><span class="line">    m_ActiveColorAttachments[<span class="number">0</span>] = BuiltinRenderTextureType.CameraTarget;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m_ActiveColorAttachments.Length; ++i)</span><br><span class="line">        m_ActiveColorAttachments[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活的深度</span></span><br><span class="line">    m_ActiveDepthAttachment = BuiltinRenderTextureType.CameraTarget;</span><br><span class="line"></span><br><span class="line">    m_FirstTimeCameraColorTargetIsBound = cameraType == CameraRenderType.Base;</span><br><span class="line">    m_FirstTimeCameraDepthTargetIsBound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前相机的颜色和深度缓冲区</span></span><br><span class="line">    m_CameraColorTarget = BuiltinRenderTextureType.CameraTarget;</span><br><span class="line">    m_CameraDepthTarget = BuiltinRenderTextureType.CameraTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.
执行剔除前调用函数，ScriptableRenderer.OnPreCullRenderPasses</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">OnPreCullRenderPasses</span>(<span class="params"><span class="keyword">in</span> CameraData cameraData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用到渲染特性中的OnCameraPreCull</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rendererFeatures.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rendererFeatures[i].isActive)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rendererFeatures[i].OnCameraPreCull(<span class="keyword">this</span>, <span class="keyword">in</span> cameraData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.
构建相机剔除参数ScriptableRenderer.SetupCullingParameters，每个子类具体实现</strong></p>
<p><strong>4. 构建各种渲染Pass,
ScriptableRenderer.Setup，每个子类具体实现</strong></p>
<p><strong>5. 执行渲染，ScriptableRenderer.Execute</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用场景覆盖时禁用Gizmos。 Gizmos破坏了一些效果，例如Overdraw调试。</span></span><br><span class="line">    <span class="keyword">bool</span> drawGizmos = DebugDisplaySettings.Instance.RenderingSettings.debugSceneOverrideMode == DebugSceneOverrideMode.None;</span><br><span class="line"></span><br><span class="line">    m_IsPipelineExecuting = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">ref</span> CameraData cameraData = <span class="keyword">ref</span> renderingData.cameraData;</span><br><span class="line">    Camera camera = cameraData.camera;</span><br><span class="line"></span><br><span class="line">    CommandBuffer cmd = CommandBufferPool.Get();</span><br><span class="line"></span><br><span class="line">    CommandBuffer cmdScope = renderingData.cameraData.xr.enabled ? <span class="literal">null</span> : cmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmdScope, profilingExecute))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始渲染，执行所有Pass的OnCameraSetup函数</span></span><br><span class="line">        InternalStartRendering(context, <span class="keyword">ref</span> renderingData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存time信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="keyword">float</span> time = Application.isPlaying ? Time.time : Time.realtimeSinceStartup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">float</span> time = Time.time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">float</span> deltaTime = Time.deltaTime;</span><br><span class="line">        <span class="keyword">float</span> smoothDeltaTime = Time.smoothDeltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化渲染状态，禁用一些Shader的宏</span></span><br><span class="line">        ClearRenderingState(cmd);</span><br><span class="line">        <span class="comment">// 设置Time信息，在Shader中访问的_Time，_SinTime和_CosTime等</span></span><br><span class="line">        SetShaderTimeValues(cmd, time, deltaTime, smoothDeltaTime);</span><br><span class="line">        context.ExecuteCommandBuffer(cmd);</span><br><span class="line">        cmd.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据RenderPassEvent排序Pass</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.sortRenderPasses))</span><br><span class="line">        &#123;</span><br><span class="line">            SortStable(m_ActiveRenderPassQueue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SetupNativeRenderPassFrameData(cameraData, useRenderPassEnabled);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将渲染Pass根据RenderPassEvent分为4个大类（RenderPassBlock.BeforeRendering, RenderPassBlock.MainRenderingOpaque, RenderPassBlock.MainRenderingTransparent和RenderPassBlock.AfterRendering）</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> renderBlocks = <span class="keyword">new</span> RenderBlocks(m_ActiveRenderPassQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建灯光数据</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.setupLights))</span><br><span class="line">        &#123;</span><br><span class="line">            SetupLights(context, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取渲染前的渲染Pass, 被用于为渲染器准备输入纹理（比如：shadowmaps）</span></span><br><span class="line">        <span class="keyword">if</span> (renderBlocks.GetLength(RenderPassBlock.BeforeRendering) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 执行渲染前的所有Pass</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.RenderBlock.beforeRendering);</span><br><span class="line">            ExecuteBlock(RenderPassBlock.BeforeRendering, <span class="keyword">in</span> renderBlocks, context, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始设置相机属性和相机相关的Shader变量</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.setupCamera))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cameraData.renderType == CameraRenderType.Base)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置相机属性</span></span><br><span class="line">                context.SetupCameraProperties(camera);</span><br><span class="line">                <span class="comment">// 设置相机相关的的Shader变量（_WorldSpaceCameraPos， _ScreenParams， _ProjectionParams， _ZBufferParams和_ScaledScreenParams等）</span></span><br><span class="line">                SetPerCameraShaderVariables(cmd, <span class="keyword">ref</span> cameraData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置相机相关的的Shader变量（_WorldSpaceCameraPos， _ScreenParams， _ProjectionParams， _ZBufferParams和_ScaledScreenParams等）</span></span><br><span class="line">                SetPerCameraShaderVariables(cmd, <span class="keyword">ref</span> cameraData);</span><br><span class="line">                <span class="comment">// 设置相机的裁剪平面Shader变量（unity_CameraWorldClipPlanes）</span></span><br><span class="line">                SetPerCameraClippingPlaneProperties(cmd, <span class="keyword">in</span> cameraData);</span><br><span class="line">                <span class="comment">// 设置相机的布告属性（unity_BillboardNormal， unity_BillboardTangent和unity_BillboardCameraParams）</span></span><br><span class="line">                SetPerCameraBillboardProperties(cmd, <span class="keyword">ref</span> cameraData);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新设置设置Shader的时间相关的变量，在SetupCameraProperties被修改了</span></span><br><span class="line">            SetShaderTimeValues(cmd, time, deltaTime, smoothDeltaTime);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VISUAL_EFFECT_GRAPH_0_0_1_OR_NEWER</span></span><br><span class="line">            <span class="comment">// GPU粒子系统，设置所有全局参数</span></span><br><span class="line">            VFX.VFXManager.ProcessCameraCommand(camera, cmd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.ExecuteCommandBuffer(cmd);</span><br><span class="line">        cmd.Clear();</span><br><span class="line"></span><br><span class="line">        BeginXRRendering(cmd, context, <span class="keyword">ref</span> renderingData.cameraData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行主要的不透明和半透明对象的渲染</span></span><br><span class="line">        <span class="comment">// 不透明块的渲染</span></span><br><span class="line">        <span class="keyword">if</span> (renderBlocks.GetLength(RenderPassBlock.MainRenderingOpaque) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 执行不透明块中的所有Pass</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.RenderBlock.mainRenderingOpaque);</span><br><span class="line">            ExecuteBlock(RenderPassBlock.MainRenderingOpaque, <span class="keyword">in</span> renderBlocks, context, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 透明块</span></span><br><span class="line">        <span class="keyword">if</span> (renderBlocks.GetLength(RenderPassBlock.MainRenderingTransparent) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 执行透明块中的所有Pass</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.RenderBlock.mainRenderingTransparent);</span><br><span class="line">            ExecuteBlock(RenderPassBlock.MainRenderingTransparent, <span class="keyword">in</span> renderBlocks, context, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_VR &amp;&amp; ENABLE_XR_MODULE</span></span><br><span class="line">        <span class="keyword">if</span> (cameraData.xr.enabled)</span><br><span class="line">            cameraData.xr.canMarkLateLatch = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制 Gizmos</span></span><br><span class="line">        <span class="keyword">if</span> (drawGizmos)</span><br><span class="line">        &#123;</span><br><span class="line">            DrawGizmos(context, camera, GizmoSubset.PreImageEffects);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在绘制完不透明和透明对象块中的Pass后，执行AfterRendering块，主要包括后处理，视频捕获等。</span></span><br><span class="line">        <span class="keyword">if</span> (renderBlocks.GetLength(RenderPassBlock.AfterRendering) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, Profiling.RenderBlock.afterRendering);</span><br><span class="line">            ExecuteBlock(RenderPassBlock.AfterRendering, <span class="keyword">in</span> renderBlocks, context, <span class="keyword">ref</span> renderingData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EndXRRendering(cmd, context, <span class="keyword">ref</span> renderingData.cameraData);</span><br><span class="line"></span><br><span class="line">        DrawWireOverlay(context, camera);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawGizmos)</span><br><span class="line">        &#123;</span><br><span class="line">            DrawGizmos(context, camera, GizmoSubset.PostImageEffects);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束渲染，执行所有Pass的FrameCleanup函数，如果是相机栈的最后一个，则还回调用所有Pass的OnFinishCameraStackRendering</span></span><br><span class="line">        InternalFinishRendering(context, cameraData.resolveFinalTarget);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_ActiveRenderPassQueue.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_ActiveRenderPassQueue[i].m_ColorAttachmentIndices.Dispose();</span><br><span class="line">            m_ActiveRenderPassQueue[i].m_InputAttachmentIndices.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context.ExecuteCommandBuffer(cmd);</span><br><span class="line">    CommandBufferPool.Release(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="universalrenderer">UniversalRenderer</h2>
<p>UniversalRenderer是ScriptableRenderer的子类，URP的标准渲染器。
它主要在复写的Setup函数中添加了各种的渲染Pass到m_ActiveRenderPassQueue中，核心的代码在基类ScriptableRenderer中。</p>
<p><strong>核心成员：</strong></p>
<ul>
<li>ForwardLights m_ForwardLights; // 前向渲染光照</li>
<li>DeferredLights m_DeferredLights; // 延迟渲染光照</li>
</ul>
<p><strong>核心Pass:</strong></p>
<ul>
<li>DepthOnlyPass 深度Pass</li>
<li>MainLightShadowCasterPass 主灯光阴影投射Pass</li>
<li>DrawObjectsPass 绘制对象Pass</li>
<li>DrawSkyboxPass 绘制天空盒Pass</li>
</ul>
<h1 id="urp中的pass">URP中的Pass</h1>
<p>Pass是执行一个具体的渲染任务。</p>
<h2 id="scriptablerenderpass">ScriptableRenderPass</h2>
<p>ScriptableRenderPass是渲染Pass的基础类，提供一些Pass都应具备的属性，一些公共的方法和Pass的生命周期函数，具体如下：</p>
<p><strong>Pass的共有属性：</strong></p>
<ul>
<li>renderPassEvent 渲染Pass事件（BeforeRendering，
BeforeRenderingGbuffer， BeforeRenderingOpaques，
AfterRenderingOpaques， BeforeRenderingTransparents，
AfterRenderingTransparents，
BeforeRenderingPostProcessing和AfterRendering等 ）。</li>
<li>colorAttachment 颜色缓冲区纹理。</li>
<li>depthAttachment 深度缓冲区纹理。</li>
<li>input
Pass的输入需求（ScriptableRenderPassInput.Depth,Normal,Color和Motion）。</li>
<li>clearFlag 需要清除的是：Color，Depth和Stencil)。</li>
<li>clearColor 清除的值是什么。</li>
<li>renderTargetWidth/renderTargetHeight 渲染目标的宽度和高度。</li>
<li>depthOnly 是仅深度？</li>
<li>isLastPass 是最后一个Pass。</li>
<li>renderPassQueueIndex
这帧中Pass的索引，就是在ScriptableRenderer.m_ActiveRenderPassQueue排序后的索引</li>
</ul>
<p><strong>公共的方法：</strong></p>
<ul>
<li>ConfigureInput 配置此Pass的输入需求。</li>
<li>ConfigureInputAttachments 配置输入附件纹理</li>
<li>ConfigureTarget
配置渲染目标（colorAttachment和depthAttachment）</li>
<li>ConfigureClear 配置清除标志</li>
<li>Blit 拷贝纹理</li>
<li>CreateDrawingSettings 创建绘制设置（使用的什么Tag的Shader,
排序规则是什么等。）</li>
</ul>
<p><strong>生命周期函数:</strong></p>
<ul>
<li>OnCameraSetup 渲染一个相机前调用，所有Pass执行之前调用。</li>
<li>Configure 执行一个Pass前调用。</li>
<li>Execute 核心执行函数。</li>
<li>OnCameraCleanup 渲染一个相机完成后调用。</li>
<li>OnFinishCameraStackRendering 整个相机栈渲染完成后调用。</li>
</ul>
<h2 id="核心pass">核心Pass</h2>
<h3 id="depthonlypass-深度pass">DepthOnlyPass 深度Pass</h3>
<p><strong>核心函数：</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup函数是由Render中调用过来的，它并不在ScriptableRenderPass基类中定义，它在OnCameraSetup之前调用，并不是所有的Pass都有此函数，如果需要自定义Render可以在Render的Setup中去调用Pass的Setup函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    RenderTextureDescriptor baseDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">    RenderTargetHandle depthAttachmentHandle</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.depthAttachmentHandle = depthAttachmentHandle;</span><br><span class="line">    baseDescriptor.colorFormat = RenderTextureFormat.Depth;</span><br><span class="line">    baseDescriptor.depthBufferBits = UniversalRenderer.k_DepthStencilBufferBits;</span><br><span class="line"></span><br><span class="line">    baseDescriptor.msaaSamples = <span class="number">1</span>;</span><br><span class="line">    descriptor = baseDescriptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.allocateDepth = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.shaderTagId = k_ShaderTagId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有Pass执行之前调用，相机渲染相关资源和数据(renderingData)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCameraSetup</span>(<span class="params">CommandBuffer cmd, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allocateDepth)</span><br><span class="line">        cmd.GetTemporaryRT(depthAttachmentHandle.id, descriptor, FilterMode.Point);</span><br><span class="line">    <span class="keyword">var</span> desc = renderingData.cameraData.cameraTargetDescriptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置深度Pass的渲染目标</span></span><br><span class="line">    <span class="keyword">if</span> (renderingData.cameraData.renderer.useDepthPriming &amp;&amp; (renderingData.cameraData.renderType == CameraRenderType.Base || renderingData.cameraData.clearDepth))</span><br><span class="line">    &#123;</span><br><span class="line">        ConfigureTarget(renderingData.cameraData.renderer.cameraDepthTarget, descriptor.depthStencilFormat, desc.width, desc.height, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ConfigureTarget(<span class="keyword">new</span> RenderTargetIdentifier(depthAttachmentHandle.Identifier(), <span class="number">0</span>, CubemapFace.Unknown, <span class="number">-1</span>), descriptor.depthStencilFormat, desc.width, desc.height, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置清除</span></span><br><span class="line">    ConfigureClear(ClearFlag.Depth, Color.black);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行此Pass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个CommandBuff用于执行渲染</span></span><br><span class="line">    CommandBuffer cmd = CommandBufferPool.Get();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.DepthPrepass)))</span><br><span class="line">    &#123;</span><br><span class="line">        context.ExecuteCommandBuffer(cmd);</span><br><span class="line">        cmd.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 筛选需要绘制的对象，使用Shader中的Tag为"DepthOnly"的Pass进行渲染</span></span><br><span class="line">        <span class="keyword">var</span> sortFlags = renderingData.cameraData.defaultOpaqueSortFlags;</span><br><span class="line">        <span class="keyword">var</span> drawSettings = CreateDrawingSettings(<span class="keyword">this</span>.shaderTagId, <span class="keyword">ref</span> renderingData, sortFlags);</span><br><span class="line">        drawSettings.perObjectData = PerObjectData.None;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制对象</span></span><br><span class="line">        context.DrawRenderers(renderingData.cullResults, <span class="keyword">ref</span> drawSettings, <span class="keyword">ref</span> m_FilteringSettings);</span><br><span class="line">    &#125;</span><br><span class="line">    context.ExecuteCommandBuffer(cmd);</span><br><span class="line">    CommandBufferPool.Release(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机渲染完成后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCameraCleanup</span>(<span class="params">CommandBuffer cmd</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">"cmd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的资源</span></span><br><span class="line">    <span class="keyword">if</span> (depthAttachmentHandle != RenderTargetHandle.CameraTarget)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allocateDepth)</span><br><span class="line">            cmd.ReleaseTemporaryRT(depthAttachmentHandle.id);</span><br><span class="line">        depthAttachmentHandle = RenderTargetHandle.CameraTarget;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3
id="mainlightshadowcasterpass-主灯光阴影投射pass">MainLightShadowCasterPass
主灯光阴影投射Pass</h3>
<p><strong>核心函数：</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainLightShadowCasterPass</span>(<span class="params">RenderPassEvent evt</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">base</span>.profilingSampler = <span class="keyword">new</span> ProfilingSampler(<span class="keyword">nameof</span>(MainLightShadowCasterPass));</span><br><span class="line">    renderPassEvent = evt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个级联阴影矩阵，切片数据和距离</span></span><br><span class="line">    m_MainLightShadowMatrices = <span class="keyword">new</span> Matrix4x4[k_MaxCascades + <span class="number">1</span>];</span><br><span class="line">    m_CascadeSlices = <span class="keyword">new</span> ShadowSliceData[k_MaxCascades];</span><br><span class="line">    m_CascadeSplitDistances = <span class="keyword">new</span> Vector4[k_MaxCascades];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算主灯光阴影需要Shader属性</span></span><br><span class="line">    MainLightShadowConstantBuffer._WorldToShadow = Shader.PropertyToID(<span class="string">"_MainLightWorldToShadow"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._ShadowParams = Shader.PropertyToID(<span class="string">"_MainLightShadowParams"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._CascadeShadowSplitSpheres0 = Shader.PropertyToID(<span class="string">"_CascadeShadowSplitSpheres0"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._CascadeShadowSplitSpheres1 = Shader.PropertyToID(<span class="string">"_CascadeShadowSplitSpheres1"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._CascadeShadowSplitSpheres2 = Shader.PropertyToID(<span class="string">"_CascadeShadowSplitSpheres2"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._CascadeShadowSplitSpheres3 = Shader.PropertyToID(<span class="string">"_CascadeShadowSplitSpheres3"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._CascadeShadowSplitSphereRadii = Shader.PropertyToID(<span class="string">"_CascadeShadowSplitSphereRadii"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._ShadowOffset0 = Shader.PropertyToID(<span class="string">"_MainLightShadowOffset0"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._ShadowOffset1 = Shader.PropertyToID(<span class="string">"_MainLightShadowOffset1"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._ShadowOffset2 = Shader.PropertyToID(<span class="string">"_MainLightShadowOffset2"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._ShadowOffset3 = Shader.PropertyToID(<span class="string">"_MainLightShadowOffset3"</span>);</span><br><span class="line">    MainLightShadowConstantBuffer._ShadowmapSize = Shader.PropertyToID(<span class="string">"_MainLightShadowmapSize"</span>);</span><br><span class="line"></span><br><span class="line">    m_MainLightShadowmap.Init(<span class="string">"_MainLightShadowmapTexture"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置渲染数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Setup</span>(<span class="params"><span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> profScope = <span class="keyword">new</span> ProfilingScope(<span class="literal">null</span>, m_ProfilingSetupSampler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持的时候，创建一个空（1x1）的阴影贴图</span></span><br><span class="line">    <span class="keyword">if</span> (!renderingData.shadowData.supportsMainLightShadows)</span><br><span class="line">        <span class="keyword">return</span> SetupForEmptyRendering(<span class="keyword">ref</span> renderingData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除阴影贴图和级联数据</span></span><br><span class="line">    Clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有主灯光</span></span><br><span class="line">    <span class="keyword">int</span> shadowLightIndex = renderingData.lightData.mainLightIndex;</span><br><span class="line">    <span class="keyword">if</span> (shadowLightIndex == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> SetupForEmptyRendering(<span class="keyword">ref</span> renderingData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主灯光是否支持阴影</span></span><br><span class="line">    VisibleLight shadowLight = renderingData.lightData.visibleLights[shadowLightIndex];</span><br><span class="line">    Light light = shadowLight.light;</span><br><span class="line">    <span class="keyword">if</span> (light.shadows == LightShadows.None)</span><br><span class="line">        <span class="keyword">return</span> SetupForEmptyRendering(<span class="keyword">ref</span> renderingData);</span><br><span class="line">    <span class="comment">// 只有方向光能作为主灯光</span></span><br><span class="line">    <span class="keyword">if</span> (shadowLight.lightType != LightType.Directional)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">"Only directional lights are supported as main light."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取阴影的投射边界</span></span><br><span class="line">    Bounds bounds;</span><br><span class="line">    <span class="keyword">if</span> (!renderingData.cullResults.GetShadowCasterBounds(shadowLightIndex, <span class="keyword">out</span> bounds))</span><br><span class="line">        <span class="keyword">return</span> SetupForEmptyRendering(<span class="keyword">ref</span> renderingData);</span><br><span class="line">    <span class="comment">// 获取级联数量</span></span><br><span class="line">    m_ShadowCasterCascadesCount = renderingData.shadowData.mainLightShadowCascadesCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据总分辨率和指定级联数量，计算出单个级联的分辨率</span></span><br><span class="line">    <span class="keyword">int</span> shadowResolution = ShadowUtils.GetMaxTileResolutionInAtlas(renderingData.shadowData.mainLightShadowmapWidth,</span><br><span class="line">        renderingData.shadowData.mainLightShadowmapHeight, m_ShadowCasterCascadesCount);</span><br><span class="line">    renderTargetWidth = renderingData.shadowData.mainLightShadowmapWidth;</span><br><span class="line">    renderTargetHeight = (m_ShadowCasterCascadesCount == <span class="number">2</span>) ?</span><br><span class="line">        renderingData.shadowData.mainLightShadowmapHeight &gt;&gt; <span class="number">1</span> :</span><br><span class="line">        renderingData.shadowData.mainLightShadowmapHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个级联的矩阵，切片数据和距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cascadeIndex = <span class="number">0</span>; cascadeIndex &lt; m_ShadowCasterCascadesCount; ++cascadeIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> success = ShadowUtils.ExtractDirectionalLightMatrix(<span class="keyword">ref</span> renderingData.cullResults, <span class="keyword">ref</span> renderingData.shadowData,</span><br><span class="line">            shadowLightIndex, cascadeIndex, renderTargetWidth, renderTargetHeight, shadowResolution, light.shadowNearPlane,</span><br><span class="line">            <span class="keyword">out</span> m_CascadeSplitDistances[cascadeIndex], <span class="keyword">out</span> m_CascadeSlices[cascadeIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">            <span class="keyword">return</span> SetupForEmptyRendering(<span class="keyword">ref</span> renderingData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取阴影RT</span></span><br><span class="line">    m_MainLightShadowmapTexture = ShadowUtils.GetTemporaryShadowTexture(renderTargetWidth, renderTargetHeight, k_ShadowmapBufferBits);</span><br><span class="line">    m_MaxShadowDistanceSq = renderingData.cameraData.maxShadowDistance * renderingData.cameraData.maxShadowDistance;</span><br><span class="line">    m_CascadeBorder = renderingData.shadowData.mainLightShadowCascadeBorder;</span><br><span class="line">    m_CreateEmptyShadowmap = <span class="literal">false</span>;</span><br><span class="line">    useNativeRenderPass = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将阴影贴图设置为当前的颜色缓冲区，并清除它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConfigureTarget(<span class="keyword">new</span> RenderTargetIdentifier(m_MainLightShadowmapTexture), m_MainLightShadowmapTexture.depthStencilFormat, renderTargetWidth, renderTargetHeight, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    ConfigureClear(ClearFlag.All, Color.black);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass的执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_CreateEmptyShadowmap)</span><br><span class="line">    &#123;</span><br><span class="line">        SetEmptyMainLightCascadeShadowmap(<span class="keyword">ref</span> context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RenderMainLightCascadeShadowmap(<span class="keyword">ref</span> context, <span class="keyword">ref</span> renderingData.cullResults, <span class="keyword">ref</span> renderingData.lightData, <span class="keyword">ref</span> renderingData.shadowData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染主灯光的阴影贴图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderMainLightCascadeShadowmap</span>(<span class="params"><span class="keyword">ref</span> ScriptableRenderContext context, <span class="keyword">ref</span> CullingResults cullResults, <span class="keyword">ref</span> LightData lightData, <span class="keyword">ref</span> ShadowData shadowData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shadowLightIndex = lightData.mainLightIndex;</span><br><span class="line">    <span class="keyword">if</span> (shadowLightIndex == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主灯光</span></span><br><span class="line">    VisibleLight shadowLight = lightData.visibleLights[shadowLightIndex];</span><br><span class="line"></span><br><span class="line">    CommandBuffer cmd = CommandBufferPool.Get();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, ProfilingSampler.Get(URPProfileId.MainLightShadow)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构建一个绘制阴影的设置</span></span><br><span class="line">        <span class="keyword">var</span> settings = <span class="keyword">new</span> ShadowDrawingSettings(cullResults, shadowLightIndex);</span><br><span class="line">        settings.useRenderingLayerMaskTest = UniversalRenderPipeline.asset.supportsLightLayers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置每个级联的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cascadeIndex = <span class="number">0</span>; cascadeIndex &lt; m_ShadowCasterCascadesCount; ++cascadeIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            settings.splitData = m_CascadeSlices[cascadeIndex].splitData;</span><br><span class="line"></span><br><span class="line">            Vector4 shadowBias = ShadowUtils.GetShadowBias(<span class="keyword">ref</span> shadowLight, shadowLightIndex, <span class="keyword">ref</span> shadowData, m_CascadeSlices[cascadeIndex].projectionMatrix, m_CascadeSlices[cascadeIndex].resolution);</span><br><span class="line">            ShadowUtils.SetupShadowCasterConstantBuffer(cmd, <span class="keyword">ref</span> shadowLight, shadowBias);</span><br><span class="line">            CoreUtils.SetKeyword(cmd, ShaderKeywordStrings.CastingPunctualLightShadow, <span class="literal">false</span>);</span><br><span class="line">            ShadowUtils.RenderShadowSlice(cmd, <span class="keyword">ref</span> context, <span class="keyword">ref</span> m_CascadeSlices[cascadeIndex],</span><br><span class="line">                <span class="keyword">ref</span> settings, m_CascadeSlices[cascadeIndex].projectionMatrix, m_CascadeSlices[cascadeIndex].viewMatrix);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用主灯光阴影相关的宏</span></span><br><span class="line">        shadowData.isKeywordSoftShadowsEnabled = shadowLight.light.shadows == LightShadows.Soft &amp;&amp; shadowData.supportsSoftShadows;</span><br><span class="line">        CoreUtils.SetKeyword(cmd, ShaderKeywordStrings.MainLightShadows, shadowData.mainLightShadowCascadesCount == <span class="number">1</span>);</span><br><span class="line">        CoreUtils.SetKeyword(cmd, ShaderKeywordStrings.MainLightShadowCascades, shadowData.mainLightShadowCascadesCount &gt; <span class="number">1</span>);</span><br><span class="line">        CoreUtils.SetKeyword(cmd, ShaderKeywordStrings.SoftShadows, shadowData.isKeywordSoftShadowsEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置Shader常量</span></span><br><span class="line">        SetupMainLightShadowReceiverConstants(cmd, shadowLight, shadowData.supportsSoftShadows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.ExecuteCommandBuffer(cmd);</span><br><span class="line">    CommandBufferPool.Release(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupMainLightShadowReceiverConstants</span>(<span class="params">CommandBuffer cmd, VisibleLight shadowLight, <span class="keyword">bool</span> supportsSoftShadows</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Light light = shadowLight.light;</span><br><span class="line">    <span class="keyword">bool</span> softShadows = shadowLight.light.shadows == LightShadows.Soft &amp;&amp; supportsSoftShadows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cascadeCount = m_ShadowCasterCascadesCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cascadeCount; ++i)</span><br><span class="line">        m_MainLightShadowMatrices[i] = m_CascadeSlices[i].shadowTransform;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置级联阴影矩阵</span></span><br><span class="line">    Matrix4x4 noOpShadowMatrix = Matrix4x4.zero;</span><br><span class="line">    noOpShadowMatrix.m22 = (SystemInfo.usesReversedZBuffer) ? <span class="number">1.0f</span> : <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cascadeCount; i &lt;= k_MaxCascades; ++i)</span><br><span class="line">        m_MainLightShadowMatrices[i] = noOpShadowMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> invShadowAtlasWidth = <span class="number">1.0f</span> / renderTargetWidth;</span><br><span class="line">    <span class="keyword">float</span> invShadowAtlasHeight = <span class="number">1.0f</span> / renderTargetHeight;</span><br><span class="line">    <span class="keyword">float</span> invHalfShadowAtlasWidth = <span class="number">0.5f</span> * invShadowAtlasWidth;</span><br><span class="line">    <span class="keyword">float</span> invHalfShadowAtlasHeight = <span class="number">0.5f</span> * invShadowAtlasHeight;</span><br><span class="line">    <span class="keyword">float</span> softShadowsProp = softShadows ? <span class="number">1.0f</span> : <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据距离计算缩放和Bias偏移</span></span><br><span class="line">    ShadowUtils.GetScaleAndBiasForLinearDistanceFade(m_MaxShadowDistanceSq, m_CascadeBorder, <span class="keyword">out</span> <span class="keyword">float</span> shadowFadeScale, <span class="keyword">out</span> <span class="keyword">float</span> shadowFadeBias);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Shader变量（贴图纹理，世界到阴影的矩阵，阴影参数）</span></span><br><span class="line">    cmd.SetGlobalTexture(m_MainLightShadowmap.id, m_MainLightShadowmapTexture);</span><br><span class="line">    cmd.SetGlobalMatrixArray(MainLightShadowConstantBuffer._WorldToShadow, m_MainLightShadowMatrices);</span><br><span class="line">    cmd.SetGlobalVector(MainLightShadowConstantBuffer._ShadowParams,</span><br><span class="line">        <span class="keyword">new</span> Vector4(light.shadowStrength, softShadowsProp, shadowFadeScale, shadowFadeBias));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置级联参数</span></span><br><span class="line">    <span class="keyword">if</span> (m_ShadowCasterCascadesCount &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._CascadeShadowSplitSpheres0,</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">0</span>]);</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._CascadeShadowSplitSpheres1,</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">1</span>]);</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._CascadeShadowSplitSpheres2,</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">2</span>]);</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._CascadeShadowSplitSpheres3,</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">3</span>]);</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._CascadeShadowSplitSphereRadii, <span class="keyword">new</span> Vector4(</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">0</span>].w * m_CascadeSplitDistances[<span class="number">0</span>].w,</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">1</span>].w * m_CascadeSplitDistances[<span class="number">1</span>].w,</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">2</span>].w * m_CascadeSplitDistances[<span class="number">2</span>].w,</span><br><span class="line">            m_CascadeSplitDistances[<span class="number">3</span>].w * m_CascadeSplitDistances[<span class="number">3</span>].w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 软阴影参数</span></span><br><span class="line">    <span class="keyword">if</span> (supportsSoftShadows)</span><br><span class="line">    &#123;</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._ShadowOffset0,</span><br><span class="line">            <span class="keyword">new</span> Vector4(-invHalfShadowAtlasWidth, -invHalfShadowAtlasHeight, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._ShadowOffset1,</span><br><span class="line">            <span class="keyword">new</span> Vector4(invHalfShadowAtlasWidth, -invHalfShadowAtlasHeight, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._ShadowOffset2,</span><br><span class="line">            <span class="keyword">new</span> Vector4(-invHalfShadowAtlasWidth, invHalfShadowAtlasHeight, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._ShadowOffset3,</span><br><span class="line">            <span class="keyword">new</span> Vector4(invHalfShadowAtlasWidth, invHalfShadowAtlasHeight, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">        cmd.SetGlobalVector(MainLightShadowConstantBuffer._ShadowmapSize, <span class="keyword">new</span> Vector4(invShadowAtlasWidth,</span><br><span class="line">            invShadowAtlasHeight,</span><br><span class="line">            renderTargetWidth, renderTargetHeight));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="drawobjectspass-绘制对象pass">DrawObjectsPass 绘制对象Pass</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DrawObjectsPass</span>(<span class="params"><span class="keyword">string</span> profilerTag, ShaderTagId[] shaderTagIds, <span class="keyword">bool</span> opaque, RenderPassEvent evt, RenderQueueRange renderQueueRange, LayerMask layerMask, StencilState stencilState, <span class="keyword">int</span> stencilReference</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">base</span>.profilingSampler = <span class="keyword">new</span> ProfilingSampler(<span class="keyword">nameof</span>(DrawObjectsPass));</span><br><span class="line"></span><br><span class="line">    m_ProfilerTag = profilerTag;</span><br><span class="line">    m_ProfilingSampler = <span class="keyword">new</span> ProfilingSampler(profilerTag);</span><br><span class="line">    <span class="keyword">foreach</span> (ShaderTagId sid <span class="keyword">in</span> shaderTagIds)</span><br><span class="line">        m_ShaderTagIdList.Add(sid);</span><br><span class="line">    renderPassEvent = evt;</span><br><span class="line">    m_FilteringSettings = <span class="keyword">new</span> FilteringSettings(renderQueueRange, layerMask);</span><br><span class="line">    m_RenderStateBlock = <span class="keyword">new</span> RenderStateBlock(RenderStateMask.Nothing);</span><br><span class="line">    m_IsOpaque = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stencilState.enabled)</span><br><span class="line">    &#123;</span><br><span class="line">        m_RenderStateBlock.stencilReference = stencilReference;</span><br><span class="line">        m_RenderStateBlock.mask = RenderStateMask.Stencil;</span><br><span class="line">        m_RenderStateBlock.stencilState = stencilState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCameraSetup</span>(<span class="params">CommandBuffer cmd, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置深度</span></span><br><span class="line">    <span class="keyword">if</span> (renderingData.cameraData.renderer.useDepthPriming &amp;&amp; m_IsOpaque &amp;&amp; (renderingData.cameraData.renderType == CameraRenderType.Base || renderingData.cameraData.clearDepth))</span><br><span class="line">    &#123;</span><br><span class="line">        m_RenderStateBlock.depthState = <span class="keyword">new</span> DepthState(<span class="literal">false</span>, CompareFunction.Equal);</span><br><span class="line">        m_RenderStateBlock.mask |= RenderStateMask.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_RenderStateBlock.depthState.compareFunction == CompareFunction.Equal)</span><br><span class="line">    &#123;</span><br><span class="line">        m_RenderStateBlock.depthState = <span class="keyword">new</span> DepthState(<span class="literal">true</span>, CompareFunction.LessEqual);</span><br><span class="line">        m_RenderStateBlock.mask |= RenderStateMask.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CommandBuffer cmd = CommandBufferPool.Get();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, m_ProfilingSampler))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 包含各种设置的全局渲染通道数据。</span></span><br><span class="line">        <span class="comment">// x,y,z are currently unused</span></span><br><span class="line">        <span class="comment">// w 用于了解对象是不透明的 (1) 还是 alpha 混合的 (0)</span></span><br><span class="line">        Vector4 drawObjectPassData = <span class="keyword">new</span> Vector4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, (m_IsOpaque) ? <span class="number">1.0f</span> : <span class="number">0.0f</span>);</span><br><span class="line">        cmd.SetGlobalVector(s_DrawObjectPassDataPropID, drawObjectPassData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RT反转符号</span></span><br><span class="line">        <span class="keyword">float</span> flipSign = (renderingData.cameraData.IsCameraProjectionMatrixFlipped()) ? <span class="number">-1.0f</span> : <span class="number">1.0f</span>;</span><br><span class="line">        Vector4 scaleBias = (flipSign &lt; <span class="number">0.0f</span>)</span><br><span class="line">            ? <span class="keyword">new</span> Vector4(flipSign, <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">            : <span class="keyword">new</span> Vector4(flipSign, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        cmd.SetGlobalVector(ShaderPropertyId.scaleBiasRt, scaleBias);</span><br><span class="line"></span><br><span class="line">        context.ExecuteCommandBuffer(cmd);</span><br><span class="line">        cmd.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取对象的排序规则</span></span><br><span class="line">        Camera camera = renderingData.cameraData.camera;</span><br><span class="line">        <span class="keyword">var</span> sortFlags = (m_IsOpaque) ? renderingData.cameraData.defaultOpaqueSortFlags : SortingCriteria.CommonTransparent;</span><br><span class="line">        <span class="keyword">if</span> (renderingData.cameraData.renderer.useDepthPriming &amp;&amp; m_IsOpaque &amp;&amp; (renderingData.cameraData.renderType == CameraRenderType.Base || renderingData.cameraData.clearDepth))</span><br><span class="line">            sortFlags = SortingCriteria.SortingLayer | SortingCriteria.RenderQueue | SortingCriteria.OptimizeStateChanges | SortingCriteria.CanvasOrder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> filterSettings = m_FilteringSettings;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="comment">// 预览相机的时候强制渲染所有</span></span><br><span class="line">        <span class="keyword">if</span> (renderingData.cameraData.isPreviewCamera)</span><br><span class="line">        &#123;</span><br><span class="line">            filterSettings.layerMask = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用基类的CreateDrawingSettings函数创建绘制设置对象（用于描述哪些对象使用哪些Shader的Pass去绘制，以及渲染对象的排序规则）</span></span><br><span class="line">        DrawingSettings drawSettings = CreateDrawingSettings(m_ShaderTagIdList, <span class="keyword">ref</span> renderingData, sortFlags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调试绘制</span></span><br><span class="line">        <span class="keyword">var</span> activeDebugHandler = GetActiveDebugHandler(renderingData);</span><br><span class="line">        <span class="keyword">if</span> (activeDebugHandler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            activeDebugHandler.DrawWithDebugRenderState(context, cmd, <span class="keyword">ref</span> renderingData, <span class="keyword">ref</span> drawSettings, <span class="keyword">ref</span> filterSettings, <span class="keyword">ref</span> m_RenderStateBlock,</span><br><span class="line">                (ScriptableRenderContext ctx, <span class="keyword">ref</span> RenderingData data, <span class="keyword">ref</span> DrawingSettings ds, <span class="keyword">ref</span> FilteringSettings fs, <span class="keyword">ref</span> RenderStateBlock rsb) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    ctx.DrawRenderers(data.cullResults, <span class="keyword">ref</span> ds, <span class="keyword">ref</span> fs, <span class="keyword">ref</span> rsb);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 告诉Unity底层绘制对象</span></span><br><span class="line">            context.DrawRenderers(renderingData.cullResults, <span class="keyword">ref</span> drawSettings, <span class="keyword">ref</span> filterSettings, <span class="keyword">ref</span> m_RenderStateBlock);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有匹配任意着色器Pass则使用错误Shader进行渲染</span></span><br><span class="line">            RenderingUtils.RenderObjectsWithError(context, <span class="keyword">ref</span> renderingData.cullResults, camera, filterSettings, SortingCriteria.None);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    context.ExecuteCommandBuffer(cmd);</span><br><span class="line">    CommandBufferPool.Release(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="drawskyboxpass-绘制天空盒pass">DrawSkyboxPass
绘制天空盒Pass</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CameraData cameraData = renderingData.cameraData;</span><br><span class="line">    Camera camera = cameraData.camera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> activeDebugHandler = GetActiveDebugHandler(renderingData);</span><br><span class="line">    <span class="keyword">if</span> (activeDebugHandler != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeDebugHandler.IsScreenClearNeeded)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除VR和XR的代码</span></span><br><span class="line">    <span class="comment">// 告诉Unity绘制天空盒子</span></span><br><span class="line">    context.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Rendering/" rel="tag"><i class="fa fa-tag"></i> Rendering</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2022/06/28/Unity/Graphics/ShaderLab/" rel="next" title="Unity ShaderLab">
                  <i class="fa fa-chevron-left"></i> Unity ShaderLab
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2023/02/14/Unity/Graphics/Batching/" rel="prev" title="Static Batching, Dynamic Batching, GUP Instancing和SRP Batcher">
                  Static Batching, Dynamic Batching, GUP Instancing和SRP Batcher <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#应用阶段"><span class="nav-number">1.</span> <span class="nav-text">应用阶段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#urp渲染管线"><span class="nav-number">2.</span> <span class="nav-text">URP渲染管线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#renderpipelinemanager"><span class="nav-number">2.1.</span> <span class="nav-text">RenderPipelineManager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#renderpipeline"><span class="nav-number">2.2.</span> <span class="nav-text">RenderPipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#universalrenderpipeline"><span class="nav-number">2.3.</span> <span class="nav-text">UniversalRenderPipeline</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#urp渲染器"><span class="nav-number">3.</span> <span class="nav-text">URP渲染器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scriptablerenderer"><span class="nav-number">3.1.</span> <span class="nav-text">ScriptableRenderer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#universalrenderer"><span class="nav-number">3.2.</span> <span class="nav-text">UniversalRenderer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#urp中的pass"><span class="nav-number">4.</span> <span class="nav-text">URP中的Pass</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scriptablerenderpass"><span class="nav-number">4.1.</span> <span class="nav-text">ScriptableRenderPass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心pass"><span class="nav-number">4.2.</span> <span class="nav-text">核心Pass</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#depthonlypass-深度pass"><span class="nav-number">4.2.1.</span> <span class="nav-text">DepthOnlyPass 深度Pass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mainlightshadowcasterpass-主灯光阴影投射pass"><span class="nav-number">4.2.2.</span> <span class="nav-text">MainLightShadowCasterPass
主灯光阴影投射Pass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawobjectspass-绘制对象pass"><span class="nav-number">4.2.3.</span> <span class="nav-text">DrawObjectsPass 绘制对象Pass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawskyboxpass-绘制天空盒pass"><span class="nav-number">4.2.4.</span> <span class="nav-text">DrawSkyboxPass
绘制天空盒Pass</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张卫"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">张卫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/zw514159799" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;zw514159799" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Divad1111?tab=repositories" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Divad1111?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/qilezaitu" title="博客园 &amp;rarr; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;qilezaitu" rel="noopener" target="_blank"><i class="fa fa-fw fa-cnblogs"></i>博客园</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张卫</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">542k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:13</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

  

</body>
</html>
