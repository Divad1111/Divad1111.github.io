<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="文件结构   Lua文件结构  提供外部使用的头文件  lua.h 定义了Lua的核心API。 lauxlib.h 定义了Lua的辅助API，此文件中定义的函数，是对lua.h中函数的简单封装，方便使用。 lualib.h 定义了Lua的标准库（coroutine， table, io, os, string, utf8, math, debug, package）。 luaconf.h 定义编译">
<meta property="og:type" content="article">
<meta property="og:title" content="Lua虚拟机源码阅读">
<meta property="og:url" content="http://yoursite.com/2021/11/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/Lua%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html">
<meta property="og:site_name" content="张卫的博客">
<meta property="og:description" content="文件结构   Lua文件结构  提供外部使用的头文件  lua.h 定义了Lua的核心API。 lauxlib.h 定义了Lua的辅助API，此文件中定义的函数，是对lua.h中函数的简单封装，方便使用。 lualib.h 定义了Lua的标准库（coroutine， table, io, os, string, utf8, math, debug, package）。 luaconf.h 定义编译">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/lua/lua_file_struct.png">
<meta property="article:published_time" content="2021-11-29T04:00:02.000Z">
<meta property="article:modified_time" content="2025-04-26T11:06:24.134Z">
<meta property="article:author" content="张卫">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/lua/lua_file_struct.png">

<link rel="canonical" href="http://yoursite.com/2021/11/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/Lua%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Lua虚拟机源码阅读 | 张卫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张卫的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Done is better than perfect</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/Lua%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="张卫">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张卫的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lua虚拟机源码阅读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-29 12:00:02" itemprop="dateCreated datePublished" datetime="2021-11-29T12:00:02+08:00">2021-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-26 19:06:24" itemprop="dateModified" datetime="2025-04-26T19:06:24+08:00">2025-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="文件结构">文件结构</h1>
<figure>
<img src="/images/lua/lua_file_struct.png" alt="Lua文件结构" />
<figcaption aria-hidden="true">Lua文件结构</figcaption>
</figure>
<h2 id="提供外部使用的头文件">提供外部使用的头文件</h2>
<ul>
<li><strong>lua.h</strong> 定义了Lua的核心API。</li>
<li><strong>lauxlib.h</strong>
定义了Lua的辅助API，此文件中定义的函数，是对lua.h中函数的简单封装，方便使用。</li>
<li><strong>lualib.h</strong> 定义了Lua的标准库（coroutine， table, io,
os, string, utf8, math, debug, package）。</li>
<li><strong>luaconf.h</strong>
定义编译相关的宏，主要用于区分别不同平台的特性以及一些其他编译特性。</li>
</ul>
<h2 id="核心代码">核心代码</h2>
<p>Lua的核心代码主要分为以下几个模块：</p>
<p><strong>核心API</strong></p>
<ul>
<li><strong>lapi.h</strong>
定义了几个栈的操作宏（api_incr_top：栈顶加一，
adjustresults：调节栈顶以容纳更多的返回值，
api_checknelems：检查栈中是否有对应的栈空间）。</li>
<li><strong>lapi.c</strong> lua.h头文件中定义核心API的实现。</li>
<li><strong>lctype.h</strong>
C语言的标准字符检查函数头文件，主要检查单个字符的类型，增加了EOZ，允许传入-1（EOZ）进行检测。</li>
<li><strong>lctype.c</strong> 定义了符号表。</li>
<li><strong>ldo.c</strong> 处理Lua的栈和调用结构。</li>
<li><strong>lfunc.c</strong>
定义了用于操纵函数原型和闭包的辅助函数。</li>
<li><strong>llimits.c</strong> 定义了一些基础的类型和安装依赖信息。</li>
<li><strong>lmen.c</strong> 内存管理接口。</li>
<li><strong>lobject.h</strong> Lua中的对象类型定义。</li>
<li><strong>lobject.c</strong> 对象上的一些操作。</li>
<li><strong>lstate.h</strong>
定义了lua_State相关的结构，这是Lua的核心结构。</li>
<li><strong>lstate.c</strong> lstate.h中定义结构的相关操作。</li>
<li><strong>lstring.c</strong>
Lua字符串表，处理和缓存Lua中使用的字符串。</li>
<li><strong>ltable.c</strong> 定义了Lua中Tale相关的操作。</li>
<li><strong>ltm.c</strong> 元表相关的定义和操作。</li>
<li><strong>ldump.c</strong> 将Lua函数转储为预编译块。</li>
<li><strong>lundump.c</strong> 加载预编译的Lua块。</li>
<li><strong>lzio.c</strong> 定义了一个buffer流，用于读取数据。</li>
</ul>
<p><strong>GC管理</strong></p>
<ul>
<li><strong>lgc.c</strong> 垃圾回收器</li>
</ul>
<p><strong>词法，语法和语义分析器</strong></p>
<ul>
<li><strong>llex.c</strong> 词法分析器。</li>
<li><strong>lparser.h</strong> 语法和语义分析器。</li>
</ul>
<p><strong>Lua虚拟机（解释器）</strong></p>
<ul>
<li><strong>lopcodes.h</strong> 定义了Lua虚拟机的操作码（OP_MOVE，
OP_LOADI等）跟汇编的MOV指令类型，虚拟机就是用来执行这些指令的。</li>
<li><strong>lopnames.h</strong> 定义了操作码对应的名字。</li>
<li><strong>ljumptab.h</strong>
定义了Lua解释器跳转表相关的宏（vmdispatch, vmcase, vmbreak）。</li>
<li><strong>lvm.c</strong> Lua的虚拟机用于执行opcode。</li>
</ul>
<h2 id="调试">调试</h2>
<ul>
<li><strong>ldebug.c</strong> 获取调试信息（函数调用,
行号信息等）。</li>
</ul>
<a id="more"></a>
<h2 id="标准库代码">标准库代码</h2>
<ul>
<li><strong>lauxlib.c</strong>
实现了Lua的辅助API，此文件中定义的函数，是对lua.h中函数的简单封装，方便使用。</li>
<li><strong>lbaselib.c</strong> 实现了Lua中使用的一些全局函数（assert,
dofile, error, ipairs, pairs, print, getmetatable, setmetatable, xpcall,
tostring, type等）。</li>
<li><strong>lcorolib.c</strong> 协程(coroutine)。</li>
<li><strong>ldblib.c</strong> 调试库(debug)。</li>
<li><strong>liolib</strong> 标准IO操作（io）。</li>
<li><strong>lmathlib.c</strong> 数学库(math)。</li>
<li><strong>loadlib.c</strong> 加载库（package）。</li>
<li><strong>loslib.c</strong> 系统库（os）。</li>
<li><strong>lstrlib.c</strong> 字符串库（string）。</li>
<li><strong>ltablib.c</strong> 表（table）。</li>
<li><strong>lutf8lib.c</strong> utf8库（utf8）。</li>
<li><strong>linit.c</strong> 注册所有的标注库到Lua,
核心函数luaL_openlibs，会遍历注册所有的标准库。</li>
</ul>
<h2 id="解释器和编译器">解释器和编译器</h2>
<ul>
<li><strong>lua.c</strong> 通过上面的API构建的一个Lua解释器。</li>
<li><strong>luac.c</strong>
Lua的编译器，主要用于将Lua源文件编译成二进制格式。</li>
</ul>
<h1 id="核心代码-1">核心代码</h1>
<h2 id="核心结构">核心结构</h2>
<p><strong>global_State</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的State, 被所用State共享的，用于记录一些全局数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_State</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  lua_Alloc frealloc;   <span class="comment">// 内存分配函数,现在是使用的realloc(有连续空间，扩展内存是不会进行拷贝数的)</span></span><br><span class="line">  <span class="keyword">void</span> *ud;             <span class="comment">// frealloc 的辅助数据，现在没有用，如果使用其他的内存分配函数可以使用这个预留的字段，在lauxlib.c中的l_alloc函数中是未使用的</span></span><br><span class="line">  l_mem totalbytes;     <span class="comment">// 当前分配的总内存（单位：Byte）</span></span><br><span class="line">  l_mem GCdebt;         <span class="comment">// 垃圾收集器还未归还的内存（单位：Byte）</span></span><br><span class="line">  lu_mem GCestimate;    <span class="comment">// 正在使用的非垃圾内存的预估值（单位：Byte）</span></span><br><span class="line">  lu_mem lastatomic;    <span class="comment">// 代垃圾收集的一个标志</span></span><br><span class="line">  stringtable strt;     <span class="comment">// 用于存储Lua中使用的短字符（长度小于等于40，通过宏LUAI_MAXSHORTLEN定义的）串表</span></span><br><span class="line">  TValue l_registry;    <span class="comment">// 注册表（Table类型），默认存储了全局主线程的State和全局Table，主要用来存储用户数据的元表</span></span><br><span class="line">  TValue nilvalue;      <span class="comment">// 定义的全局nil值</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed;    <span class="comment">// 随机数种子</span></span><br><span class="line">  <span class="comment">// 垃圾收集相关</span></span><br><span class="line">  lu_byte currentwhite;</span><br><span class="line">  lu_byte gcstate;      <span class="comment">// 垃圾收集器状态(GCSpropagate, GCSenteratomic, GCSatomic, GCSswpallgc, GCSswpfinobj, GCSswptobefnz, GCSswpend, GCScallfin, GCSpause)</span></span><br><span class="line">  lu_byte gckind;       <span class="comment">// 当前运行的GC类型（KGC_INC（增量GC）， KGC_GEN（分代GC））</span></span><br><span class="line">  lu_byte gcstopem;     <span class="comment">// 是否停止紧急收集</span></span><br><span class="line">  lu_byte genminormul;  <span class="comment">// 次代收集倍数</span></span><br><span class="line">  lu_byte genmajormul;  <span class="comment">// 主代收集倍数</span></span><br><span class="line">  lu_byte gcrunning;    <span class="comment">// GC是否在运行</span></span><br><span class="line">  lu_byte gcemergency;  <span class="comment">// 是紧急收集</span></span><br><span class="line">  lu_byte gcpause;      <span class="comment">// 两个连续GC的暂停阈值</span></span><br><span class="line">  lu_byte gcstepmul;    <span class="comment">// GC的步长，用于控制GC的速度</span></span><br><span class="line">  lu_byte gcstepsize;   <span class="comment">// 单步长收集的的大小</span></span><br><span class="line">  GCObject *allgc;      <span class="comment">// 所有可收集对象的列表</span></span><br><span class="line">  GCObject **sweepgc;   <span class="comment">// 当前扫到的位置</span></span><br><span class="line">  GCObject *finobj;     <span class="comment">// 进入了析构的对象列表（还未真正的释放）</span></span><br><span class="line">  GCObject *gray;       <span class="comment">// 灰色对象列表</span></span><br><span class="line">  GCObject *grayagain;  <span class="comment">/* list of objects to be traversed atomically */</span></span><br><span class="line">  GCObject *weak;       <span class="comment">// 弱值弱引用表</span></span><br><span class="line">  GCObject *ephemeron;  <span class="comment">// 弱key引用表</span></span><br><span class="line">  GCObject *allweak;    <span class="comment">// 所有的若引用</span></span><br><span class="line">  GCObject *tobefnz;    <span class="comment">// 要GC的userdata列表</span></span><br><span class="line">  GCObject *fixedgc;    <span class="comment">// 不被GC回收的对象列表</span></span><br><span class="line">  <span class="comment">// 分代收集器相关的字段</span></span><br><span class="line">  GCObject *survival;   <span class="comment">// 存活了一个GC周期的对象头</span></span><br><span class="line">  GCObject *old1;       <span class="comment">/* start of old1 objects */</span></span><br><span class="line">  GCObject *reallyold;  <span class="comment">/* objects more than one cycle old ("really old") */</span></span><br><span class="line">  GCObject *firstold1;  <span class="comment">/* first OLD1 object in the list (if any) */</span></span><br><span class="line">  GCObject *finobjsur;  <span class="comment">/* list of survival objects with finalizers */</span></span><br><span class="line">  GCObject *finobjold1;  <span class="comment">/* list of old1 objects with finalizers */</span></span><br><span class="line">  GCObject *finobjrold;  <span class="comment">/* list of really old objects with finalizers */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">twups</span>;</span> <span class="comment">// 开放了上值的现场列表</span></span><br><span class="line">  lua_CFunction panic;  <span class="comment">// 为保护模式下发生异常时调用的函数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">mainthread</span>;</span> <span class="comment">// 主线程的State对象</span></span><br><span class="line">  TString *memerrmsg;   <span class="comment">// 缓存的一个内存分配的错误消息</span></span><br><span class="line">  TString *tmname[TM_N];<span class="comment">// 元方法名字（__index, __len等）</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">mt</span>[<span class="title">LUA_NUMTAGS</span>];</span>  基础类型的元表()</span><br><span class="line">  TString *strcache[STRCACHE_N][STRCACHE_M];  <span class="comment">// 字符串缓存，避免在使用一些字符串时频繁创建</span></span><br><span class="line">  lua_WarnFunction warnf; <span class="comment">// 警告函数</span></span><br><span class="line">  <span class="keyword">void</span> *ud_warn;          <span class="comment">// 警告函数的辅助数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>lua_State</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个线程的State</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  CommonHeader;       <span class="comment">// 公共头(所有可回收对象都有)宏struct GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line">  lu_byte status;     <span class="comment">// 线程状态LUA_OK，LUA_YIELD，LUA_ERRRUN，LUA_ERRSYNTAX，LUA_ERRMEM，UA_ERRERR</span></span><br><span class="line">  lu_byte allowhook;  <span class="comment">// 是否允许hook</span></span><br><span class="line">  <span class="keyword">unsigned</span> short nci; <span class="comment">// 调用信息（CallInfo）的数量</span></span><br><span class="line">  StkId top;          <span class="comment">// 当前可以使用的栈值（也就是栈顶的上一个值）StkId（ typedef StackValue *StkId）</span></span><br><span class="line">  global_State *l_G;  <span class="comment">// 关联的全局State</span></span><br><span class="line">  CallInfo *ci;       <span class="comment">// 当前函数的调用信息</span></span><br><span class="line">  StkId stack_last;   <span class="comment">// 栈底的下一个栈值</span></span><br><span class="line">  StkId <span class="built_in">stack</span>;        <span class="comment">// 栈</span></span><br><span class="line">  UpVal *openupval;   <span class="comment">// 在栈中的开放上值（open upvalues）列表</span></span><br><span class="line">  StkId tbclist;      <span class="comment">// to-be-closed变量列表</span></span><br><span class="line">  GCObject *gclist;   <span class="comment">// GC对象列表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">twups</span>;</span>        <span class="comment">// 使用了开放上值（open upvalues）的线程列表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_longjmp</span> *<span class="title">errorJmp</span>;</span>   <span class="comment">//保存setjump和longjump上下问环境，用于错误恢复</span></span><br><span class="line">  CallInfo base_ci;       <span class="comment">// 第一级调用信息（c 调用 Lua）</span></span><br><span class="line">  <span class="keyword">volatile</span> lua_Hook hook; <span class="comment">// 钩子（hook）函数指针</span></span><br><span class="line">  <span class="keyword">ptrdiff_t</span> errfunc;      <span class="comment">// 当前的错误处理函数的栈索引</span></span><br><span class="line">  l_uint32 nCcalls;       <span class="comment">// 内嵌的调用数量（non-yieldable | C）</span></span><br><span class="line">  <span class="keyword">int</span> oldpc;              <span class="comment">// 记录最后一次PC（指令）指针的位置</span></span><br><span class="line">  <span class="keyword">int</span> basehookcount;      <span class="comment">// hook的基础计数</span></span><br><span class="line">  <span class="keyword">int</span> hookcount;          <span class="comment">// 当前的hook计数</span></span><br><span class="line">  <span class="keyword">volatile</span> l_signalT hookmask; <span class="comment">// hook的掩码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>CallInfo</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CallInfo</span> &#123;</span></span><br><span class="line">  StkId func;  <span class="comment">// 函数在栈中的位置（一个StackValue的地址）</span></span><br><span class="line">  StkId	top;   <span class="comment">// 这个函数的栈顶位置(栈顶的地址)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CallInfo</span> *<span class="title">previous</span>, *<span class="title">next</span>;</span>  <span class="comment">// 调用链的前后指针</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">      <span class="keyword">const</span> Instruction *savedpc; <span class="comment">// 虚拟机的指令列表</span></span><br><span class="line">      <span class="keyword">volatile</span> l_signalT trap;    <span class="comment">// </span></span><br><span class="line">      <span class="keyword">int</span> nextraargs;             <span class="comment">// 变长函数的额外参数个数（...）</span></span><br><span class="line">    &#125; l; <span class="comment">// Lua函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      lua_KFunction k;  <span class="comment">/* continuation in case of yields */</span></span><br><span class="line">      <span class="keyword">ptrdiff_t</span> old_errfunc;</span><br><span class="line">      lua_KContext ctx;  <span class="comment">/* context info. in case of yields */</span></span><br><span class="line">    &#125; c; <span class="comment">// c函数</span></span><br><span class="line">  &#125; u; </span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> funcidx;  当前调用函数在栈中的索引（func的地址-L.<span class="built_in">stack</span>的地址求出函数在栈中的索引），仅用于在保护模式下调用的c函数</span><br><span class="line">    <span class="keyword">int</span> nyield;   <span class="comment">// yielded的值的数量</span></span><br><span class="line">    <span class="keyword">int</span> nres;     <span class="comment">// 返回的值的数量， 字段“nres”仅在从C函数返回时关闭tbc变量时使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>   </span><br><span class="line">      <span class="keyword">unsigned</span> short ftransfer;  首个传递值的偏移</span><br><span class="line">      <span class="keyword">unsigned</span> short ntransfer;  传递值的数量</span><br><span class="line">    &#125; transferinfo;</span><br><span class="line">  &#125; u2; <span class="comment">// 从hook调用或返回时传递的值的信息</span></span><br><span class="line">  short nresults;  从这个函数返回的期望的结果数量</span><br><span class="line">  <span class="keyword">unsigned</span> short callstatus; <span class="comment">// 调用的状态（CIST_OAH:运行hook, CIST_C:函数调用，等）</span></span><br><span class="line">&#125; CallInfo;</span><br></pre></td></tr></table></figure>
<p><strong>TString</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;       <span class="comment">// 所有的GC对象都必须包含此宏 #define CommonHeader	struct GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line">  lu_byte extra;      <span class="comment">// 保留关键字（and, break, do 等）的枚举值, 此字段有非0值，表示是关键字。</span></span><br><span class="line">  lu_byte shrlen;     <span class="comment">// 短字符串（小于40）长度，短字符串会被缓存到global_State.strt中</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;  <span class="comment">// 长字符串对应的hash值</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> lnglen;    <span class="comment">// 长字符串的长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">// 链接的字符串列表</span></span><br><span class="line">  &#125; u;</span><br><span class="line">  <span class="keyword">char</span> contents[<span class="number">1</span>];   <span class="comment">// 字符串本身的内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Closure</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包的公共头</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClosureHeader \</span></span><br><span class="line">	CommonHeader; lu_byte nupvalues; GCObject *gclist</span><br><span class="line"></span><br><span class="line"><span class="comment">// C闭包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CClosure</span> &#123;</span></span><br><span class="line">  ClosureHeader;</span><br><span class="line">  lua_CFunction f;  <span class="comment">// C函数指针</span></span><br><span class="line">  TValue upvalue[<span class="number">1</span>];<span class="comment">// 上值列表 </span></span><br><span class="line">&#125; CClosure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lua闭包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> &#123;</span></span><br><span class="line">  ClosureHeader;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> *<span class="title">p</span>;</span> <span class="comment">// Lua函数原型</span></span><br><span class="line">  UpVal *upvals[<span class="number">1</span>];<span class="comment">// 上值列表</span></span><br><span class="line">&#125; LClosure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含C和Lua的闭包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Closure &#123;</span><br><span class="line">  CClosure c;</span><br><span class="line">  LClosure l;</span><br><span class="line">&#125; Closure;</span><br></pre></td></tr></table></figure>
<p><strong>Proto</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> &#123;</span></span><br><span class="line">  CommonHeader;         <span class="comment">// 所有GC独享都有的</span></span><br><span class="line">  lu_byte numparams;    <span class="comment">// 函数的固定参数数量</span></span><br><span class="line">  lu_byte is_vararg;    <span class="comment">// 有变成参数吗</span></span><br><span class="line">  lu_byte maxstacksize; <span class="comment">// 这个函数需要的寄存器数量（也就是有多少参数要压栈）</span></span><br><span class="line">  <span class="keyword">int</span> sizeupvalues;     <span class="comment">// 函数的上值数量</span></span><br><span class="line">  <span class="keyword">int</span> sizek;            <span class="comment">// 函数使用的常量数量</span></span><br><span class="line">  <span class="keyword">int</span> sizecode;         <span class="comment">// 指令的数量</span></span><br><span class="line">  <span class="keyword">int</span> sizelineinfo;     <span class="comment">// 行号的数量</span></span><br><span class="line">  <span class="keyword">int</span> sizep;            <span class="comment">// 函数的子函数(内部函数)的数量</span></span><br><span class="line">  <span class="keyword">int</span> sizelocvars;      <span class="comment">// 本地变量的数量</span></span><br><span class="line">  <span class="keyword">int</span> sizeabslineinfo;  <span class="comment">// 每条指令对应的行号信息</span></span><br><span class="line">  <span class="keyword">int</span> linedefined;      <span class="comment">// 函数的开始行， 用于调试</span></span><br><span class="line">  <span class="keyword">int</span> lastlinedefined;  <span class="comment">// 函数的结束行， 用于调试</span></span><br><span class="line">  TValue *k;            <span class="comment">// 函数使用的常量值</span></span><br><span class="line">  Instruction *code;    <span class="comment">// 函数的指令列表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> **<span class="title">p</span>;</span>     <span class="comment">// 函数的内部函数原型列表</span></span><br><span class="line">  Upvaldesc *upvalues;  <span class="comment">// 函数的上值信息</span></span><br><span class="line">  ls_byte *lineinfo;    <span class="comment">// 函数源码的行列表， 用于调试</span></span><br><span class="line">  AbsLineInfo *abslineinfo;  <span class="comment">// 函数指令的行列表</span></span><br><span class="line">  LocVar *locvars;      <span class="comment">// 本地变量， 用于调试</span></span><br><span class="line">  TString  *source;     <span class="comment">// 函数源码， 用于调试</span></span><br><span class="line">  GCObject *gclist;     <span class="comment">// </span></span><br><span class="line">&#125; Proto;</span><br></pre></td></tr></table></figure>
<p><strong>Upvaldesc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型的上值描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Upvaldesc</span> &#123;</span></span><br><span class="line">  TString *name;    <span class="comment">// 上值得名字，用于调试</span></span><br><span class="line">  lu_byte instack;  <span class="comment">// 是否在栈上</span></span><br><span class="line">  lu_byte idx;      <span class="comment">// 在栈上或外部函数列表的索引</span></span><br><span class="line">  lu_byte kind;     <span class="comment">// 类型（0:常规， 1：常量， 2：to-be-closed（超出作用域会调用__close原方法，local t&lt;clost&gt; = xx 5.4新增的）, 3:编译时常量）</span></span><br><span class="line">&#125; Upvaldesc;</span><br></pre></td></tr></table></figure>
<p><strong>UpVal</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包的上值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte tbc;  <span class="comment">// 是否是to-be-closed变量</span></span><br><span class="line">  TValue *v;    <span class="comment">// 指向堆栈或其自身的值</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> *<span class="title">next</span>;</span> 列表的Next指针</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> **<span class="title">previous</span>;</span> 列表的Previous指针</span><br><span class="line">    &#125; <span class="built_in">open</span>; <span class="comment">// open 的上值</span></span><br><span class="line">    TValue value;  closed的上值</span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; UpVal;</span><br></pre></td></tr></table></figure>
<p><strong>Udata</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// userdata的头，分配的内存区域放在此结构的后面</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Udata</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  <span class="keyword">unsigned</span> short nuvalue;   <span class="comment">// 用户值的数量</span></span><br><span class="line">  <span class="keyword">size_t</span> len;               <span class="comment">// bytes大小</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span>  <span class="comment">// userdata的元表</span></span><br><span class="line">  GCObject *gclist;         </span><br><span class="line">  UValue uv[<span class="number">1</span>];             <span class="comment">// 用户值</span></span><br><span class="line">&#125; Udata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是TValue，只是为了保证最大化的字节对齐在里面放了所有类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUAI_MAXALIGN  lua_Number n; double u; void *s; lua_Integer i; long l</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> UValue &#123;</span><br><span class="line">  TValue uv;</span><br><span class="line">  LUAI_MAXALIGN;   <span class="comment">/* ensures maximum alignment for udata bytes */</span></span><br><span class="line">&#125; UValue;</span><br></pre></td></tr></table></figure>
<p><strong>Table</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lua的核心数据结构，我们常用的表的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;        <span class="comment">// 表的标志位</span></span><br><span class="line">  lu_byte lsizenode;    <span class="comment">// 表的Hash部分的大小（2的lsizenode次幂），lsizenode存的是2的指数部分的值</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> alimit;  <span class="comment">// 表的数组部分的大小</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;        <span class="comment">// 数组部分的开始地址</span></span><br><span class="line">  Node *node;           <span class="comment">// Hash部分的开始地址</span></span><br><span class="line">  Node *lastfree;       <span class="comment">// 用于记录最后一个空闲节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span> <span class="comment">// 元表</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash表使用的节点，为什么Key的类型和值不能直接使用TValue? 因为字节对齐的原因分开定义能减少NodeKey的内存占用大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Node &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">NodeKey</span> &#123;</span></span><br><span class="line">    TValuefields;   <span class="comment">// 值（带类型的Value）#define TValuefields	Value value_; lu_byte tt_</span></span><br><span class="line">    lu_byte key_tt; <span class="comment">// Key的类型 </span></span><br><span class="line">    <span class="keyword">int</span> next;       <span class="comment">// Hash冲突时，用于表示下一个Key</span></span><br><span class="line">    Value key_val;  <span class="comment">// Key的值</span></span><br><span class="line">  &#125; u;</span><br><span class="line">  TValue i_val;     <span class="comment">// 直接访问节点的TValue（只是为了方便访问值）</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>
<p>flags字段说明：</p>
<p>7 位
表示alimit字段是否代表了数组的真实大小（0:是，1:不是），否则数组的真实大小是不小于alimit的2的整数次幂。
0-6 位 表示是否有TM_INDEX, TM_NEWINDEX, TM_GC, TM_MODE, TM_LEN,
TM_EQ(0:有，1：没有)主要用于快速检测这几个常用的元方法是否存在。</p>
<p>Table同时使用数组和Hash表的结构，当使用的key是整形且不大于alimit时，Lua会使用array字段，当大于alimit时，则会转换成hash表的方式来。当数组或Hash表的大小需要扩容，应尽量避免这些没有避免的性能消耗。解决Hash冲突的方式是结合了开放寻址和链表的形式。</p>
<p><strong>TValue</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lua中的值（所有类型都是用的此结构）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Value &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> *<span class="title">gc</span>;</span>  <span class="comment">// 可收集(GC)对象</span></span><br><span class="line">  <span class="keyword">void</span> *p;              <span class="comment">// 轻量级userdata</span></span><br><span class="line">  lua_CFunction f;      <span class="comment">// 轻量级c函数</span></span><br><span class="line">  lua_Integer i;        <span class="comment">// 整型</span></span><br><span class="line">  lua_Number n;         <span class="comment">// 浮点型数据</span></span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带Tag(标记)的值(定义了TValue的字段)，value_：为值 tt_ 为(Tag)标记字段,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields	Value value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>
<p>Tag(标记)字段说明：</p>
<p>0-3 位 表示LUA_T*定义的类型(最多16种类型) 4-5 位
表示变体标志（额外附加的一些标志位，比如要表示一个Number类型是整形还是浮点型，则可以加上一个变体标志来表示，如果LUA_TNUMBER(3)宏默认定义为整形，为了表示是浮点型，则可以
1 &amp; (3&lt;&lt;4)
这就在变体位加上了一个1，假设想区分单/双精度浮点则我们可以用1表单精度，2表示双精度，则可以使用2&amp;(3&lt;&lt;4)来表示）
6 位 表示是否是可收集(GC)对象</p>
<p><strong>StackValue</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于表示Lua栈上的值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> StackValue &#123;</span><br><span class="line">  TValue val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="keyword">unsigned</span> short delta;</span><br><span class="line">  &#125; tbclist;    <span class="comment">// to-be-closed值，表示5.4新增的一种带作用域的变量，比如在lua中这样定义： local a&lt;close&gt; = xxx 当a超出作用范围时，则会调用a元表中的__close元方法</span></span><br><span class="line">&#125; StackValue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈元素的索引(通过将两个栈值的地址先减就能计算出两个栈值的相对位置，比如当前栈值地址-栈基地址，就能求出在栈中的索引)</span></span><br><span class="line"><span class="keyword">typedef</span> StackValue *StkId;</span><br></pre></td></tr></table></figure>
<h2 id="核心函数">核心函数</h2>
<p><strong>State相关</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程状态+额外空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LX</span> &#123;</span></span><br><span class="line">  lu_byte extra_[LUA_EXTRASPACE];</span><br><span class="line">  lua_State l;</span><br><span class="line">&#125; LX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程和全局状态对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LG</span> &#123;</span></span><br><span class="line">  LX l;</span><br><span class="line">  global_State g;</span><br><span class="line">&#125; LG;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个State</span></span><br><span class="line"><span class="function">LUA_API lua_State *<span class="title">lua_newstate</span> <span class="params">(lua_Alloc f, <span class="keyword">void</span> *ud)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  lua_State *L;</span><br><span class="line">  global_State *g;</span><br><span class="line">  LG *l = cast(LG *, (*f)(ud, <span class="literal">NULL</span>, LUA_TTHREAD, <span class="keyword">sizeof</span>(LG)));  <span class="comment">// 分配一个LG对象</span></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  L = &amp;l-&gt;l.l;  <span class="comment">// 线程状态对象</span></span><br><span class="line">  g = &amp;l-&gt;g;    <span class="comment">// 全局状态对象</span></span><br><span class="line">  L-&gt;tt = LUA_VTHREAD; <span class="comment">// 初始化类型为线程</span></span><br><span class="line">  g-&gt;currentwhite = bitmask(WHITE0BIT); <span class="comment">// 垃圾收集器相关的，后续单独分析</span></span><br><span class="line">  L-&gt;marked = luaC_white(g);</span><br><span class="line">  preinit_thread(L, g);   <span class="comment">// 初始化一个线程状态，并关联线程状态对应的全局状态</span></span><br><span class="line">  g-&gt;allgc = obj2gco(L);  <span class="comment">// 将线程状态放入GC列表</span></span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;         <span class="comment">// 下一个GC为空（当前它是最有一个GC对象，因为当前只分配了这一个线程状态对象）</span></span><br><span class="line">  incnny(L);              <span class="comment">///* main thread is always non yieldable */</span></span><br><span class="line">  g-&gt;frealloc = f;        <span class="comment">// 保持内存分配函数到全局状态对象上</span></span><br><span class="line">  g-&gt;ud = ud;             <span class="comment">// NULL</span></span><br><span class="line">  g-&gt;warnf = <span class="literal">NULL</span>;        </span><br><span class="line">  g-&gt;ud_warn = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;mainthread = L;      <span class="comment">// 将当前线程状态设置为主线程</span></span><br><span class="line">  g-&gt;seed = luai_makeseed(L);       <span class="comment">// 产生随机数种子</span></span><br><span class="line">  g-&gt;gcrunning = <span class="number">0</span>;  </span><br><span class="line">  g-&gt;strt.<span class="built_in">size</span> = g-&gt;strt.nuse = <span class="number">0</span>;  <span class="comment">// 初始化短字符串缓存表</span></span><br><span class="line">  g-&gt;strt.hash = <span class="literal">NULL</span>;</span><br><span class="line">  setnilvalue(&amp;g-&gt;l_registry);      <span class="comment">// 注册表设为空</span></span><br><span class="line">  g-&gt;panic = <span class="literal">NULL</span>;                  </span><br><span class="line">  g-&gt;gcstate = GCSpause;            <span class="comment">// 初始化时GC处于暂停状态</span></span><br><span class="line">  g-&gt;gckind = KGC_INC;              <span class="comment">// 默认的GC类型是增量GC</span></span><br><span class="line">  g-&gt;gcstopem = <span class="number">0</span>;</span><br><span class="line">  g-&gt;gcemergency = <span class="number">0</span>;</span><br><span class="line">  g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;firstold1 = g-&gt;survival = g-&gt;old1 = g-&gt;reallyold = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;finobjsur = g-&gt;finobjold1 = g-&gt;finobjrold = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;sweepgc = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;gray = g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;twups = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;totalbytes = <span class="keyword">sizeof</span>(LG);</span><br><span class="line">  g-&gt;GCdebt = <span class="number">0</span>;</span><br><span class="line">  g-&gt;lastatomic = <span class="number">0</span>;</span><br><span class="line">  setivalue(&amp;g-&gt;nilvalue, <span class="number">0</span>);  </span><br><span class="line">  setgcparam(g-&gt;gcpause, LUAI_GCPAUSE); </span><br><span class="line">  setgcparam(g-&gt;gcstepmul, LUAI_GCMUL); </span><br><span class="line">  g-&gt;gcstepsize = LUAI_GCSTEPSIZE;</span><br><span class="line">  setgcparam(g-&gt;genmajormul, LUAI_GENMAJORMUL);</span><br><span class="line">  g-&gt;genminormul = LUAI_GENMINORMUL;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = <span class="literal">NULL</span>;            <span class="comment">// 基础类型的元表设置为空</span></span><br><span class="line">  <span class="keyword">if</span> (luaD_rawrunprotected(L, f_luaopen, <span class="literal">NULL</span>) != LUA_OK) &#123;   <span class="comment">// 调用线程状态打开函数</span></span><br><span class="line">    <span class="comment">// 不成功，则关闭线程状态并释放已经分配的内存</span></span><br><span class="line">    close_state(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程状态初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f_luaopen</span> <span class="params">(lua_State *L, <span class="keyword">void</span> *ud)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  UNUSED(ud);</span><br><span class="line">  stack_init(L, L);     <span class="comment">// 初始化线程状态的栈</span></span><br><span class="line">  init_registry(L, g);  <span class="comment">// 初始化注册表</span></span><br><span class="line">  luaS_init(L);         <span class="comment">// 初始化短字符串缓存表</span></span><br><span class="line">  luaT_init(L);         <span class="comment">// 初始化元方法字符串，并缓存到全局状态的tmname中</span></span><br><span class="line">  luaX_init(L);         <span class="comment">// 初始化保留关键字字符串</span></span><br><span class="line">  g-&gt;gcrunning = <span class="number">1</span>;     <span class="comment">// 开启GC</span></span><br><span class="line">  setnilvalue(&amp;g-&gt;nilvalue);</span><br><span class="line">  luai_userstateopen(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stack_init</span> <span class="params">(lua_State *L1, lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; CallInfo *ci;</span><br><span class="line">  <span class="comment">// 分配一个大小为(40+5)的栈</span></span><br><span class="line">  L1-&gt;<span class="built_in">stack</span> = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, StackValue);</span><br><span class="line">  L1-&gt;tbclist = L1-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  <span class="comment">// 将栈中的值设置为nil</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BASIC_STACK_SIZE + EXTRA_STACK; i++)</span><br><span class="line">    setnilvalue(s2v(L1-&gt;<span class="built_in">stack</span> + i));</span><br><span class="line">  L1-&gt;top = L1-&gt;<span class="built_in">stack</span>;  <span class="comment">// 将栈顶设置到栈的初始位置</span></span><br><span class="line">  L1-&gt;stack_last = L1-&gt;<span class="built_in">stack</span> + BASIC_STACK_SIZE; <span class="comment">// 标记栈的最后一个栈值（不包含额外空间）</span></span><br><span class="line">  <span class="comment">// 初始化首个调用信息</span></span><br><span class="line">  ci = &amp;L1-&gt;base_ci;</span><br><span class="line">  ci-&gt;next = ci-&gt;previous = <span class="literal">NULL</span>;</span><br><span class="line">  ci-&gt;callstatus = CIST_C;  <span class="comment">// C调用</span></span><br><span class="line">  ci-&gt;func = L1-&gt;top;</span><br><span class="line">  ci-&gt;u.c.k = <span class="literal">NULL</span>;</span><br><span class="line">  ci-&gt;nresults = <span class="number">0</span>;</span><br><span class="line">  setnilvalue(s2v(L1-&gt;top));</span><br><span class="line">  L1-&gt;top++;</span><br><span class="line">  ci-&gt;top = L1-&gt;top + LUA_MINSTACK; <span class="comment">// 设置当前调用信息的栈顶为当前线程状态的栈顶+20</span></span><br><span class="line">  L1-&gt;ci = ci;                      <span class="comment">// 设置base_ci调用信息为当前的ci</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建注册表并初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_registry</span> <span class="params">(lua_State *L, global_State *g)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建注册表</span></span><br><span class="line">  Table *registry = luaH_new(L);</span><br><span class="line">  <span class="comment">// 保持注册表到全局状态中去</span></span><br><span class="line">  sethvalue(L, &amp;g-&gt;l_registry, registry);</span><br><span class="line">  <span class="comment">// 扩展注册表大小为2</span></span><br><span class="line">  luaH_resize(L, registry, LUA_RIDX_LAST, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 将主线程保存到注册表中</span></span><br><span class="line">  setthvalue(L, &amp;registry-&gt;<span class="built_in">array</span>[LUA_RIDX_MAINTHREAD - <span class="number">1</span>], L);</span><br><span class="line">  <span class="comment">// 创建一个全局表到注册表中</span></span><br><span class="line">  sethvalue(L, &amp;registry-&gt;<span class="built_in">array</span>[LUA_RIDX_GLOBALS - <span class="number">1</span>], luaH_new(L));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化stringtable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaS_init</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  stringtable *tb = &amp;G(L)-&gt;strt;</span><br><span class="line">  tb-&gt;hash = luaM_newvector(L, MINSTRTABSIZE, TString*);  <span class="comment">// 初始化一个大小为128的TString指针数组</span></span><br><span class="line">  tablerehash(tb-&gt;hash, <span class="number">0</span>, MINSTRTABSIZE);                <span class="comment">// 清空tb-&gt;hash</span></span><br><span class="line">  tb-&gt;<span class="built_in">size</span> = MINSTRTABSIZE;</span><br><span class="line">  g-&gt;memerrmsg = luaS_newliteral(L, MEMERRMSG);           <span class="comment">// 创建一个"not enough memory"消息</span></span><br><span class="line">  luaC_fix(L, obj2gco(g-&gt;memerrmsg));                     <span class="comment">// 不让其被GC</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; STRCACHE_N; i++)                        <span class="comment">// 给strcache填充一个有效值</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; STRCACHE_M; j++)</span><br><span class="line">      g-&gt;strcache[i][j] = g-&gt;memerrmsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化元方法字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaT_init</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> luaT_eventname[] = &#123;  </span><br><span class="line">    <span class="string">"__index"</span>, <span class="string">"__newindex"</span>,</span><br><span class="line">    <span class="string">"__gc"</span>, <span class="string">"__mode"</span>, <span class="string">"__len"</span>, <span class="string">"__eq"</span>,</span><br><span class="line">    <span class="string">"__add"</span>, <span class="string">"__sub"</span>, <span class="string">"__mul"</span>, <span class="string">"__mod"</span>, <span class="string">"__pow"</span>,</span><br><span class="line">    <span class="string">"__div"</span>, <span class="string">"__idiv"</span>,</span><br><span class="line">    <span class="string">"__band"</span>, <span class="string">"__bor"</span>, <span class="string">"__bxor"</span>, <span class="string">"__shl"</span>, <span class="string">"__shr"</span>,</span><br><span class="line">    <span class="string">"__unm"</span>, <span class="string">"__bnot"</span>, <span class="string">"__lt"</span>, <span class="string">"__le"</span>,</span><br><span class="line">    <span class="string">"__concat"</span>, <span class="string">"__call"</span>, <span class="string">"__close"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;TM_N; i++) &#123;</span><br><span class="line">    G(L)-&gt;tmname[i] = luaS_new(L, luaT_eventname[i]);</span><br><span class="line">    luaC_fix(L, obj2gco(G(L)-&gt;tmname[i]));    <span class="comment">// 不被GC回收</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Lua中的关键字字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaX_init</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  TString *e = luaS_newliteral(L, LUA_ENV);  <span class="comment">// 创建"_ENV"字符串</span></span><br><span class="line">  luaC_fix(L, obj2gco(e));                    </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_RESERVED; i++) &#123;</span><br><span class="line">    TString *ts = luaS_new(L, luaX_tokens[i]);  <span class="comment">// 创建关键字字符串</span></span><br><span class="line">    luaC_fix(L, obj2gco(ts));  </span><br><span class="line">    ts-&gt;extra = cast_byte(i+<span class="number">1</span>);                 <span class="comment">// 记录关键字枚举值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Proto和Closure相关</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个Proto对象</span></span><br><span class="line"><span class="function">LUAI_FUNC Proto *<span class="title">luaF_newproto</span> <span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="comment">// 分配C闭包</span></span><br><span class="line"><span class="function">LUAI_FUNC CClosure *<span class="title">luaF_newCclosure</span> <span class="params">(lua_State *L, <span class="keyword">int</span> nupvals)</span></span>;</span><br><span class="line"><span class="comment">// 分配一个Lua闭包 </span></span><br><span class="line"><span class="function">LUAI_FUNC LClosure *<span class="title">luaF_newLclosure</span> <span class="params">(lua_State *L, <span class="keyword">int</span> nupvals)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化上值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaF_initupvals</span> <span class="params">(lua_State *L, LClosure *cl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cl-&gt;nupvalues; i++) &#123;</span><br><span class="line">    GCObject *o = luaC_newobj(L, LUA_VUPVAL, <span class="keyword">sizeof</span>(UpVal));</span><br><span class="line">    UpVal *uv = gco2upv(o);</span><br><span class="line">    uv-&gt;v = &amp;uv-&gt;u.value;  <span class="comment">/* make it closed */</span></span><br><span class="line">    setnilvalue(uv-&gt;v);</span><br><span class="line">    cl-&gt;upvals[i] = uv;</span><br><span class="line">    luaC_objbarrier(L, cl, uv);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找或创建一个上值</span></span><br><span class="line"><span class="function">UpVal *<span class="title">luaF_findupval</span> <span class="params">(lua_State *L, StkId level)</span> </span>&#123;</span><br><span class="line">  UpVal **pp = &amp;L-&gt;openupval;</span><br><span class="line">  UpVal *p;</span><br><span class="line">  lua_assert(isintwups(L) || L-&gt;openupval == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span> ((p = *pp) != <span class="literal">NULL</span> &amp;&amp; uplevel(p) &gt;= level) &#123;  <span class="comment">/* search for it */</span></span><br><span class="line">    lua_assert(!isdead(G(L), p));</span><br><span class="line">    <span class="keyword">if</span> (uplevel(p) == level)  <span class="comment">/* corresponding upvalue? */</span></span><br><span class="line">      <span class="keyword">return</span> p;  <span class="comment">/* return it */</span></span><br><span class="line">    pp = &amp;p-&gt;u.<span class="built_in">open</span>.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* not found: create a new upvalue after 'pp' */</span></span><br><span class="line">  <span class="keyword">return</span> newupval(L, <span class="number">0</span>, level, pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CallInfo相关</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用lua解析器生成Lua闭包和函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaD_protectedparser</span> <span class="params">(lua_State *L, ZIO *z, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  incnny(L);  <span class="comment">/* cannot yield during parsing */</span></span><br><span class="line">  p.z = z; p.name = name; p.mode = mode;</span><br><span class="line">  p.dyd.actvar.arr = <span class="literal">NULL</span>; p.dyd.actvar.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  p.dyd.gt.arr = <span class="literal">NULL</span>; p.dyd.gt.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  p.dyd.label.arr = <span class="literal">NULL</span>; p.dyd.label.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  luaZ_initbuffer(L, &amp;p.buff);</span><br><span class="line">  status = luaD_pcall(L, f_parser, &amp;p, savestack(L, L-&gt;top), L-&gt;errfunc);</span><br><span class="line">  luaZ_freebuffer(L, &amp;p.buff);</span><br><span class="line">  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.<span class="built_in">size</span>);</span><br><span class="line">  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.<span class="built_in">size</span>);</span><br><span class="line">  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.<span class="built_in">size</span>);</span><br><span class="line">  decnny(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备函数的调用信息</span></span><br><span class="line"><span class="function">CallInfo *<span class="title">luaD_precall</span> <span class="params">(lua_State *L, StkId func, <span class="keyword">int</span> nresults)</span> </span>&#123;</span><br><span class="line">  lua_CFunction f;</span><br><span class="line"> retry:</span><br><span class="line">  <span class="keyword">switch</span> (ttypetag(s2v(func))) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_VCCL:  <span class="comment">/* C closure */</span></span><br><span class="line">      f = clCvalue(s2v(func))-&gt;f;</span><br><span class="line">      <span class="keyword">goto</span> Cfunc;</span><br><span class="line">    <span class="keyword">case</span> LUA_VLCF:  <span class="comment">/* light C function */</span></span><br><span class="line">      f = fvalue(s2v(func));</span><br><span class="line">     Cfunc: &#123;</span><br><span class="line">      <span class="keyword">int</span> n;  <span class="comment">/* number of returns */</span></span><br><span class="line">      CallInfo *ci;</span><br><span class="line">      checkstackGCp(L, LUA_MINSTACK, func);  <span class="comment">/* ensure minimum stack size */</span></span><br><span class="line">      L-&gt;ci = ci = next_ci(L);</span><br><span class="line">      ci-&gt;nresults = nresults;</span><br><span class="line">      ci-&gt;callstatus = CIST_C;</span><br><span class="line">      ci-&gt;top = L-&gt;top + LUA_MINSTACK;</span><br><span class="line">      ci-&gt;func = func;</span><br><span class="line">      lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);</span><br><span class="line">      <span class="keyword">if</span> (l_unlikely(L-&gt;hookmask &amp; LUA_MASKCALL)) &#123;</span><br><span class="line">        <span class="keyword">int</span> narg = cast_int(L-&gt;top - func) - <span class="number">1</span>;</span><br><span class="line">        luaD_hook(L, LUA_HOOKCALL, <span class="number">-1</span>, <span class="number">1</span>, narg);</span><br><span class="line">      &#125;</span><br><span class="line">      lua_unlock(L);</span><br><span class="line">      n = (*f)(L);  <span class="comment">/* do the actual call */</span></span><br><span class="line">      lua_lock(L);</span><br><span class="line">      api_checknelems(L, n);</span><br><span class="line">      luaD_poscall(L, ci, n);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_VLCL: &#123;  <span class="comment">/* Lua function */</span></span><br><span class="line">      CallInfo *ci;</span><br><span class="line">      Proto *p = clLvalue(s2v(func))-&gt;p;</span><br><span class="line">      <span class="keyword">int</span> narg = cast_int(L-&gt;top - func) - <span class="number">1</span>;  <span class="comment">/* number of real arguments */</span></span><br><span class="line">      <span class="keyword">int</span> nfixparams = p-&gt;numparams;</span><br><span class="line">      <span class="keyword">int</span> fsize = p-&gt;maxstacksize;  <span class="comment">/* frame size */</span></span><br><span class="line">      checkstackGCp(L, fsize, func);</span><br><span class="line">      L-&gt;ci = ci = next_ci(L);</span><br><span class="line">      ci-&gt;nresults = nresults;</span><br><span class="line">      ci-&gt;u.l.savedpc = p-&gt;code;  <span class="comment">/* starting point */</span></span><br><span class="line">      ci-&gt;top = func + <span class="number">1</span> + fsize;</span><br><span class="line">      ci-&gt;func = func;</span><br><span class="line">      L-&gt;ci = ci;</span><br><span class="line">      <span class="keyword">for</span> (; narg &lt; nfixparams; narg++)</span><br><span class="line">        setnilvalue(s2v(L-&gt;top++));  <span class="comment">/* complete missing arguments */</span></span><br><span class="line">      lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);</span><br><span class="line">      <span class="keyword">return</span> ci;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;  <span class="comment">/* not a function */</span></span><br><span class="line">      checkstackGCp(L, <span class="number">1</span>, func);  <span class="comment">/* space for metamethod */</span></span><br><span class="line">      luaD_tryfuncTM(L, func);  <span class="comment">/* try to get '__call' metamethod */</span></span><br><span class="line">      <span class="keyword">goto</span> retry;  <span class="comment">/* try again with metamethod */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ccall</span> <span class="params">(lua_State *L, StkId func, <span class="keyword">int</span> nResults, <span class="keyword">int</span> inc)</span> </span>&#123;</span><br><span class="line">  CallInfo *ci;</span><br><span class="line">  L-&gt;nCcalls += inc;</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(getCcalls(L) &gt;= LUAI_MAXCCALLS))</span><br><span class="line">    luaE_checkcstack(L);</span><br><span class="line">  <span class="keyword">if</span> ((ci = luaD_precall(L, func, nResults)) != <span class="literal">NULL</span>) &#123;  <span class="comment">/* Lua function? */</span></span><br><span class="line">    ci-&gt;callstatus = CIST_FRESH;  <span class="comment">/* mark that it is a "fresh" execute */</span></span><br><span class="line">    luaV_execute(L, ci);  <span class="comment">/* call it */</span></span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;nCcalls -= inc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaD_call</span> <span class="params">(lua_State *L, StkId func, <span class="keyword">int</span> nResults)</span> </span>&#123;</span><br><span class="line">  ccall(L, func, nResults, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Table相关</strong></p>
<p>创建和释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Tablew</span></span><br><span class="line"><span class="function">Table *<span class="title">luaH_new</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  GCObject *o = luaC_newobj(L, LUA_VTABLE, <span class="keyword">sizeof</span>(Table)); <span class="comment">// 分配一个Table对象</span></span><br><span class="line">  Table *t = gco2t(o);  </span><br><span class="line">  t-&gt;metatable = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;flags = cast_byte(maskflags);  <span class="comment">/* table has no metamethod fields */</span></span><br><span class="line">  t-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;alimit = <span class="number">0</span>;</span><br><span class="line">  setnodevector(L, t, <span class="number">0</span>);   <span class="comment">// 初始化一个带虚拟节点的空table</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaH_free</span> <span class="params">(lua_State *L, Table *t)</span> </span>&#123;</span><br><span class="line">  freehash(L, t);</span><br><span class="line">  luaM_freearray(L, t-&gt;<span class="built_in">array</span>, luaH_realasize(t));</span><br><span class="line">  luaM_free(L, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取函数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TValue *<span class="title">luaH_get</span> <span class="params">(Table *t, <span class="keyword">const</span> TValue *key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (ttypetag(key)) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_VSHRSTR: <span class="keyword">return</span> luaH_getshortstr(t, tsvalue(key)); <span class="comment">// 短字符串key</span></span><br><span class="line">    <span class="keyword">case</span> LUA_VNUMINT: <span class="keyword">return</span> luaH_getint(t, ivalue(key));       <span class="comment">// 整型key</span></span><br><span class="line">    <span class="keyword">case</span> LUA_VNIL: <span class="keyword">return</span> &amp;absentkey;                           <span class="comment">// Nil返回未找到static const TValue absentkey = &#123; value_: &#123;NULL&#125;, tt_: makevariant(LUA_TNIL, 2)&#125;;</span></span><br><span class="line">    <span class="keyword">case</span> LUA_VNUMFLT: &#123;                                         <span class="comment">// 浮点型key</span></span><br><span class="line">      lua_Integer k;</span><br><span class="line">      <span class="keyword">if</span> (luaV_flttointeger(fltvalue(key), &amp;k, F2Ieq))          <span class="comment">// 能转换成整形吗</span></span><br><span class="line">        <span class="keyword">return</span> luaH_getint(t, k);                               <span class="comment">// 能则调用获取整形key的函数，否则直接到default</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> getgeneric(t, key, <span class="number">0</span>);                             <span class="comment">// 通用的get方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整型key时，如果key的小于等于alimit则直接访问数组部分，当等于alimit + 1时则增加数组部分的大小并访问，否则就访问hash部分</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TValue *<span class="title">luaH_getint</span> <span class="params">(Table *t, lua_Integer key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l_castS2U(key) - <span class="number">1u</span> &lt; t-&gt;alimit)  </span><br><span class="line">    <span class="keyword">return</span> &amp;t-&gt;<span class="built_in">array</span>[key - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!limitequalsasize(t) &amp;&amp; </span><br><span class="line">           (l_castS2U(key) == t-&gt;alimit + <span class="number">1</span> ||</span><br><span class="line">            l_castS2U(key) - <span class="number">1u</span> &lt; luaH_realasize(t))) &#123;</span><br><span class="line">    t-&gt;alimit = cast_uint(key); </span><br><span class="line">    <span class="keyword">return</span> &amp;t-&gt;<span class="built_in">array</span>[key - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node *n = hashint(t, key); 获取hash的slot（主节点）</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (keyisinteger(n) &amp;&amp; keyival(n) == key)</span><br><span class="line">        <span class="keyword">return</span> gval(n);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = gnext(n);</span><br><span class="line">        <span class="keyword">if</span> (nx == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        n += nx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;absentkey;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “通用"的get(不是通用的：对于可能在数组部分的整数无效，对于具有整数值的浮点数也无效。)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> TValue *<span class="title">getgeneric</span> <span class="params">(Table *t, <span class="keyword">const</span> TValue *key, <span class="keyword">int</span> deadok)</span> </span>&#123;</span><br><span class="line">  Node *n = mainpositionTV(t, key);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 检查key是否在链表中的某处</span></span><br><span class="line">    <span class="keyword">if</span> (equalkey(key, n, deadok))</span><br><span class="line">      <span class="keyword">return</span> gval(n);  匹配到key就返回，否则需要在hash的冲突链中查找</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> nx = gnext(n); <span class="comment">// 获取冲突链中的下一个</span></span><br><span class="line">      <span class="keyword">if</span> (nx == <span class="number">0</span>)       <span class="comment">// 已经到最后一个了，则返回没有找到</span></span><br><span class="line">        <span class="keyword">return</span> &amp;absentkey; </span><br><span class="line">      n += nx;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取key值对应的hash槽（slot）也就是hash值对应的主节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node *<span class="title">mainpositionTV</span> <span class="params">(<span class="keyword">const</span> Table *t, <span class="keyword">const</span> TValue *key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mainposition(t, rawtt(key), valraw(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node *<span class="title">mainposition</span> <span class="params">(<span class="keyword">const</span> Table *t, <span class="keyword">int</span> ktt, <span class="keyword">const</span> Value *kvl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (withvariant(ktt)) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_VNUMINT: &#123; <span class="comment">// 整形的hash函数</span></span><br><span class="line">      lua_Integer key = ivalueraw(*kvl);</span><br><span class="line">      <span class="keyword">return</span> hashint(t, key);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_VNUMFLT: &#123; <span class="comment">// 浮点数的hash 函数</span></span><br><span class="line">      lua_Number n = fltvalueraw(*kvl);</span><br><span class="line">      <span class="keyword">return</span> hashmod(t, l_hashfloat(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_VSHRSTR: &#123; <span class="comment">// 字符串的哈希函数，</span></span><br><span class="line">      TString *ts = tsvalueraw(*kvl);</span><br><span class="line">      <span class="keyword">return</span> hashstr(t, ts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_VLNGSTR: &#123; <span class="comment">// 字符串的函数函数</span></span><br><span class="line">      TString *ts = tsvalueraw(*kvl);</span><br><span class="line">      <span class="keyword">return</span> hashpow2(t, luaS_hashlongstr(ts));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_VFALSE:  <span class="comment">// 布尔值的hash函数</span></span><br><span class="line">      <span class="keyword">return</span> hashboolean(t, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">case</span> LUA_VTRUE:</span><br><span class="line">      <span class="keyword">return</span> hashboolean(t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">case</span> LUA_VLIGHTUSERDATA: &#123; <span class="comment">// 轻量级用户数据的hash函数</span></span><br><span class="line">      <span class="keyword">void</span> *p = pvalueraw(*kvl);</span><br><span class="line">      <span class="keyword">return</span> hashpointer(t, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_VLCF: &#123;          <span class="comment">// C函数的hash函数</span></span><br><span class="line">      lua_CFunction f = fvalueraw(*kvl);</span><br><span class="line">      <span class="keyword">return</span> hashpointer(t, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;              <span class="comment">// 其他类型的hash函数</span></span><br><span class="line">      GCObject *o = gcvalueraw(*kvl);</span><br><span class="line">      <span class="keyword">return</span> hashpointer(t, o);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash函数说明：</span></span><br><span class="line"><span class="comment">// 整形：直接用整形值对表的长度求模。</span></span><br><span class="line"><span class="comment">// 浮点数：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">l_hashfloat</span> <span class="params">(lua_Number n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  lua_Integer ni;</span><br><span class="line">  n = l_mathop(<span class="built_in">frexp</span>)(n, &amp;i) * -cast_num(INT_MIN);</span><br><span class="line">  <span class="keyword">if</span> (!lua_numbertointeger(n, &amp;ni)) &#123;  <span class="comment">/* is 'n' inf/-inf/NaN? */</span></span><br><span class="line">    lua_assert(luai_numisnan(n) || l_mathop(<span class="built_in">fabs</span>)(n) == cast_num(HUGE_VAL));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* normal case */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> u = cast_uint(i) + cast_uint(ni);</span><br><span class="line">    <span class="keyword">return</span> cast_int(u &lt;= cast_uint(INT_MAX) ? u : ~u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hashstr(t,str)		hashpow2(t, (str)-&gt;hash)</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">luaS_hash</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l, <span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = seed ^ cast_uint(l);</span><br><span class="line">  <span class="keyword">for</span> (; l &gt; <span class="number">0</span>; l--)</span><br><span class="line">    h ^= ((h&lt;&lt;<span class="number">5</span>) + (h&gt;&gt;<span class="number">2</span>) + cast_byte(str[l - <span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hashboolean(t,p)	hashpow2(t, p)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 轻量级用户数据, C函数和其他类型：</span></span><br><span class="line"> <span class="comment">// 都是将地址转换为整型</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> hashpointer(t,p)	hashmod(t, point2uint(p))</span></span><br></pre></td></tr></table></figure>
<p>设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaH_set</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *key, TValue *value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TValue *slot = luaH_get(t, key);</span><br><span class="line">  luaH_finishset(L, t, key, slot, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaH_finishset</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> TValue *slot, TValue *value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有发现key，则新建一个，否则直接设置值</span></span><br><span class="line">  <span class="keyword">if</span> (isabstkey(slot))</span><br><span class="line">    luaH_newkey(L, t, key, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    setobj2t(L, cast(TValue *, slot), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Hash表中添加一个新的key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaH_newkey</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *key, TValue *value)</span> </span>&#123;</span><br><span class="line">  Node *mp;</span><br><span class="line">  TValue aux;</span><br><span class="line">  <span class="comment">// 检查key</span></span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(ttisnil(key))) <span class="comment">// key为nil</span></span><br><span class="line">    luaG_runerror(L, <span class="string">"table index is nil"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ttisfloat(key)) &#123;    <span class="comment">// key为浮点数           </span></span><br><span class="line">    lua_Number f = fltvalue(key);</span><br><span class="line">    lua_Integer k;</span><br><span class="line">    <span class="keyword">if</span> (luaV_flttointeger(f, &amp;k, F2Ieq)) &#123; <span class="comment">// 将浮点数转为整型</span></span><br><span class="line">      setivalue(&amp;aux, k);                          </span><br><span class="line">      key = &amp;aux;   <span class="comment">// 将其作为一个整数key插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l_unlikely(luai_numisnan(f)))</span><br><span class="line">      luaG_runerror(L, <span class="string">"table index is NaN"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查值</span></span><br><span class="line">  <span class="keyword">if</span> (ttisnil(value))</span><br><span class="line">    <span class="keyword">return</span>;   <span class="comment">// 值为nil就不插入了</span></span><br><span class="line">  mp = mainpositionTV(t, key); <span class="comment">// 获取key的在hash槽的主位置</span></span><br><span class="line">  <span class="keyword">if</span> (!isempty(gval(mp)) || isdummy(t)) &#123; <span class="comment">// 获取到主位置</span></span><br><span class="line">    Node *othern;</span><br><span class="line">    Node *f = getfreepos(t);  <span class="comment">// 获取一个空的Node（倒着查找）</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;          <span class="comment">// 没有空余位置时，则需要进行扩容</span></span><br><span class="line">      rehash(L, t, key);      <span class="comment">// 重新计算hash并扩容</span></span><br><span class="line">      luaH_set(L, t, key, value); 插入值到成长后的表</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_assert(!isdummy(t));</span><br><span class="line">    othern = mainposition(t, keytt(mp), &amp;keyval(mp)); <span class="comment">// 获取主位置上key值对应的主位置</span></span><br><span class="line">    <span class="keyword">if</span> (othern != mp) &#123;  <span class="comment">// 冲突节点在主位置外部（当前key对应的槽已经被其他的key占用了）</span></span><br><span class="line">      <span class="comment">// 移动冲突节点的空位置，并将其重新连接上</span></span><br><span class="line">      <span class="keyword">while</span> (othern + gnext(othern) != mp)</span><br><span class="line">        othern += gnext(othern);</span><br><span class="line">      gnext(othern) = cast_int(f - othern);  </span><br><span class="line">      *f = *mp;  <span class="comment">// 拷贝冲突节点到空的位置上（next也一并拷贝了）</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>) &#123;</span><br><span class="line">        gnext(f) += cast_int(mp - f);  <span class="comment">// 重新修正next的位置</span></span><br><span class="line">        gnext(mp) = <span class="number">0</span>;                </span><br><span class="line">      &#125;</span><br><span class="line">      setempty(gval(mp));  <span class="comment">// 现在主位置空出来了，将其设置为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 冲突节点在主位置上，这说明了是相同的key</span></span><br><span class="line">      <span class="comment">// 将空节点连接到冲突链上</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>)</span><br><span class="line">        gnext(f) = cast_int((mp + gnext(mp)) - f);  <span class="comment">/* chain new position */</span></span><br><span class="line">      <span class="keyword">else</span> lua_assert(gnext(f) == <span class="number">0</span>);</span><br><span class="line">      gnext(mp) = cast_int(f - mp);</span><br><span class="line">      mp = f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置节点的key</span></span><br><span class="line">  setnodekey(L, mp, key);</span><br><span class="line">  luaC_barrierback(L, obj2gco(t), key);</span><br><span class="line">  lua_assert(isempty(gval(mp)));</span><br><span class="line">  <span class="comment">// 设置节点的值</span></span><br><span class="line">  setobj2t(L, gval(mp), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="helloworld">HelloWorld</h1>
<p>通过HelloWorld函数程序来说明Lua程序是如何运行起来的。</p>
<p><strong>创建LuaState并注册标注库</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 先构建一个lua state</span></span><br><span class="line">  lua_State* L = luaL_newstate();</span><br><span class="line">  <span class="comment">// 注册lua的标注库</span></span><br><span class="line">  luaL_openlibs(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造打印HelloWorld的Lua代码</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"print('hello world')"</span>;</span><br><span class="line">  <span class="comment">// 加载并执行</span></span><br><span class="line">  luaL_dostring(L, str.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Lua State</span></span><br><span class="line"><span class="function">LUALIB_API lua_State *<span class="title">luaL_newstate</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  lua_State *L = lua_newstate(l_alloc, <span class="literal">NULL</span>); <span class="comment">// 注册全局内存分配函数l_alloc，辅助库里的内存分配函数使用的是realloc</span></span><br><span class="line">  <span class="keyword">if</span> (l_likely(L)) &#123;</span><br><span class="line">    lua_atpanic(L, &amp;panic);  <span class="comment">// 注册全局错误回调函数</span></span><br><span class="line">    lua_setwarnf(L, warnfoff, L);  <span class="comment">// 设置全局的默认警告函数，默认警告关闭</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注册的库</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg loadedlibs[] = &#123;</span><br><span class="line">  &#123;LUA_GNAME, luaopen_base&#125;,</span><br><span class="line">  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,</span><br><span class="line">  &#123;LUA_COLIBNAME, luaopen_coroutine&#125;,</span><br><span class="line">  &#123;LUA_TABLIBNAME, luaopen_table&#125;,</span><br><span class="line">  &#123;LUA_IOLIBNAME, luaopen_io&#125;,</span><br><span class="line">  &#123;LUA_OSLIBNAME, luaopen_os&#125;,</span><br><span class="line">  &#123;LUA_STRLIBNAME, luaopen_string&#125;,</span><br><span class="line">  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,</span><br><span class="line">  &#123;LUA_UTF8LIBNAME, luaopen_utf8&#125;,</span><br><span class="line">  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,</span><br><span class="line">  &#123;<span class="string">"mylib"</span>, luaopen_mylib&#125;,</span><br><span class="line">  &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册所有的库</span></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaL_openlibs</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> luaL_Reg *lib;</span><br><span class="line">  <span class="keyword">for</span> (lib = loadedlibs; lib-&gt;func; lib++) &#123;</span><br><span class="line">    luaL_requiref(L, lib-&gt;name, lib-&gt;func, <span class="number">1</span>);</span><br><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用注册函数</span></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaL_requiref</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *modname,</span></span></span><br><span class="line"><span class="function"><span class="params">                               lua_CFunction openf, <span class="keyword">int</span> glb)</span> </span>&#123;</span><br><span class="line">  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);  <span class="comment">// 从注册表中获取_LOADED对应的table</span></span><br><span class="line">  lua_getfield(L, <span class="number">-1</span>, modname);   <span class="comment">// 获取table中对应的模块（modname）</span></span><br><span class="line">  <span class="keyword">if</span> (!lua_toboolean(L, <span class="number">-1</span>)) &#123;    <span class="comment">// 检查获取结果,如果没有就加载</span></span><br><span class="line">    lua_pop(L, <span class="number">1</span>);                <span class="comment">// 弹出刚lua_getfield获取的结果</span></span><br><span class="line">    lua_pushcfunction(L, openf);  <span class="comment">// 将要调用的c函数压入栈中</span></span><br><span class="line">    lua_pushstring(L, modname);   <span class="comment">// 传递到open函数的参数</span></span><br><span class="line">    lua_call(L, <span class="number">1</span>, <span class="number">1</span>);            <span class="comment">// 调用‘openf’函数去打开库（1:一个传入参数， 1：一个返回值）</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);         <span class="comment">// 将调用的结果（一个table）再次压入栈中</span></span><br><span class="line">    lua_setfield(L, <span class="number">-3</span>, modname); <span class="comment">// 将返回的table保存到key(modname)中</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_remove(L, <span class="number">-2</span>);              <span class="comment">// 移除栈中的LOADED table </span></span><br><span class="line">  <span class="keyword">if</span> (glb) &#123;                      <span class="comment">// 需要将其保存到全局表中？</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);         <span class="comment">// 先将lua_call返回的table压入栈顶</span></span><br><span class="line">    lua_setglobal(L, modname);    <span class="comment">// 将栈顶的table设置到全局表中的modname字段</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看一个简单的table库的打开函数</span></span><br><span class="line"><span class="comment">// 辅助库定义的一个创建库的函数，就是创建了一个table, 然后将tab_funcs中定义的字段名和函数绑定到table中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaL_newlib(L,l)  \</span></span><br><span class="line">  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注册的函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg tab_funcs[] = &#123;</span><br><span class="line">  &#123;<span class="string">"concat"</span>, tconcat&#125;,</span><br><span class="line">  &#123;<span class="string">"insert"</span>, tinsert&#125;,</span><br><span class="line">  &#123;<span class="string">"pack"</span>, tpack&#125;,</span><br><span class="line">  &#123;<span class="string">"unpack"</span>, tunpack&#125;,</span><br><span class="line">  &#123;<span class="string">"remove"</span>, tremove&#125;,</span><br><span class="line">  &#123;<span class="string">"move"</span>, tmove&#125;,</span><br><span class="line">  &#123;<span class="string">"sort"</span>, sort&#125;,</span><br><span class="line">  &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table库的打开函数</span></span><br><span class="line"><span class="function">LUAMOD_API <span class="keyword">int</span> <span class="title">luaopen_table</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  luaL_newlib(L, tab_funcs);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解析Lua代码生产指令</strong>
Lua解释器将Lua源码转换成Lua指令的过程。核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载解析并执行Lua代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaL_dostring(L, s) \</span></span><br><span class="line">	(luaL_loadstring(L, s) || lua_pcall(L, <span class="number">0</span>, LUA_MULTRET, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载并解析字符串</span></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaL_loadstring</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> luaL_loadbuffer(L, s, <span class="built_in">strlen</span>(s), s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaL_loadbufferx</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *buff, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">  LoadS ls;         <span class="comment">// 将Lua代码放在ls中</span></span><br><span class="line">  ls.s = buff;</span><br><span class="line">  ls.<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">  <span class="keyword">return</span> lua_load(L, getS, &amp;ls, name, mode); <span class="comment">// 加载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LUA_API <span class="keyword">int</span> <span class="title">lua_load</span> <span class="params">(lua_State *L, lua_Reader reader, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">char</span> *chunkname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">  ZIO z;             <span class="comment">// 数据流缓存，用于解析Lua代码</span></span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  <span class="keyword">if</span> (!chunkname) chunkname = <span class="string">"?"</span>;</span><br><span class="line">  luaZ_init(L, &amp;z, reader, data);   <span class="comment">// 初始化数据流缓存</span></span><br><span class="line">  status = luaD_protectedparser(L, &amp;z, chunkname, mode);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;  <span class="comment">/* no errors? */</span></span><br><span class="line">    LClosure *f = clLvalue(s2v(L-&gt;top - <span class="number">1</span>));  <span class="comment">/* get newly created function */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nupvalues &gt;= <span class="number">1</span>) &#123;  <span class="comment">/* does it have an upvalue? */</span></span><br><span class="line">      <span class="comment">/* get global table from registry */</span></span><br><span class="line">      <span class="keyword">const</span> TValue *gt = getGtable(L);</span><br><span class="line">      <span class="comment">/* set global table as 1st upvalue of 'f' (may be LUA_ENV) */</span></span><br><span class="line">      setobj(L, f-&gt;upvals[<span class="number">0</span>]-&gt;v, gt);</span><br><span class="line">      luaC_barrier(L, f-&gt;upvals[<span class="number">0</span>], gt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析（词法，语法，语义分析）Lua代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaD_protectedparser</span> <span class="params">(lua_State *L, ZIO *z, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> <span class="title">p</span>;</span>       <span class="comment">// 创建一个解析器</span></span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  incnny(L);  </span><br><span class="line">  p.z = z; p.name = name; p.mode = mode;</span><br><span class="line">  p.dyd.actvar.arr = <span class="literal">NULL</span>; p.dyd.actvar.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  p.dyd.gt.arr = <span class="literal">NULL</span>; p.dyd.gt.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  p.dyd.label.arr = <span class="literal">NULL</span>; p.dyd.label.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  luaZ_initbuffer(L, &amp;p.buff);</span><br><span class="line">  status = luaD_pcall(L, f_parser, &amp;p, savestack(L, L-&gt;top), L-&gt;errfunc);<span class="comment">// 调用解析函数</span></span><br><span class="line">  luaZ_freebuffer(L, &amp;p.buff);</span><br><span class="line">  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.<span class="built_in">size</span>);</span><br><span class="line">  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.<span class="built_in">size</span>);</span><br><span class="line">  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.<span class="built_in">size</span>);</span><br><span class="line">  decnny(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f_parser</span> <span class="params">(lua_State *L, <span class="keyword">void</span> *ud)</span> </span>&#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> = <span class="title">cast</span>(<span class="title">struct</span> <span class="title">SParser</span> *, <span class="title">ud</span>);</span></span><br><span class="line">  <span class="keyword">int</span> c = zgetc(p-&gt;z);  <span class="comment">// 读取第一个字符</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">"binary"</span>); </span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, p-&gt;name); <span class="comment">//解析编译好的二进制格式</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">"text"</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c); <span class="comment">// 解析源码</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luaF_initupvals(L, cl);  <span class="comment">// 初始化闭包的上值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析完后会生成一个原型（Proto）对象，对象的code字段存放的就是对应的指令码，指令码有如下5种格式：
3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 1 0 9 8
7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 iABC C(8) | B(8)
|k| A(8) | Op(7) | iABx Bx(17) | A(8) | Op(7) | iAsBx sBx (signed)(17) |
A(8) | Op(7) | iAx Ax(25) | Op(7) | isJ sJ(25) | Op(7) |</p>
<p>开头的7位表示操作码，后面的表示操作码对应的参数。</p>
<p><strong>执行指令</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaV_execute</span> <span class="params">(lua_State *L, CallInfo *ci)</span> </span>&#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  TValue *k;</span><br><span class="line">  StkId base;</span><br><span class="line">  <span class="keyword">const</span> Instruction *pc;</span><br><span class="line">  ......</span><br><span class="line">  base = ci-&gt;func + <span class="number">1</span>;  <span class="comment">// 函数在栈上的地址</span></span><br><span class="line">  <span class="comment">// 主解释循环</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Instruction i;  <span class="comment">// 当前被执行的指令</span></span><br><span class="line">    StkId ra;       <span class="comment">// 寄存器A(就是一个栈值的地址)</span></span><br><span class="line">    vmfetch();      <span class="comment">// pc指针加1并给ra寄存器赋值</span></span><br><span class="line">    lua_assert(base == ci-&gt;func + <span class="number">1</span>);</span><br><span class="line">    lua_assert(base &lt;= L-&gt;top &amp;&amp; L-&gt;top &lt; L-&gt;stack_last);</span><br><span class="line">    lua_assert(isIT(i) || (cast_void(L-&gt;top = base), <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 获取操作码</span></span><br><span class="line">    vmdispatch (GET_OPCODE(i)) &#123;</span><br><span class="line">      vmcase(OP_MOVE) &#123;  <span class="comment">// 移动指令OP_MOVE将寄存器B的值赋值个寄存A, /*	A B	R[A] := R[B] */</span></span><br><span class="line">        setobjs2s(L, ra, RB(i));</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">      vmcase(OP_LOADI) &#123;  <span class="comment">// 装载一个整形常量值到ra</span></span><br><span class="line">        lua_Integer b = GETARG_sBx(i);</span><br><span class="line">        setivalue(s2v(ra), b);</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>通过对源码的阅读，对Lua虚拟机的内部结构以及运行机制有更深入的理解。但是并不是所有细节和模块都进行了阅读，比如像Lua词法，语法和语义分析以及GC相关的代码就是直接跳过的。Lua本身也不是一篇文章就能理解完的，对于Lua虚拟机的学习先暂时告一段落。后续闲了会再对GC相关的代码进行阅读，至于词法，语法和语义分析这块的代码暂时不打算去学习，主要是在实际项目中暂时不需要这方面的内容。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Lua/" rel="tag"><i class="fa fa-tag"></i> Lua</a>
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"><i class="fa fa-tag"></i> 源码</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/11/05/Unity/Graphics/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" rel="next" title="Unity渲染管线介绍">
                  <i class="fa fa-chevron-left"></i> Unity渲染管线介绍
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/11/29/%E6%B8%B8%E6%88%8F/Map/%E5%85%AD%E8%BE%B9%E5%BD%A2%E7%BD%91%E6%A0%BC/" rel="prev" title="六边形网格">
                  六边形网格 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#文件结构"><span class="nav-number">1.</span> <span class="nav-text">文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#提供外部使用的头文件"><span class="nav-number">1.1.</span> <span class="nav-text">提供外部使用的头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心代码"><span class="nav-number">1.2.</span> <span class="nav-text">核心代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试"><span class="nav-number">1.3.</span> <span class="nav-text">调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库代码"><span class="nav-number">1.4.</span> <span class="nav-text">标准库代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释器和编译器"><span class="nav-number">1.5.</span> <span class="nav-text">解释器和编译器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心代码-1"><span class="nav-number">2.</span> <span class="nav-text">核心代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心结构"><span class="nav-number">2.1.</span> <span class="nav-text">核心结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心函数"><span class="nav-number">2.2.</span> <span class="nav-text">核心函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#helloworld"><span class="nav-number">3.</span> <span class="nav-text">HelloWorld</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张卫"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">张卫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/zw514159799" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;zw514159799" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Divad1111?tab=repositories" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Divad1111?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/qilezaitu" title="博客园 &amp;rarr; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;qilezaitu" rel="noopener" target="_blank"><i class="fa fa-fw fa-cnblogs"></i>博客园</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张卫</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">542k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:13</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

  

</body>
</html>
