<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="基础回顾 在正式分析UGUI源码前，让我们回顾一下，模型的组成，以及渲染。 模型组成 模型是由一系列的三角形组成，三角形又是由三个顶点构成的，每个顶点上保存了相关的顶点属性（顶点位置，顶点颜色，顶点UV，顶点法线，顶点切线）在Unity中使用Mesh类来表示。 模型渲染 模型筛选：  首先根据相机的Culling Mask剔除那些不需要此相机渲染的模型。 然后根据摄像机的视锥体大小，剔除完全在视锥">
<meta property="og:type" content="article">
<meta property="og:title" content="UGUI源码分析">
<meta property="og:url" content="http://yoursite.com/2021/08/04/Unity/UI/UGUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="张卫的博客">
<meta property="og:description" content="基础回顾 在正式分析UGUI源码前，让我们回顾一下，模型的组成，以及渲染。 模型组成 模型是由一系列的三角形组成，三角形又是由三个顶点构成的，每个顶点上保存了相关的顶点属性（顶点位置，顶点颜色，顶点UV，顶点法线，顶点切线）在Unity中使用Mesh类来表示。 模型渲染 模型筛选：  首先根据相机的Culling Mask剔除那些不需要此相机渲染的模型。 然后根据摄像机的视锥体大小，剔除完全在视锥">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/ugui/canvas_camera.png">
<meta property="og:image" content="http://yoursite.com/images/ugui/canvas_overlays.png">
<meta property="og:image" content="http://yoursite.com/images/ugui/graphic_class.png">
<meta property="og:image" content="http://yoursite.com/images/ugui/mesheffect_class.png">
<meta property="og:image" content="http://yoursite.com/images/ugui/offset.png">
<meta property="og:image" content="http://yoursite.com/images/ugui/rect.png">
<meta property="og:image" content="http://yoursite.com/images/ugui/layout.png">
<meta property="article:published_time" content="2021-08-04T09:52:28.000Z">
<meta property="article:modified_time" content="2025-04-26T11:06:24.132Z">
<meta property="article:author" content="张卫">
<meta property="article:tag" content="UI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/ugui/canvas_camera.png">

<link rel="canonical" href="http://yoursite.com/2021/08/04/Unity/UI/UGUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>UGUI源码分析 | 张卫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张卫的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Done is better than perfect</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/04/Unity/UI/UGUI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="张卫">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张卫的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          UGUI源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-04 17:52:28" itemprop="dateCreated datePublished" datetime="2021-08-04T17:52:28+08:00">2021-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-26 19:06:24" itemprop="dateModified" datetime="2025-04-26T19:06:24+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index">
                    <span itemprop="name">Unity</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="基础回顾">基础回顾</h1>
<p>在正式分析UGUI源码前，让我们回顾一下，模型的组成，以及渲染。</p>
<h2 id="模型组成">模型组成</h2>
<p>模型是由一系列的三角形组成，三角形又是由三个顶点构成的，每个顶点上保存了相关的顶点属性（顶点位置，顶点颜色，顶点UV，顶点法线，顶点切线）在Unity中使用Mesh类来表示。</p>
<h2 id="模型渲染">模型渲染</h2>
<p><strong>模型筛选：</strong></p>
<ol type="1">
<li>首先根据相机的Culling Mask剔除那些不需要此相机渲染的模型。</li>
<li>然后根据摄像机的视锥体大小，剔除完全在视锥体外的模型。</li>
</ol>
<p><strong>模型分类:</strong></p>
<p>Unity将根据需要渲染的模型Shader中RenderQueue对模型进行分类，分为不透明模型(小于2500)和透明模型(大于等于2500)。</p>
<p><strong>排序渲染模型:</strong></p>
<ol type="1">
<li>首先通过sortLayer和sortingOrder对不透明模型进行进行排序，越低的越先渲染；然后再通过Shader中的RenderQueue进行排序；再然后就通过包围盒中心点的深度（距离摄像机的位置）进行排序；最后如果深度相同则还可以通过ZBias进行深度调节。</li>
<li>透明物体同样的使用上述规则进行排序。</li>
</ol>
<a id="more"></a>
<p><strong>根据排序的结果逐个渲染模型:</strong></p>
<p>渲染一个模型主要分为以下2步：</p>
<ol type="1">
<li>设置渲染状态（提交模型数据，贴图，设置深度,模板和混合参数等 ）</li>
<li>调用绘制命令</li>
</ol>
<p>当然这个只是它的渲染顺序，并不是说最后渲染的物体就一定会进入颜色缓冲，最后还的看深度和模板测试的结果。</p>
<h1 id="显示组件渲染">显示组件（渲染）</h1>
<h2 id="设计结构">设计结构</h2>
<p>UGUI主要由显示组件，布局系统，事件系统，交互组件组成。这里主要介绍UGUI显示组件相关的几个核心类</p>
<ul>
<li><p><strong>UIBehaviour</strong>,
此类继承至MonoBehaviour，主要定义了UI组件的生命周期以及RectTransform的一些事件函数（比如：RectTransform的大小或层次结构的改变等）</p></li>
<li><p><strong>Canvas</strong>,
主要定义了渲染相关的参数，比如渲染模式，渲染顺序，使用的相机以及缩放因子等。此类也用来进行组织UI渲染和Mesh合并。Canvas的渲染，
在有相机(ScreenSpaceCamera和WorldSpace渲染模式)的情况下是在渲染透明物体阶段进行渲染的
<img src="/images/ugui/canvas_camera.png" alt="Canvs_Camera" />
在没有相机（ScreenSpaceOverlay渲染模式）的情况下是在所有渲染完成后在进行单独渲染的，所以能够保证Canvas在最上面。
<img src="/images/ugui/canvas_overlays.png"
alt="Canvs_Camera" /></p></li>
<li><p><strong>ICanvasElement</strong>,
此接口是所有Canvas元素需要实现的接口，接口中最重要的函数就是Rebuild函数和其关联的transform字段，当一个Canvas元素需要重建时则会调用此函数。Canvas元素包含显示组件和交互组件。</p></li>
<li><p><strong>CanvasRenderer</strong>,
定义了显示组件需要用到的Mesh，材质，纹理，是否剔除，裁剪区域以及深度信息等。Canvas则会根据这些信息进行排序、动态合并Mesh和最终的渲染。</p></li>
<li><p><strong>CanvasUpdateRegistry</strong>,
此用用于管理需要更新的Canvas元素，更新主要分为两类，一类是：布局更新，另一类是：Graphic更新（包含UpdateGeometry和UpdateMaterial）Canvas元素的更新主要包含以下5个阶段：
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CanvasUpdate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//布局前</span></span><br><span class="line">    Prelayout = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//布局中</span></span><br><span class="line">    Layout = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//布局后</span></span><br><span class="line">    PostLayout = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">//渲染前</span></span><br><span class="line">    PreRender = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">//渲染后</span></span><br><span class="line">    LatePreRender = <span class="number">4</span>,</span><br><span class="line">    <span class="comment">//定义的最大值</span></span><br><span class="line">    MaxUpdateValue = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
CanvasUpdateRegistry类在其构造函数中监听了Canvas将要渲染的事件，当收到此事件后则会进行上述几个阶段的更新，核心代码如下：
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此类是个单例</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CanvasUpdateRegistry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Canvas.willRenderCanvases += PerformUpdate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心的更新函数，所有需要更新的Canvas元素都不被添加到m_LayoutRebuildQueue或m_GraphicRebuildQueue列表中，如果没有Canvas元素Dirty则队列里面是空</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在Profile里可以查看完成一次完整的更新需要多少时间</span></span><br><span class="line">    UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">    CleanInvalidItems();</span><br><span class="line"></span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据父节点数量进行排序</span></span><br><span class="line">    m_LayoutRebuildQueue.Sort(s_SortLayoutFunction);</span><br><span class="line">    <span class="comment">//开始更新布局</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)CanvasUpdate.PostLayout; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rebuild = instance.m_LayoutRebuildQueue[j];</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(rebuild))</span><br><span class="line">                    rebuild.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, rebuild.transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//布局更新完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_LayoutRebuildQueue.Count; ++i)</span><br><span class="line">        m_LayoutRebuildQueue[i].LayoutComplete();</span><br><span class="line"></span><br><span class="line">    instance.m_LayoutRebuildQueue.Clear();</span><br><span class="line">    m_PerformingLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//布局完后进行裁剪剔除 RectMask2D的方式，与传统的Mask使用模板(Stencil)缓冲不同，RectMask2D是直接在应用层级根据Mask的矩形区域直接进行裁剪</span></span><br><span class="line">    ClipperRegistry.instance.Cull();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始Graphic更新</span></span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = (<span class="keyword">int</span>)CanvasUpdate.PreRender; i &lt; (<span class="keyword">int</span>)CanvasUpdate.MaxUpdateValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; instance.m_GraphicRebuildQueue.Count; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> element = instance.m_GraphicRebuildQueue[k];</span><br><span class="line">                <span class="keyword">if</span> (ObjectValidForUpdate(element))</span><br><span class="line">                    element.Rebuild((CanvasUpdate)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogException(e, instance.m_GraphicRebuildQueue[k].transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Graphic更新完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_GraphicRebuildQueue.Count; ++i)</span><br><span class="line">        m_GraphicRebuildQueue[i].GraphicUpdateComplete();</span><br><span class="line"></span><br><span class="line">    instance.m_GraphicRebuildQueue.Clear();</span><br><span class="line">    m_PerformingGraphicUpdate = <span class="literal">false</span>;</span><br><span class="line">    UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Canvas元素的布局Dirty会调用此函数记录一下应该对Canvas元数进行布局更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForLayoutRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForLayoutRebuild(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Canvas元素的Graphic Dirty会调用此函数记录一下应该对Canvas元数进行Graphic更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterCanvasElementForGraphicRebuild</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    instance.InternalRegisterCanvasElementForGraphicRebuild(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>总结：设计的主要结构就是Canvas元素负责更新CanvasRenderer中的Mesh,材质等，然后Canvas则管理CanvasRenderer中Mesh的合并，并根据其渲染模式进行渲染。接下来我们将继续探索Canvas元素的具体更新流程。</p>
<h2 id="显示组件rawimageimage和text">显示组件RawImage，Image和Text</h2>
<p>显示组件关联的几个核心类：</p>
<ul>
<li><p><strong>Graphic</strong>,
继承至UIBehaviour并实现了ICanvasElement是所有显示组件的基类，此类维护了显示组件的生命周期，管理了布局，顶点和材质改变，一旦顶点或材质改变则会将自己添加到<strong>CanvasUpdateRegistry</strong>的更新列表里，在下帧则会进行重建（调用Rebuild函数）。如果布局改变则会将自己添加到LayoutRebuilder的队列里，在下一帧进行构建。
<strong>Graphic</strong>的核心函数：</p>
<ol type="1">
<li><p><strong>Graphic.Rebuild</strong>,
此函数会负责具体的材质更新和Mesh的构建； <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate update</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canvasRenderer == <span class="literal">null</span> || canvasRenderer.cull)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.PreRender:</span><br><span class="line">            <span class="keyword">if</span> (m_VertsDirty)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 此函数会调用DoMeshGeneration进行Mesh的构建</span></span><br><span class="line">                UpdateGeometry(); </span><br><span class="line">                m_VertsDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m_MaterialDirty)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// 更新材质到CanvasRenderer</span></span><br><span class="line">                UpdateMaterial();</span><br><span class="line">                m_MaterialDirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Graphic.DoMeshGeneration</strong>,
此函数负责具体的Mesh构建（基础Mesh和附加Mesh（描边和阴影Mesh的生成））；
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoMeshGeneration</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 矩形有大小的大小的时候，才去构建Mesh，否则就清空顶点</span></span><br><span class="line">    <span class="keyword">if</span> (rectTransform != <span class="literal">null</span> &amp;&amp; rectTransform.rect.width &gt;= <span class="number">0</span> &amp;&amp; rectTransform.rect.height &gt;= <span class="number">0</span>)</span><br><span class="line">        OnPopulateMesh(s_VertexHelper);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s_VertexHelper.Clear(); <span class="comment">// clear the vertex helper so invalid graphics dont draw.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是获取修改顶点的组件 这类组件的基类是class BaseMeshEffect：UIBehaviour, IMeshModifier</span></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    GetComponents(<span class="keyword">typeof</span>(IMeshModifier), components);</span><br><span class="line">    <span class="comment">// 具体的顶点修改在BaseMeshEffect的子类的ModifyMesh函数里进行，具体有哪些Mesh效果的子类，在下一节进行介绍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">        ((IMeshModifier)components[i]).ModifyMesh(s_VertexHelper);</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将顶点信息，填充到Mesh里， 并设置个CanvasRenderer对象</span></span><br><span class="line">    s_VertexHelper.FillMesh(workerMesh);</span><br><span class="line">    canvasRenderer.SetMesh(workerMesh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Graphic.OnPopulateMesh</strong>,
此函数主要是用于派生类去覆写Mesh的基础构建； <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper vh</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将矩形调整为像素对其的</span></span><br><span class="line">    <span class="keyword">var</span> r = GetPixelAdjustedRect();</span><br><span class="line">    <span class="keyword">var</span> v = <span class="keyword">new</span> Vector4(r.x, r.y, r.x + r.width, r.y + r.height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始构建顶点</span></span><br><span class="line">    Color32 color32 = color;</span><br><span class="line">    vh.Clear();</span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.x, v.y), color32, <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">0f</span>));</span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.x, v.w), color32, <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">1f</span>));</span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.z, v.w), color32, <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">1f</span>));</span><br><span class="line">    vh.AddVert(<span class="keyword">new</span> Vector3(v.z, v.y), color32, <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义顶点构成的三角形，这里构建了2个三角形，刚好构成一个Quad</span></span><br><span class="line">    vh.AddTriangle(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    vh.AddTriangle(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Graphic.materialForRendering</strong>，此字段用于获取渲染时使用的材质，这主要做了一个提供修改材质的机制，当对象上有IMaterialModifier接口的组件对象时，则会使用它的材质进行渲染，主要用于Mask的材质修改，当然你也可以新建一个自定义的组件用于修改渲染时的材质。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Material materialForRendering</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取一个Component的列表， 并回去自己对象上实现了IMaterialModifier接口的组件</span></span><br><span class="line">        <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">        GetComponents(<span class="keyword">typeof</span>(IMaterialModifier), components);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用IMaterialModifier接口的GetModifiedMaterial的函数，此函数返回修改后的材质</span></span><br><span class="line">        <span class="keyword">var</span> currentMat = material;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            currentMat = (components[i] <span class="keyword">as</span> IMaterialModifier).GetModifiedMaterial(currentMat);</span><br><span class="line">        ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">        <span class="keyword">return</span> currentMat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Graphic.Raycast</strong>,
此函数由于检查是否能被击中</p></li>
</ol></li>
<li><p><strong>MaskableGraphic</strong>,
继承至Graphic新增了Mask的支持，Mask相关的内容，在下一节去学习。</p></li>
<li><p><strong>VertexHelper</strong>,
此类是一个辅助产生Mesh的类，记录每个顶点以及顶点的相关属性（顶点位置，顶点颜色，顶点UV，顶点法线，顶点切线和三角形索引）。</p></li>
<li><p><strong>RawImage</strong>,
直接使用一张纹理显示一张图片，一个RawImage就是一个Drawcall，此类一版用于背景。核心函数就是覆写的OnPopulateMesh支持了uv的修改。</p></li>
<li><p><strong>Imge</strong>,
此类也是显示一张图片，但是显示的不是一张完整的纹理而是显示一个图集中的一个Sprite。支持Simple,
Sliced,
Tiled和Filled类型。在OnPopulateMesh函数中根据不同的类型进行顶点的生成。</p></li>
<li><p><strong>Text</strong>,
此类是用来显示文字的。此类在OnPopulateMesh函数中，通过TextGenerator类进行顶点的生成，并将每4个顶点组成一个Quad。</p></li>
</ul>
<p>类图： <img src="/images/ugui/graphic_class.png"
alt="Graphic_Class" /></p>
<h2 id="mask实现原理">Mask实现原理</h2>
<p>UGUI在实现Mask的时候有两种方式：</p>
<ol type="1">
<li>使用模板(Stencil)缓冲进行裁剪，缺点是在Mask下没有任何显示对象的情况下都需要2个Drawcall，一个Drawcall绘制蒙版，另一个Drawcall清除绘制的蒙版，并且还会打断合批。</li>
<li>直接在应用层级根据Mask的矩形区域进行裁剪剔除，这样保证在绘制前，那些超出Mask区域的顶点已经被裁剪，优点是不需要额外的2个Drawcall，缺点是需要CPU进行额外的裁剪操作，对象越多CPU执行裁剪的消耗就越多，并且也只能进行2D对象的裁剪。</li>
</ol>
<p>所用我们在选用蒙版的时候也要综合考虑两种方式的优缺点，在子对象比较多，CPU成为了性能瓶颈的时候，可以考虑使用第1种方式，如果子对象比较少则可以使用第2种方式；还的综合考虑合批的影响。</p>
<h3 id="模板stencil缓冲实现mask">模板(Stencil)缓冲实现Mask</h3>
<ul>
<li><p><strong>IMaskable</strong>,
实现这个接口的元素是可以被蒙版裁剪剔除的，现在只有MaskableGraphic实现了这个接口，也就是说，上一节讨论的所有显示组件（RawImage，Image和Text）都能被蒙版裁剪剔除。就一个接口RecalculateMasking。</p></li>
<li><p><strong>Mask</strong>,
此类主要实现了IMaterialModifier接口中的GetModifiedMaterial函数，用于修改显示组件使用的材质，参见上一节的Graphic.materialForRendering。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mask类的GetModifiedMaterial函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否启用了Mask组件</span></span><br><span class="line">    <span class="keyword">if</span> (!MaskEnabled())</span><br><span class="line">        <span class="keyword">return</span> baseMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在父节点中获取最近的overringsort的Canvas如果没则获取最顶层的Canvas</span></span><br><span class="line">    <span class="keyword">var</span> rootSortCanvas = MaskUtilities.FindRootSortOverrideCanvas(transform);</span><br><span class="line">    <span class="comment">// 获取自己在继承结构中的深度，用于后续的Stencil计算</span></span><br><span class="line">    <span class="keyword">var</span> stencilDepth = MaskUtilities.GetStencilDepth(transform, rootSortCanvas);</span><br><span class="line">    <span class="comment">// 蒙版不能嵌套超过8层（因为stencil buffer每个像素只有8个bit）</span></span><br><span class="line">    <span class="keyword">if</span> (stencilDepth &gt;= <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">"Attempting to use a stencil mask with depth &gt; 8"</span>, gameObject);</span><br><span class="line">        <span class="keyword">return</span> baseMaterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义蒙版的Bit值，用于后续的计算，每个深度的Mask占用一位bit</span></span><br><span class="line">    <span class="keyword">int</span> desiredStencilBit = <span class="number">1</span> &lt;&lt; stencilDepth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是最外层的Mask，我们则直接替换stencil buffer中的值为1</span></span><br><span class="line">    <span class="keyword">if</span> (desiredStencilBit == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据基础材质，创建带stencil参数的材质，直接替换stencil的值为1，并且根据如果要显示模板对应的显示对象，那么就让让所有颜色通道通过，否则就不通过任何颜色通道</span></span><br><span class="line">        <span class="keyword">var</span> maskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Replace, CompareFunction.Always, m_ShowMaskGraphic ? ColorWriteMask.All : <span class="number">0</span>);</span><br><span class="line">        StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">        m_MaskMaterial = maskMaterial;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当Mask下的子对象渲染完后，Unity会为我们再次渲染这个Mask对象，作用是为了清除设置的stencil buffer中的对应值。最外层的Mask的子对象绘制完成后，直接就将stencil buffer的值清零了。</span></span><br><span class="line">        <span class="keyword">var</span> unmaskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Zero, CompareFunction.Always, <span class="number">0</span>);</span><br><span class="line">        StencilMaterial.Remove(m_UnmaskMaterial);</span><br><span class="line">        m_UnmaskMaterial = unmaskMaterial;</span><br><span class="line">        <span class="comment">//这表示在所有子对象渲染完后，需要使用此材质再次渲染此对象</span></span><br><span class="line">        graphic.canvasRenderer.popMaterialCount = <span class="number">1</span>;</span><br><span class="line">        graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_MaskMaterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建写入内层Mask的材质，这里把stencil值写入后，在渲染它的子对象时，需要匹配stencil buffer的值，在MaskableGraphic.GetModifiedMaterial中根据m_StencilValue的进行模板测试，如果模板测试未通过则不绘制制定区域，如果通过则绘制</span></span><br><span class="line">    <span class="keyword">var</span> maskMaterial2 = StencilMaterial.Add(baseMaterial, desiredStencilBit | (desiredStencilBit - <span class="number">1</span>), StencilOp.Replace, CompareFunction.Equal, m_ShowMaskGraphic ? ColorWriteMask.All : <span class="number">0</span>, desiredStencilBit - <span class="number">1</span>, desiredStencilBit | (desiredStencilBit - <span class="number">1</span>));</span><br><span class="line">    StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">    m_MaskMaterial = maskMaterial2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建内层清理stencil buffer值的材质</span></span><br><span class="line">    graphic.canvasRenderer.hasPopInstruction = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> unmaskMaterial2 = StencilMaterial.Add(baseMaterial, desiredStencilBit - <span class="number">1</span>, StencilOp.Replace, CompareFunction.Equal, <span class="number">0</span>, desiredStencilBit - <span class="number">1</span>, desiredStencilBit | (desiredStencilBit - <span class="number">1</span>));</span><br><span class="line">    StencilMaterial.Remove(m_UnmaskMaterial);</span><br><span class="line">    m_UnmaskMaterial = unmaskMaterial2;</span><br><span class="line">    graphic.canvasRenderer.popMaterialCount = <span class="number">1</span>;</span><br><span class="line">    graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_MaskMaterial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaskableGraphic类的GetModifiedMaterial函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toUse = baseMaterial;</span><br><span class="line">    <span class="comment">// 根据层次结构(Hierarchy)的深度获取m_StencilValue，如果不需要maskable这直接使用0</span></span><br><span class="line">    <span class="keyword">if</span> (m_ShouldRecalculateStencil)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maskable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rootCanvas = MaskUtilities.FindRootSortOverrideCanvas(transform);</span><br><span class="line">            m_StencilValue = MaskUtilities.GetStencilDepth(transform, rootCanvas);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m_StencilValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_ShouldRecalculateStencil = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果需要进行模板计算则构建新的stencil材质， isMaskingGraphic表示要排除用于模板绘制的显示对象，如果stencil buffer值和参考值相等，则通过次像素，否则不通过， stencil buffer值是在Mask.GetModifiedMaterial函数中生成的材质设置的</span></span><br><span class="line">    <span class="keyword">if</span> (m_StencilValue &gt; <span class="number">0</span> &amp;&amp; !isMaskingGraphic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> maskMat = StencilMaterial.Add(toUse, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, StencilOp.Keep, CompareFunction.Equal, ColorWriteMask.All, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">        m_MaskMaterial = maskMat;</span><br><span class="line">        toUse = m_MaskMaterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不用使用stencil材质，则直接使用原材质进行渲染</span></span><br><span class="line">    <span class="keyword">return</span> toUse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>MaskUtilities</strong>,
两种类型的Mask都用的工具类。</p></li>
<li><p><strong>StencilMaterial</strong>,
模板(Stencil)缓冲的材质生成类，主要的功能是基于基础材质添加上模板参数生成新的材质给Mask使用，也使用了引用计数的方式对相同的材质进行了缓存，避免重复创建相同的。核心代码如下：
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Material <span class="title">Add</span>(<span class="params">Material baseMat, <span class="keyword">int</span> stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask, <span class="keyword">int</span> readMask, <span class="keyword">int</span> writeMask</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((stencilID &lt;= <span class="number">0</span> &amp;&amp; colorWriteMask == ColorWriteMask.All) || baseMat == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="comment">//...... 缓存引用的代码省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置shader参数</span></span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">"_Stencil"</span>, stencilID);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">"_StencilOp"</span>, (<span class="keyword">int</span>)operation);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">"_StencilComp"</span>, (<span class="keyword">int</span>)compareFunction);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">"_StencilReadMask"</span>, readMask);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">"_StencilWriteMask"</span>, writeMask);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">"_ColorMask"</span>, (<span class="keyword">int</span>)colorWriteMask);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">"_UseUIAlphaClip"</span>, newEnt.useAlphaClip ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newEnt.useAlphaClip)</span><br><span class="line">        newEnt.customMat.EnableKeyword(<span class="string">"UNITY_UI_ALPHACLIP"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newEnt.customMat.DisableKeyword(<span class="string">"UNITY_UI_ALPHACLIP"</span>);</span><br><span class="line"></span><br><span class="line">    m_List.Add(newEnt);</span><br><span class="line">    <span class="keyword">return</span> newEnt.customMat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3
id="应用程序裁剪mask实现rectmask2d">应用程序裁剪Mask实现RectMask2D</h3>
<ul>
<li><strong>IClipper</strong>,
定义了裁剪器接口，现在只有RectMask2D实现了此接口，核心函数PerformClipping。</li>
<li><strong>IClippable</strong>,
定义了能够被裁剪的接口，现在只有MaskableGraphic实现了此接口，核心函数RecalculateClipping，Cull和SetClipRect。</li>
<li><strong>ClipperRegistry</strong>,
此类缓存了所有的IClipper对象,核心函数Cull，在布局完后调用，对所有的裁剪器调用PerformClipping进行裁剪。</li>
<li><strong>RectangularVertexClipper</strong>,
唯一一个函数GetCanvasRect获取在Canvas下的Rect信息。</li>
<li><strong>Clipping</strong>,
唯一一个函数FindCullAndClipWorldRect查找所有RectMask2D的公共Rect区域.</li>
<li><strong>RectMask2D</strong>,
此类实现了IClipper接口，核心函数就是IClipper接口中的PerformClipping，此函数执行计算了裁剪的矩形区域，并将计算的裁剪区域设置给了IClippable接口的对象，现在只有MaskableGraphic类，MaskableGraphic又将裁剪区域设置给了CanvasRenderer，每个显示组件的裁剪是Unity底层去进行裁剪的。核心代码如下：
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PerformClipping</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查有没有Canvas对象</span></span><br><span class="line">    <span class="keyword">if</span> (ReferenceEquals(Canvas, <span class="literal">null</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当结构改变时需要重新获取RectMask2D的对象列表（存在嵌套）</span></span><br><span class="line">    <span class="keyword">if</span> (m_ShouldRecalculateClipRects)</span><br><span class="line">    &#123;</span><br><span class="line">        MaskUtilities.GetRectMasksForClip(<span class="keyword">this</span>, m_Clippers);</span><br><span class="line">        m_ShouldRecalculateClipRects = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有RectMask2D的公共区域</span></span><br><span class="line">    <span class="keyword">bool</span> validRect = <span class="literal">true</span>;</span><br><span class="line">    Rect clipRect = Clipping.FindCullAndClipWorldRect(m_Clippers, <span class="keyword">out</span> validRect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查自己的裁剪区域是否和公共的裁剪区域有交集，如果没有则剔除这个RectMask2D</span></span><br><span class="line">    RenderMode renderMode = Canvas.rootCanvas.renderMode;</span><br><span class="line">    <span class="keyword">bool</span> maskIsCulled =</span><br><span class="line">        (renderMode == RenderMode.ScreenSpaceCamera || renderMode == RenderMode.ScreenSpaceOverlay) &amp;&amp;</span><br><span class="line">        !clipRect.Overlaps(rootCanvasRect, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maskIsCulled)</span><br><span class="line">    &#123;</span><br><span class="line">        clipRect = Rect.zero;</span><br><span class="line">        validRect = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果公共裁剪区域变化，则更新</span></span><br><span class="line">    <span class="keyword">if</span> (clipRect != m_LastClipRectCanvasSpace)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新IClippable对象，保留对其他非MaskableGraphic对象的裁剪区域设置</span></span><br><span class="line">        <span class="keyword">foreach</span> (IClippable clipTarget <span class="keyword">in</span> m_ClipTargets)</span><br><span class="line">        &#123;</span><br><span class="line">            clipTarget.SetClipRect(clipRect, validRect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对MaskableGraphic对象的裁剪区域设置，并将完全不在这个clipRect内的MaskableGraphic标记为剔除</span></span><br><span class="line">        <span class="keyword">foreach</span> (MaskableGraphic maskableTarget <span class="keyword">in</span> m_MaskableTargets)</span><br><span class="line">        &#123;</span><br><span class="line">            maskableTarget.SetClipRect(clipRect, validRect);</span><br><span class="line">            maskableTarget.Cull(clipRect, validRect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_ForceClip)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 同上，</span></span><br><span class="line">        <span class="keyword">foreach</span> (IClippable clipTarget <span class="keyword">in</span> m_ClipTargets)</span><br><span class="line">        &#123;</span><br><span class="line">            clipTarget.SetClipRect(clipRect, validRect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (MaskableGraphic maskableTarget <span class="keyword">in</span> m_MaskableTargets)</span><br><span class="line">        &#123;</span><br><span class="line">            maskableTarget.SetClipRect(clipRect, validRect);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maskableTarget.canvasRenderer.hasMoved)</span><br><span class="line">                maskableTarget.Cull(clipRect, validRect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (MaskableGraphic maskableTarget <span class="keyword">in</span> m_MaskableTargets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Case 1170399 - hasMoved is not a valid check when animating on pivot of the object</span></span><br><span class="line">            maskableTarget.Cull(clipRect, validRect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_LastClipRectCanvasSpace = clipRect;</span><br><span class="line">    m_ForceClip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    UpdateClipSoftness();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结：ClipperRegistry.Cull会在每帧布局完成后调用，此函数执行所有IClipper的裁剪计算，并将计算好的裁剪矩形区域通过MaskableGraphic.SetClipRect传递给CanvasRenderer对象，最后Unity内部根据这些裁剪矩形来进行顶点的裁剪。</p>
<h2 id="mesh效果">Mesh效果</h2>
<p>Mesh效果是在，基础Mesh构建完后，再重修或添加新的顶点构成最终的Mesh。UGUI自带的Mesh效果有Outline，PositionAsUV1和Shadow效果。</p>
<ul>
<li><strong>IMeshModifier</strong>, 定义了ModifyMesh函数</li>
<li><strong>BaseMeshEffect</strong>,
Mesh效果的基类，核心函数是接口IMeshModifier的ModifyMesh函数。</li>
<li><strong>Outline</strong>, 在ModifyMesh添加描边的顶点。</li>
<li><strong>PositionAsUV1</strong>,
将顶点的位置设置为该顶点的UV1（一般是法线贴图坐标），为图片或者文字添加法线贴图效果。</li>
</ul>
<p>类图： <img src="/images/ugui/mesheffect_class.png"
alt="MeshEffectClass.png" /></p>
<h1 id="布局系统">布局系统</h1>
<h2 id="布局基础-recttransform">布局基础-RectTransform</h2>
<p>RectTransform组件是Transform组件对应的2D表示。
其中Transform表示单个点，RectTransform表示可以放置UI元素的矩形。如果RectTransform的父项也是RectTransform，则子项RectTransform也可以指定它相对于父矩形的位置和大小。RectTransform用于存储和操作矩形的位置、大小和锚点，并支持基于父RectTransform的各种形式的缩放。</p>
<p><strong>基础属性：</strong></p>
<ul>
<li><strong>轴心点(Pivot)</strong>，轴心点定义了物体自身原点的位置以及作为旋转和缩放基点。</li>
<li><strong>锚点(Anchors)</strong>，子对象锚定在父对象上的点，使用RectTransform的anchorMin和anchorMax两个属性表示，anchorMin和anchorMax两个属性的范围是[0,1],anchorMin表示锚定在父对象<strong>左下角的位置</strong>，anchorMax表示锚定在父对象<strong>右上角的位置</strong>，值[0,1]表示是锚定在父对象<strong>X轴</strong>和<strong>Y轴</strong>上的百分百位置。锚定在父对象上，意思是子对象的Pivot（轴心点）到（父对象上）Anchors（锚点）的相对位置不变。</li>
<li><strong>位置</strong>，子对象在父对象下的位置，有两种：一种是：localPosition，是基于<strong>轴心点</strong>的一个本地位置；另一种：anchoredPosition和anchoredPosition3D,
是基于锚点的位置(就是轴心点在锚点空间下的坐标)，如下图： <img
src="/images/ugui/anchoredPosition.png"
alt="anchoredPosition.png" /></li>
<li><strong>偏移(offset)</strong>，指的是RectTransform的左下角或右上角到锚点的左下角或右上角的偏移值，即RectTransform的offsetMin和offsetMax字段。如下图：
<img src="/images/ugui/offset.png" alt="offset.png" /></li>
<li><strong>sizeDelta</strong>，表示的是RectTransform的区域与Anchors区域的差值，即offsetMax
- offsetMin。<strong>在锚点重合的时候，offsetMax -
offsetMin刚好是RectTransform的宽度和高度</strong>。</li>
<li><strong>矩形区域(rect)</strong>，
RectTransform对象的矩形区域通过rect字段表示，其中x,y是RectTransform左下角到轴心点（Pivot）的相对位置，with和height是RectTransform的宽度和高度。
<img src="/images/ugui/rect.png" alt="rect.png" /></li>
<li><strong>SetSizeWithCurrentAnchors</strong>，此函数设置大小。</li>
<li><strong>SetInsetAndSizeFromParentEdge</strong>，此函数设置边距和大小（会改变锚点（Anchors））。</li>
<li><strong>RectTransformUtility</strong>，此类是RectTransform的工具类，提供了一些便利的方法（像：坐标转换、坐标获取、范围测试等）。</li>
</ul>
<p>布局的基础知识了解完了，接下来看下UGUI自带的布局器。</p>
<h2 id="布局器">布局器</h2>
<p>布局器大致很两类，一类控制自己，另一类控制子对象。</p>
<h3 id="控制自己">控制自己</h3>
<ul>
<li><strong>ILayoutElement</strong>，
定义布局元素的相关属性和方法（CalculateLayoutInputHorizontal，
CalculateLayoutInputVertical，minWidth/Height, preferredWidth/Height,
flexibleWidth/Height）。</li>
<li><strong>LayoutElement</strong>，
覆盖对象的布局元素参数，使用这个组件定义的大小。</li>
<li><strong>ILayoutSelfController</strong>，ILayoutElement负责计算布局，ILayoutController负责更新布局，ILayoutSelfController直接继承至ILayoutController，其中两个核心函数（SetLayoutHorizontal和SetLayoutVertical）。</li>
<li><strong>LayoutUtility</strong>， 对获取布局元素中的min,
preferred和flexible便捷的获取，并且获取优先级最高的。</li>
<li><strong>AspectRatioFitter</strong>，调整自身的大小以适应指定的纵横比。</li>
<li><strong>ContentSizeFitter</strong>，根据自身内容调整RectTransfrom的大小。</li>
</ul>
<h3 id="控制子对象">控制子对象</h3>
<ul>
<li><strong>ILayoutGroup</strong>，ILayoutElement负责计算布局，ILayoutController负责更新布局，ILayoutGroup直接继承至ILayoutController，其中两个核心函数（SetLayoutHorizontal和SetLayoutVertical）。</li>
<li><strong>LayoutGroup</strong>，所有控制子对象布局器的基类。主要完成的工作包括：定义对其参数以及相关的操作，获取有效的布局子对象和获取布局对象总的min,
preferred和flexible的值。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">GetStartOffset</span>(<span class="params"><span class="keyword">int</span> axis, <span class="keyword">float</span> requiredSpaceWithoutPadding</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> requiredSpace = requiredSpaceWithoutPadding + (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical);</span><br><span class="line">    <span class="keyword">float</span> availableSpace = rectTransform.rect.size[axis];</span><br><span class="line">    <span class="keyword">float</span> surplusSpace = availableSpace - requiredSpace;</span><br><span class="line">    <span class="keyword">float</span> alignmentOnAxis = GetAlignmentOnAxis(axis);</span><br><span class="line">    <span class="keyword">return</span> (axis == <span class="number">0</span> ? padding.left : padding.top) + surplusSpace * alignmentOnAxis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>HorizontalOrVerticalLayoutGroup</strong>,
水平或垂直布局的基类，核心函数CalcAlongAxis计算自己的总的大小和SetChildrenAlongAxis设置子的位置和大小。</li>
<li><strong>HorizontalLayoutGroup和VerticalLayoutGroup</strong>,
继承至HorizontalOrVerticalLayoutGroup这个类，分别在计算和设置函数中调用了HorizontalOrVerticalLayoutGroup类的两个核心函数。</li>
<li><strong>GridLayoutGroup</strong>， 网格布局的。</li>
<li><strong>LayoutRebuilder</strong>，此类是RectTransform对应的布局重建器，核心函数MarkLayoutForRebuild关联一个需要布局重建的RectTransfrom，Rebuild函数（ICanvasElement的接口函数）负责布局重建，Rebuild函数是在Canvas更新循环（CanvasUpdateRegistry）的布局阶段进行调用的（常见前面章节）。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联LayoutRebuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MarkLayoutForRebuild</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查输入参数</span></span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span> || rect.gameObject == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到顶层的布局器，如果没有就把传入的对象标记为需要重建的，如果有顶层的组布局器，子布局器就不用重新计算了，因为父布局器计算算的时候，会递归计算所有子对象（在PerformLayoutCalculation，和PerformLayoutControl函数中会进行递归处理）</span></span><br><span class="line">    <span class="keyword">var</span> comps = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    <span class="keyword">bool</span> validLayoutGroup = <span class="literal">true</span>;</span><br><span class="line">    RectTransform layoutRoot = rect;</span><br><span class="line">    <span class="keyword">var</span> parent = layoutRoot.parent <span class="keyword">as</span> RectTransform;</span><br><span class="line">    <span class="keyword">while</span> (validLayoutGroup &amp;&amp; !(parent == <span class="literal">null</span> || parent.gameObject == <span class="literal">null</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        validLayoutGroup = <span class="literal">false</span>;</span><br><span class="line">        parent.GetComponents(<span class="keyword">typeof</span>(ILayoutGroup), comps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; comps.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> cur = comps[i];</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span> &amp;&amp; cur <span class="keyword">is</span> Behaviour &amp;&amp; ((Behaviour)cur).isActiveAndEnabled)</span><br><span class="line">            &#123;</span><br><span class="line">                validLayoutGroup = <span class="literal">true</span>;</span><br><span class="line">                layoutRoot = parent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent = parent.parent <span class="keyword">as</span> RectTransform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查时候有效，无效的则不用添加到布局更新里了</span></span><br><span class="line">    <span class="keyword">if</span> (layoutRoot == rect &amp;&amp; !ValidController(layoutRoot, comps))</span><br><span class="line">    &#123;</span><br><span class="line">        ListPool&lt;Component&gt;.Release(comps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个LayoutRebuilder并且关联传入的RectTransform对象rect，并将其添加到CanvasUpdateRegistry的m_LayoutRebuildQueue列表里，在下一次更新的时候则会计算布局，如果需要立即更新则可以调用LayoutRebuilder.ForceRebuildLayoutImmediate函数。</span></span><br><span class="line">    MarkLayoutRootForRebuild(layoutRoot);</span><br><span class="line">    ListPool&lt;Component&gt;.Release(comps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行布局计算并布局</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (executing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.Layout:</span><br><span class="line">            <span class="comment">// 下面的每个函数都会递归调用遍历完所有的子布局元素（ILayoutElement），在遍历每个对象时都会通过调用回调函数将当前操作的对象回传并这里调用当前对象自己的计算和控制布局</span></span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputHorizontal());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutHorizontal());</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputVertical());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutVertical());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/images/ugui/layout.png" alt="rect.png" /></li>
</ul>
<h2 id="屏幕适配">屏幕适配</h2>
<ul>
<li><strong>CanvasScaler</strong>,
定义几种缩放模式，此类是主要是计算Canvas的缩放因子（Canvas.scaleFactor）,每种缩放模式计算缩放因子的方式不一样，这里主要看哈ScaleWithScreenSize模式的缩放因子计算
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ScaleMode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 位置和大小是直接对应屏幕上的像素的</span></span><br><span class="line">    ConstantPixelSize,</span><br><span class="line">    <span class="comment">// 根据设计分辨率进行缩缩放</span></span><br><span class="line">    ScaleWithScreenSize,</span><br><span class="line">    <span class="comment">// 位置和大小都是通过物理单位（Centimeters， Millimeters， Inches， Points和Picas）标定的</span></span><br><span class="line">    ConstantPhysicalSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandleScaleWithScreenSize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取屏幕大小</span></span><br><span class="line">    Vector2 screenSize = <span class="keyword">new</span> Vector2(Screen.width, Screen.height);</span><br><span class="line">    <span class="comment">// 处理多显示的情况</span></span><br><span class="line">    <span class="keyword">int</span> displayIndex = m_Canvas.targetDisplay;</span><br><span class="line">    <span class="keyword">if</span> (displayIndex &gt; <span class="number">0</span> &amp;&amp; displayIndex &lt; Display.displays.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        Display disp = Display.displays[displayIndex];</span><br><span class="line">        screenSize = <span class="keyword">new</span> Vector2(disp.renderingWidth, disp.renderingHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的屏幕匹配模式进行计算</span></span><br><span class="line">    <span class="keyword">float</span> scaleFactor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (m_ScreenMatchMode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ScreenMatchMode.MatchWidthOrHeight:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用宽，高或宽和高的中间值来缩放Canvas</span></span><br><span class="line">            <span class="comment">// We take the log of the relative width and height before taking the average.</span></span><br><span class="line">            <span class="comment">// Then we transform it back in the original space.</span></span><br><span class="line">            <span class="comment">// the reason to transform in and out of logarithmic space is to have better behavior.</span></span><br><span class="line">            <span class="comment">// If one axis has twice resolution and the other has half, it should even out if widthOrHeight value is at 0.5.</span></span><br><span class="line">            <span class="comment">// In normal space the average would be (0.5 + 2) / 2 = 1.25</span></span><br><span class="line">            <span class="comment">// In logarithmic space the average is (-1 + 1) / 2 = 0</span></span><br><span class="line">            <span class="keyword">float</span> logWidth = Mathf.Log(screenSize.x / m_ReferenceResolution.x, kLogBase);</span><br><span class="line">            <span class="keyword">float</span> logHeight = Mathf.Log(screenSize.y / m_ReferenceResolution.y, kLogBase);</span><br><span class="line">            <span class="keyword">float</span> logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);</span><br><span class="line">            scaleFactor = Mathf.Pow(kLogBase, logWeightedAverage);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ScreenMatchMode.Expand:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 保证缩放后Canvas的大小不小于设计分辨率（保证能够铺满全屏，但是会存在裁剪）</span></span><br><span class="line">            scaleFactor = Mathf.Min(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ScreenMatchMode.Shrink:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 保证缩放后的Canvas的大小不大于设计分辨率（保证设计的类容全部显示，但是会有黑边）</span></span><br><span class="line">            scaleFactor = Mathf.Max(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetScaleFactor(scaleFactor);</span><br><span class="line">    SetReferencePixelsPerUnit(m_ReferencePixelsPerUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="事件系统">事件系统</h1>
<p>事件系统分为主要分为三个模块输入模块，射线器和事件系统。</p>
<h2 id="输入模块">输入模块</h2>
<p>输入模块负责获取处理系统的各种输入（屏幕输入，鼠标等）。下文中的“指针”是指鼠标指针或Touch的触摸点。核心类：</p>
<ul>
<li><p><strong>BaseInput</strong>,
输入的基类，主要转接了Unity的Input的部分功能，当然我们也可以从此类派生一个类，用于处理自定义的输入。</p></li>
<li><p><strong>BaseInputModule</strong>,
输入模块的基类，其中包括了关联的EventSystem，BaseInput和事件数据对象。其中BaseInput用于获取设备的输入情况。核心函数</p>
<ol type="1">
<li>Process,
此函数是一个抽象函数，主要是用来处理输入模块的更新，这个函数在EventSystem.Update函数中调用的</li>
<li>HandlePointerExitAndEnter, 此函数负责处理指针的进入和离开。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派生类都调用此函数进行处理指针的进入和退出</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">HandlePointerExitAndEnter</span>(<span class="params">PointerEventData currentPointerData, GameObject newEnterTarget</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有新的指针进入对象或当前没有指针进入对象，则清除所有被追踪的对象</span></span><br><span class="line">    <span class="keyword">if</span> (newEnterTarget == <span class="literal">null</span> || currentPointerData.pointerEnter == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行对象上的OnPointerExit函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentPointerData.hovered.Count; ++i)</span><br><span class="line">            ExecuteEvents.Execute(currentPointerData.hovered[i], currentPointerData, ExecuteEvents.pointerExitHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除以前追踪的对象</span></span><br><span class="line">        currentPointerData.hovered.Clear();</span><br><span class="line">        <span class="comment">// 清除当前事件数据中的当前进入的对象，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (newEnterTarget == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentPointerData.pointerEnter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前指针进入的对象和新目标对象像同，则说明没有切换目标当前事件数据的hovered没有变化，直接返回，否则就需要处理进入和退出</span></span><br><span class="line">    <span class="keyword">if</span> (currentPointerData.pointerEnter == newEnterTarget &amp;&amp; newEnterTarget)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找事件数据的当前对象和新对象是否具有相同的父节点，目的是为了减少添加移除的数量，如果有公共父加节点时，只需要处理到公共父节点就可以了</span></span><br><span class="line">    GameObject commonRoot = FindCommonRoot(currentPointerData.pointerEnter, newEnterTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前事件数据对象中已经有指针进入的对象了，现在指针进入了新对象，那么就需要将当前事件数据对象中的已经标记为指针进入的对象移除并调用它们OnPointerExit</span></span><br><span class="line">    <span class="keyword">if</span> (currentPointerData.pointerEnter != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Transform t = currentPointerData.pointerEnter.transform;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理到公共父节点，如果没有则直接处理到最顶层的父节点</span></span><br><span class="line">            <span class="keyword">if</span> (commonRoot != <span class="literal">null</span> &amp;&amp; commonRoot.transform == t)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行退出函数OnPointerExit</span></span><br><span class="line">            ExecuteEvents.Execute(t.gameObject, currentPointerData, ExecuteEvents.pointerExitHandler);</span><br><span class="line">            <span class="comment">// 移除老的对象</span></span><br><span class="line">            currentPointerData.hovered.Remove(t.gameObject);</span><br><span class="line">            t = t.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的对象加入到hovered中</span></span><br><span class="line">    currentPointerData.pointerEnter = newEnterTarget;</span><br><span class="line">    <span class="keyword">if</span> (newEnterTarget != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Transform t = newEnterTarget.transform;</span><br><span class="line">        <span class="comment">// 也是处理到公共父就不处理了，因为公共父节点上面的节点已经在hovered里了（前面移除就没有移除公共父节点以上的节点）</span></span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">null</span> &amp;&amp; t.gameObject != commonRoot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 同样的执行进入OnPointerEnter</span></span><br><span class="line">            ExecuteEvents.Execute(t.gameObject, currentPointerData, ExecuteEvents.pointerEnterHandler);</span><br><span class="line">            currentPointerData.hovered.Add(t.gameObject);</span><br><span class="line">            t = t.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ActivateModule，定义的输入模块被激活时调用的函数，这函数是在EventSystem中调用的</li>
<li>DeactivateModule,定义的输入模块被禁用时调用的函数，这函数是在EventSystem中调用的</li>
</ol></li>
<li><p><strong>PointerInputModule</strong>,
派生至BaseInputModule，用于处理指针（Touch和Mouse）的输入。核心函数</p>
<ol type="1">
<li>GetPointerData:
此函数是从m_PointerData列表中获取或创建一个PointerEventData对象。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">bool</span> <span class="title">GetPointerData</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">out</span> PointerEventData data, <span class="keyword">bool</span> create</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从m_PointerData中获取指针数据</span></span><br><span class="line">    <span class="keyword">if</span> (!m_PointerData.TryGetValue(id, <span class="keyword">out</span> data) &amp;&amp; create)</span><br><span class="line">    &#123;</span><br><span class="line">        data = <span class="keyword">new</span> PointerEventData(eventSystem)</span><br><span class="line">        &#123;</span><br><span class="line">            pointerId = id,</span><br><span class="line">        &#125;;</span><br><span class="line">        m_PointerData.Add(id, data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>GetTouchPointerEventData,
获取Touch指针的事件数据，并返回是否<strong>按下</strong>或<strong>释放</strong>以及通过EventSystem.RaycastAll函数获取当前指针击中的第一个射线结果，并将结果保存在指针事件数据的pointerCurrentRaycast字段中。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> PointerEventData <span class="title">GetTouchPointerEventData</span>(<span class="params">Touch input, <span class="keyword">out</span> <span class="keyword">bool</span> pressed, <span class="keyword">out</span> <span class="keyword">bool</span> released</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前TouchID对应的指针数据，如果没有则创建一个指正数据</span></span><br><span class="line">    PointerEventData pointerData;</span><br><span class="line">    <span class="keyword">var</span> created = GetPointerData(input.fingerId, <span class="keyword">out</span> pointerData, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    pointerData.Reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前Touch的数据状态</span></span><br><span class="line">    pressed = created || (input.phase == TouchPhase.Began);</span><br><span class="line">    released = (input.phase == TouchPhase.Canceled) || (input.phase == TouchPhase.Ended);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前按下时的屏幕位置, 以及距离上次的指针位置偏移值</span></span><br><span class="line">    <span class="keyword">if</span> (created)</span><br><span class="line">        pointerData.position = input.position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pressed)</span><br><span class="line">        pointerData.delta = Vector2.zero;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pointerData.delta = input.position - pointerData.position;</span><br><span class="line"></span><br><span class="line">    pointerData.position = input.position;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将button类型设置为Left, 主要是兼容鼠标的（Left，Middle和Right）</span></span><br><span class="line">    pointerData.button = PointerEventData.InputButton.Left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是取消则通过EventSystem的RaycastAll检查第一个击中的对象，并记录到当前指针事件数据的pointerCurrentRaycast中</span></span><br><span class="line">    <span class="keyword">if</span> (input.phase == TouchPhase.Canceled)</span><br><span class="line">    &#123;</span><br><span class="line">        pointerData.pointerCurrentRaycast = <span class="keyword">new</span> RaycastResult();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        eventSystem.RaycastAll(pointerData, m_RaycastResultCache);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> raycast = FindFirstRaycast(m_RaycastResultCache);</span><br><span class="line">        pointerData.pointerCurrentRaycast = raycast;</span><br><span class="line">        m_RaycastResultCache.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pointerData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>StateForMouseButton,
获取指定鼠标指针的<strong>按下</strong>或<strong>释放</strong>状态。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PointerEventData.<span class="function">FramePressState <span class="title">StateForMouseButton</span>(<span class="params"><span class="keyword">int</span> buttonId</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据当前的鼠标输入获取对应鼠标按键的状态</span></span><br><span class="line">    <span class="keyword">var</span> pressed = input.GetMouseButtonDown(buttonId);</span><br><span class="line">    <span class="keyword">var</span> released = input.GetMouseButtonUp(buttonId);</span><br><span class="line">    <span class="keyword">if</span> (pressed &amp;&amp; released)</span><br><span class="line">        <span class="keyword">return</span> PointerEventData.FramePressState.PressedAndReleased;</span><br><span class="line">    <span class="keyword">if</span> (pressed)</span><br><span class="line">        <span class="keyword">return</span> PointerEventData.FramePressState.Pressed;</span><br><span class="line">    <span class="keyword">if</span> (released)</span><br><span class="line">        <span class="keyword">return</span> PointerEventData.FramePressState.Released;</span><br><span class="line">    <span class="keyword">return</span> PointerEventData.FramePressState.NotChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>GetMousePointerEventData,
获取鼠标指针的事件数据，同GetTouchPointerEventData功能一样只是这里的输入状态是获取鼠标的。</li>
<li>ProcessMove,
处理以移动，根据指针事件数据的pointerCurrentRaycast进行指针进入或离开处理</li>
<li>ProcessDrag, 处理拖拽. <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ProcessDrag</span>(<span class="params">PointerEventData pointerEvent</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否需要处理Drag，指针没有移动或者没有拖拽对象的时</span></span><br><span class="line">    <span class="keyword">if</span> (!pointerEvent.IsPointerMoving() ||</span><br><span class="line">        Cursor.lockState == CursorLockMode.Locked ||</span><br><span class="line">        pointerEvent.pointerDrag == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否应该开始拖拽，当拖动距离达到阈值时才应该开始拖拽</span></span><br><span class="line">    <span class="keyword">if</span> (!pointerEvent.dragging</span><br><span class="line">        &amp;&amp; ShouldStartDrag(pointerEvent.pressPosition, pointerEvent.position, eventSystem.pixelDragThreshold, pointerEvent.useDragThreshold))</span><br><span class="line">    &#123;</span><br><span class="line">        ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.beginDragHandler);</span><br><span class="line">        pointerEvent.dragging = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经进入拖拽状态了</span></span><br><span class="line">    <span class="keyword">if</span> (pointerEvent.dragging)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将查是否应该取消拖拽了，如果按下的对象和拖拽的对象不是同一个则应该取消拖拽</span></span><br><span class="line">        <span class="keyword">if</span> (pointerEvent.pointerPress != pointerEvent.pointerDrag)</span><br><span class="line">        &#123;</span><br><span class="line">            ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);</span><br><span class="line"></span><br><span class="line">            pointerEvent.eligibleForClick = <span class="literal">false</span>;</span><br><span class="line">            pointerEvent.pointerPress = <span class="literal">null</span>;</span><br><span class="line">            pointerEvent.rawPointerPress = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用OnDrag函数</span></span><br><span class="line">        ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.dragHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p><strong>StandaloneInputModule</strong>,
继承至PointerInputModule模块，此类处理了鼠标，键盘，控制器和Touch的输入，以前TouchInputModule模块已经合并到此类中。核心函数是Process,
ProcessTouchEvents和ProcessMouseEvent。</p>
<ol type="1">
<li><p>Process,
此函数是EventSystem.Update函数中调用过来的，用于每帧处理Touch和鼠标的输入信息。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Process</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当APP不是当前激活程序时，且又应该忽略事件在没有聚焦时候则返回，不用进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (!eventSystem.isFocused &amp;&amp; ShouldIgnoreEventsOnNoFocus())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像当前选中的对象发送OnUpdateSelected</span></span><br><span class="line">    <span class="keyword">bool</span> usedEvent = SendUpdateEventToSelectedObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有Touch输入设备则优先处理Touch的事件，如果没有Touch设备且有鼠标则处理鼠标的事件</span></span><br><span class="line">    <span class="keyword">if</span> (!ProcessTouchEvents() &amp;&amp; input.mousePresent)</span><br><span class="line">        ProcessMouseEvent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否应该发送导航事件（move, submit和cancel）</span></span><br><span class="line">    <span class="keyword">if</span> (eventSystem.sendNavigationEvents)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事件没有被吞掉时发送OnMove</span></span><br><span class="line">        <span class="keyword">if</span> (!usedEvent)</span><br><span class="line">            usedEvent |= SendMoveEventToSelectedObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事件没有被吞掉时发送OnSubmit事件</span></span><br><span class="line">        <span class="keyword">if</span> (!usedEvent)</span><br><span class="line">            SendSubmitEventToSelectedObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>ProcessTouchEvents, 此函数处理Touch的事件 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">ProcessTouchEvents</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理Touch输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.touchCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历的当前Touch</span></span><br><span class="line">        Touch touch = input.GetTouch(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是间接(远程)的Touch，则不处理</span></span><br><span class="line">        <span class="keyword">if</span> (touch.type == TouchType.Indirect)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前Touch的指针位置的事件数据，并返回是按下还是释放</span></span><br><span class="line">        <span class="keyword">bool</span> released;</span><br><span class="line">        <span class="keyword">bool</span> pressed;</span><br><span class="line">        <span class="keyword">var</span> pointer = GetTouchPointerEventData(touch, <span class="keyword">out</span> pressed, <span class="keyword">out</span> released);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Touch的按下或释放</span></span><br><span class="line">        ProcessTouchPress(pointer, pressed, released);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有释放，则就处理父类定义的处理移动和处理拖拽，释放了则移除当前TouchID对应的指针事件数据</span></span><br><span class="line">        <span class="keyword">if</span> (!released)</span><br><span class="line">        &#123;</span><br><span class="line">            ProcessMove(pointer);</span><br><span class="line">            ProcessDrag(pointer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            RemovePointerData(pointer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input.touchCount &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>ProcessTouchPress, 处理Touch的按下或释放 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ProcessTouchPress</span>(<span class="params">PointerEventData pointerEvent, <span class="keyword">bool</span> pressed, <span class="keyword">bool</span> released</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前指针事件击中对象</span></span><br><span class="line">    <span class="keyword">var</span> currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理Touch按下时</span></span><br><span class="line">    <span class="keyword">if</span> (pressed)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 重置指针事件数据</span></span><br><span class="line">        pointerEvent.eligibleForClick = <span class="literal">true</span>;</span><br><span class="line">        pointerEvent.delta = Vector2.zero;</span><br><span class="line">        pointerEvent.dragging = <span class="literal">false</span>;</span><br><span class="line">        pointerEvent.useDragThreshold = <span class="literal">true</span>;</span><br><span class="line">        pointerEvent.pressPosition = pointerEvent.position;</span><br><span class="line">        pointerEvent.pointerPressRaycast = pointerEvent.pointerCurrentRaycast;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查如果当前选中的对象是否发生改变如果发生则更改EventSystem中的当前选中对象并发送</span></span><br><span class="line">        DeselectIfSelectionChanged(currentOverGo, pointerEvent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前的OnEnter对象不是当前射线击中的对象时，所以击中对象改变了，则需要更新指针事件数据的hoverd列表</span></span><br><span class="line">        <span class="keyword">if</span> (pointerEvent.pointerEnter != currentOverGo)</span><br><span class="line">        &#123;</span><br><span class="line">            HandlePointerExitAndEnter(pointerEvent, currentOverGo);</span><br><span class="line">            pointerEvent.pointerEnter = currentOverGo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前的对象继承结构中查找并执行OnPointerDown函数</span></span><br><span class="line">        <span class="keyword">var</span> newPressed = ExecuteEvents.ExecuteHierarchy(currentOverGo, pointerEvent, ExecuteEvents.pointerDownHandler);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (newPressed == <span class="literal">null</span>)</span><br><span class="line">            newPressed = ExecuteEvents.GetEventHandler&lt;IPointerClickHandler&gt;(currentOverGo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理双击</span></span><br><span class="line">        <span class="keyword">float</span> time = Time.unscaledTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前按下的对象和一次按下的对象相同，则需要统计点击次数，如果两次点击的间隔在0.3秒以下则可以识别为双击</span></span><br><span class="line">        <span class="keyword">if</span> (newPressed == pointerEvent.lastPress)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> diffTime = time - pointerEvent.clickTime;</span><br><span class="line">            <span class="keyword">if</span> (diffTime &lt; <span class="number">0.3f</span>)</span><br><span class="line">                ++pointerEvent.clickCount;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pointerEvent.clickCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            pointerEvent.clickTime = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pointerEvent.clickCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前按下的对象对象和按下时的时间</span></span><br><span class="line">        pointerEvent.pointerPress = newPressed;</span><br><span class="line">        pointerEvent.rawPointerPress = currentOverGo;</span><br><span class="line">        </span><br><span class="line">        pointerEvent.clickTime = time;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存拖拽的对象</span></span><br><span class="line">        pointerEvent.pointerDrag = ExecuteEvents.GetEventHandler&lt;IDragHandler&gt;(currentOverGo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有需要拖拽的对象，则调用OnInitializePotentialDrag函数</span></span><br><span class="line">        <span class="keyword">if</span> (pointerEvent.pointerDrag != <span class="literal">null</span>)</span><br><span class="line">            ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.initializePotentialDrag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存当前的指针事件对象</span></span><br><span class="line">        m_InputPointerEvent = pointerEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理Touch释放时</span></span><br><span class="line">    <span class="keyword">if</span> (released)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行OnPointerUp函数</span></span><br><span class="line">        ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指针释放时有OnPointerClick的对象</span></span><br><span class="line">        <span class="keyword">var</span> pointerUpHandler = ExecuteEvents.GetEventHandler&lt;IPointerClickHandler&gt;(currentOverGo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指针按下时的对象和当前有OnPointerClick的对象相同，则说明按下和释放在同一个对象，则需要处理点击事件。在启动拖拽的时候eligibleForClick被设置成了false，也就是拖拽和点击时不可以同时出现的</span></span><br><span class="line">        <span class="keyword">if</span> (pointerEvent.pointerPress == pointerUpHandler &amp;&amp; pointerEvent.eligibleForClick)</span><br><span class="line">        &#123;</span><br><span class="line">            ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有点击的则检查是否有拖拽的对象，有并且在拖拽中释放的Touch则执行OnDrop</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pointerEvent.pointerDrag != <span class="literal">null</span> &amp;&amp; pointerEvent.dragging)</span><br><span class="line">        &#123;</span><br><span class="line">            ExecuteEvents.ExecuteHierarchy(currentOverGo, pointerEvent, ExecuteEvents.dropHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放后则重置按下的对象为空</span></span><br><span class="line">        pointerEvent.eligibleForClick = <span class="literal">false</span>;</span><br><span class="line">        pointerEvent.pointerPress = <span class="literal">null</span>;</span><br><span class="line">        pointerEvent.rawPointerPress = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放的时候再拖拽中，则还要执行OnEndDrag</span></span><br><span class="line">        <span class="keyword">if</span> (pointerEvent.pointerDrag != <span class="literal">null</span> &amp;&amp; pointerEvent.dragging)</span><br><span class="line">            ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.endDragHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置拖拽状态</span></span><br><span class="line">        pointerEvent.dragging = <span class="literal">false</span>;</span><br><span class="line">        pointerEvent.pointerDrag = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在已经指针进入的对象上执行OnPointerExit，请清除了当前指针事件数据中的pointerEnter</span></span><br><span class="line">        ExecuteEvents.ExecuteHierarchy(pointerEvent.pointerEnter, pointerEvent, ExecuteEvents.pointerExitHandler);</span><br><span class="line">        pointerEvent.pointerEnter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存当前指针的指针数据对象</span></span><br><span class="line">        m_InputPointerEvent = pointerEvent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>ProcessMouseEvent，同ProcessTouchEvents函数一样，只是输入源是鼠标。</p></li>
<li><p>ProcessMousePress，同ProcessTouchPress函数一样，只是处理输入源不一样。</p></li>
</ol></li>
</ul>
<p>事件的处理流程如下：</p>
<p>首先EventSystem的Update处理了输入模块的切换，以及调用了当前输入模块的Process函数，然后在StandaloneInputModule输入模块中处理所有的输入，并在输入模块中通过射线器去更新当前指针击中的的对象和指针的位置，并处理了所有的事件。</p>
<h2 id="射线器">射线器</h2>
<p>射线器负责根据输入的位置发射射线或通过区域检查的方式检查对象是否被击中。</p>
<ul>
<li><p><strong>BaseRaycaster</strong>,
此类是射线发射器的基类，主要功能是定义了排序优先级，Raycast函数以及在OnEnable和OnDisable的时候将自己自己添加到RaycasterManager中或从RaycasterManager中移除。</p>
<ol type="1">
<li>eventCamera: 射线器使用的相机。</li>
<li>rootRaycaster: 缓存顶层父节点的射线器。</li>
<li>sortOrderPriority：排序优先级（sortingOrder）</li>
<li>renderOrderPriority：渲染优先级(renderOrder)</li>
</ol></li>
<li><p><strong>PhysicsRaycaster</strong>,
继承至BaseRaycaster，主要功能是负责3D射线的相关功能，其核心函数就是父类定义的抽象函数Raycast。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过物理射线进行击中检查，并将结果放入resultAppendList中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Raycast</span>(<span class="params">PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前屏幕点的射线</span></span><br><span class="line">    Ray ray = <span class="keyword">new</span> Ray();</span><br><span class="line">    <span class="keyword">float</span> distanceToClipPlane = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ComputeRayAndDistance(eventData, <span class="keyword">ref</span> ray, <span class="keyword">ref</span> distanceToClipPlane))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hitCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大击中数量，0：表示发送射线时分配，即调用Physics.RaycastAll时，由此函数分配RaycastHit数组</span></span><br><span class="line">    <span class="keyword">if</span> (m_MaxRayIntersections == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过放射的方式获取了Physics.RaycastAll函数</span></span><br><span class="line">        <span class="keyword">if</span> (ReflectionMethodsCache.Singleton.raycast3DAll == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Physics.RaycastAll，并将结果缓存到m_Hits中</span></span><br><span class="line">        m_Hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);</span><br><span class="line">        hitCount = m_Hits.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用优化的版本，事先分配好RaycastHit数组</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 通过反射方式获取Physics.RaycastNonAlloc函数</span></span><br><span class="line">        <span class="keyword">if</span> (ReflectionMethodsCache.Singleton.getRaycastNonAlloc == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据设置的大小分配RaycastHit数组</span></span><br><span class="line">        <span class="keyword">if</span> (m_LastMaxRayIntersections != m_MaxRayIntersections)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Hits = <span class="keyword">new</span> RaycastHit[m_MaxRayIntersections];</span><br><span class="line">            m_LastMaxRayIntersections = m_MaxRayIntersections;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Physics.RaycastNonAlloc函数获取击中的结果</span></span><br><span class="line">        hitCount = ReflectionMethodsCache.Singleton.getRaycastNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据到摄像机的距离进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (hitCount &gt; <span class="number">1</span>)</span><br><span class="line">        System.Array.Sort(m_Hits, (r1, r2) =&gt; r1.distance.CompareTo(r2.distance));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成射线结果对象RaycastResult，并添加到返回列表中</span></span><br><span class="line">    <span class="keyword">if</span> (hitCount != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>, bmax = hitCount; b &lt; bmax; ++b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> RaycastResult</span><br><span class="line">            &#123;</span><br><span class="line">                gameObject = m_Hits[b].collider.gameObject,</span><br><span class="line">                module = <span class="keyword">this</span>,</span><br><span class="line">                distance = m_Hits[b].distance,</span><br><span class="line">                worldPosition = m_Hits[b].point,</span><br><span class="line">                worldNormal = m_Hits[b].normal,</span><br><span class="line">                screenPosition = eventData.position,</span><br><span class="line">                index = resultAppendList.Count,</span><br><span class="line">                sortingLayer = <span class="number">0</span>,</span><br><span class="line">                sortingOrder = <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">            resultAppendList.Add(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Physics2DRaycaster</strong>,
继承至PhysicsRaycaster类，其核心函数也是Raycast函数，功能和基类的Raycast函数相同只是使用的是Physics2D。</p></li>
<li><p><strong>RaycastResult</strong>,
此结构体是用于存储射线器击中结果的信息，具体信息包括：</p>
<ol type="1">
<li>gameObject: 击中的对象</li>
<li>module:使用哪个射线器击中的</li>
<li>distance:距离相机的距离</li>
<li>index:在所用击中列表的索引值</li>
<li>worldPosition:击中位置的事件坐标</li>
<li>worldNormal:击中位置的法线</li>
<li>screenPosition:射线发出时的屏幕位置</li>
</ol></li>
<li><p><strong>GraphicRaycaster</strong>,
继承至PhysicsRaycaster类的图像射线器，通过矩形区域检查是否击中，必须挂在Canvas对象上，核心函数也是Raycast。
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Raycast</span>(<span class="params">PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 没有Canvas或Canva下没有对象则不进行射线检查</span></span><br><span class="line">    <span class="keyword">if</span> (canvas == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> canvasGraphics = GraphicRegistry.GetGraphicsForCanvas(canvas);</span><br><span class="line">    <span class="keyword">if</span> (canvasGraphics == <span class="literal">null</span> || canvasGraphics.Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Canvas显示在哪个显示设备上（可能会存在多个显示设备）</span></span><br><span class="line">    <span class="keyword">int</span> displayIndex;</span><br><span class="line">    <span class="keyword">var</span> currentEventCamera = eventCamera; </span><br><span class="line">    <span class="comment">// 在屏幕覆盖模式或没有相机的时候，根据Canvas中的targetDisplay来确定显示设备索引，如果有相机则使用相机中指定的显示设备索引</span></span><br><span class="line">    <span class="keyword">if</span> (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == <span class="literal">null</span>)</span><br><span class="line">        displayIndex = canvas.targetDisplay;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        displayIndex = currentEventCamera.targetDisplay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算屏幕坐标</span></span><br><span class="line">    <span class="keyword">var</span> eventPosition = Display.RelativeMouseAt(eventData.position);</span><br><span class="line">    <span class="keyword">if</span> (eventPosition != Vector3.zero)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指针的位置不是当前显示屏幕则则不进行射线处理</span></span><br><span class="line">        <span class="keyword">int</span> eventDisplayIndex = (<span class="keyword">int</span>)eventPosition.z;</span><br><span class="line">        <span class="keyword">if</span> (eventDisplayIndex != displayIndex)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        eventPosition = eventData.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将屏幕坐标转化为视口坐标</span></span><br><span class="line">    Vector2 pos;</span><br><span class="line">    <span class="keyword">if</span> (currentEventCamera == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 多显示屏支持，更具上一步确定的显示设备索引，计算视口坐标</span></span><br><span class="line">        <span class="keyword">float</span> w = Screen.width;</span><br><span class="line">        <span class="keyword">float</span> h = Screen.height;</span><br><span class="line">        <span class="keyword">if</span> (displayIndex &gt; <span class="number">0</span> &amp;&amp; displayIndex &lt; Display.displays.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            w = Display.displays[displayIndex].systemWidth;</span><br><span class="line">            h = Display.displays[displayIndex].systemHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = <span class="keyword">new</span> Vector2(eventPosition.x / w, eventPosition.y / h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pos = currentEventCamera.ScreenToViewportPoint(eventPosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否在视口范围内</span></span><br><span class="line">    <span class="keyword">if</span> (pos.x &lt; <span class="number">0f</span> || pos.x &gt; <span class="number">1f</span> || pos.y &lt; <span class="number">0f</span> || pos.y &gt; <span class="number">1f</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 屏蔽2D或3D对象的最小距离, 使用的方式是只要选择屏蔽对象类型（2D，3D和ALL）,就通过射线去打，大于最近的这个击中距离的Graphic对象就会被排除，只个只对带相机的Canvas有效</span></span><br><span class="line">    <span class="keyword">float</span> hitDistance = <span class="keyword">float</span>.MaxValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前指针的屏幕位置生成射线</span></span><br><span class="line">    Ray ray = <span class="keyword">new</span> Ray();</span><br><span class="line">    <span class="keyword">if</span> (currentEventCamera != <span class="literal">null</span>)</span><br><span class="line">        ray = currentEventCamera.ScreenPointToRay(eventPosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过射线去中击中检查，获取最近的击中距离</span></span><br><span class="line">    <span class="keyword">if</span> (canvas.renderMode != RenderMode.ScreenSpaceOverlay &amp;&amp; blockingObjects != BlockingObjects.None)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> distanceToClipPlane = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentEventCamera != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> projectionDirection = ray.direction.z;</span><br><span class="line">            distanceToClipPlane = Mathf.Approximately(<span class="number">0.0f</span>, projectionDirection)</span><br><span class="line">                ? Mathf.Infinity</span><br><span class="line">                : Mathf.Abs((currentEventCamera.farClipPlane - currentEventCamera.nearClipPlane) / projectionDirection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ReflectionMethodsCache.Singleton.raycast3D != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (<span class="keyword">int</span>)m_BlockingMask);</span><br><span class="line">                <span class="keyword">if</span> (hits.Length &gt; <span class="number">0</span>)</span><br><span class="line">                    hitDistance = hits[<span class="number">0</span>].distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blockingObjects == BlockingObjects.TwoD || blockingObjects == BlockingObjects.All)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ReflectionMethodsCache.Singleton.raycast2D != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, (<span class="keyword">int</span>)m_BlockingMask);</span><br><span class="line">                <span class="keyword">if</span> (hits.Length &gt; <span class="number">0</span>)</span><br><span class="line">                    hitDistance = hits[<span class="number">0</span>].distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始进行图像射线击中检查，通过检查指针当前点是否在Graphic的矩形区域内</span></span><br><span class="line">    m_RaycastResults.Clear();</span><br><span class="line">    Raycast(canvas, currentEventCamera, eventPosition, canvasGraphics, m_RaycastResults);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在图像射线击中的结果中，筛选满足条件的Graphic</span></span><br><span class="line">    <span class="keyword">int</span> totalCount = m_RaycastResults.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; totalCount; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> go = m_RaycastResults[index].gameObject;</span><br><span class="line">        <span class="keyword">bool</span> appendGraphic = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果忽略了背向的Graphic,则需要剔除那些背向相机的</span></span><br><span class="line">        <span class="keyword">if</span> (ignoreReversedGraphics)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentEventCamera == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> dir = go.transform.rotation * Vector3.forward;</span><br><span class="line">                appendGraphic = Vector3.Dot(Vector3.forward, dir) &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> cameraFoward = currentEventCamera.transform.rotation * Vector3.forward;</span><br><span class="line">                <span class="keyword">var</span> dir = go.transform.rotation * Vector3.forward;</span><br><span class="line">                appendGraphic = Vector3.Dot(cameraFoward, dir) &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 筛选后可以进行事件检查的Graphic</span></span><br><span class="line">        <span class="keyword">if</span> (appendGraphic)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> distance = <span class="number">0</span>;</span><br><span class="line">            Transform trans = go.transform;</span><br><span class="line">            Vector3 transForward = trans.forward;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentEventCamera == <span class="literal">null</span> || canvas.renderMode == RenderMode.ScreenSpaceOverlay)</span><br><span class="line">                distance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// http://geomalgorithms.com/a06-_intersect-2.html</span></span><br><span class="line">                distance = (Vector3.Dot(transForward, trans.position - ray.origin) / Vector3.Dot(transForward, ray.direction));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 距离小于零表示在摄像机后面，不可见</span></span><br><span class="line">                <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 距离大于限定距离则丢弃</span></span><br><span class="line">            <span class="keyword">if</span> (distance &gt;= hitDistance)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后都通过了，则生成射线结果，并将其添加到结果列表里</span></span><br><span class="line">            <span class="keyword">var</span> castResult = <span class="keyword">new</span> RaycastResult</span><br><span class="line">            &#123;</span><br><span class="line">                gameObject = go,</span><br><span class="line">                module = <span class="keyword">this</span>,</span><br><span class="line">                distance = distance,</span><br><span class="line">                screenPosition = eventPosition,</span><br><span class="line">                index = resultAppendList.Count,</span><br><span class="line">                depth = m_RaycastResults[index].depth,</span><br><span class="line">                sortingLayer = canvas.sortingLayerID,</span><br><span class="line">                sortingOrder = canvas.sortingOrder,</span><br><span class="line">                worldPosition = ray.origin + ray.direction * distance,</span><br><span class="line">                worldNormal = -transForward</span><br><span class="line">            &#125;;</span><br><span class="line">            resultAppendList.Add(castResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像射线检查</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Raycast</span>(<span class="params">Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList&lt;Graphic&gt; foundGraphics, List&lt;Graphic&gt; results</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Canvas下的所有Graphic对象</span></span><br><span class="line">    <span class="keyword">int</span> totalCount = foundGraphics.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Graphic graphic = foundGraphics[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剔除不需要被射线检的（Canvas已经处理的，不需要射线的，已经被剔除的）</span></span><br><span class="line">        <span class="comment">// -1 means it hasn't been processed by the canvas, which means it isn't actually drawn</span></span><br><span class="line">        <span class="keyword">if</span> (graphic.depth == <span class="number">-1</span> || !graphic.raycastTarget || graphic.canvasRenderer.cull)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做矩形区域检查，点不在这个区域的直接忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 有相机时，超出远平面的也剔除</span></span><br><span class="line">        <span class="keyword">if</span> (eventCamera != <span class="literal">null</span> &amp;&amp; eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z &gt; eventCamera.farClipPlane)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此函数会调用ICanvasRaycastFilter接口的IsRaycastLocationValid函数检查并过滤掉无效的对象，没有ICanvasRaycastFilter接口的对象则不需要进行过滤检查</span></span><br><span class="line">        <span class="keyword">if</span> (graphic.Raycast(pointerPosition, eventCamera))</span><br><span class="line">        &#123;</span><br><span class="line">            s_SortedGraphics.Add(graphic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据CanvasRenderer.absoluteDepth的绝对深度进行排序。</span></span><br><span class="line">    s_SortedGraphics.Sort((g1, g2) =&gt; g2.depth.CompareTo(g1.depth));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序后的Graphic对象添加到结果列表中</span></span><br><span class="line">    totalCount = s_SortedGraphics.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalCount; ++i)</span><br><span class="line">        results.Add(s_SortedGraphics[i]);</span><br><span class="line"></span><br><span class="line">    s_SortedGraphics.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>RaycasterManager</strong>,
管理所有射线器，当射线器启动时会加到RaycasterManager中，核心函数就是AddRaycaster，
RemoveRaycasters和GetRaycasters函数。</p></li>
</ul>
<h2 id="事件系统-1">事件系统</h2>
<p>事件系统负责处理输入，发射射线并发出事件。</p>
<ul>
<li><p><strong>IEventSystemHandler</strong>,
事件接口顶层类，派生了IPointerEnterHandler，IPointerExitHandler，IPointerDownHandler，IPointerUpHandler和IPointerClickHandler接口等。</p></li>
<li><p><strong>EventTrigger</strong>,
此类实现了所有的事件接口，提供了一种在Unity对象上挂事件回调的方法。</p></li>
<li><p><strong>ExecuteEvents</strong>,
此类是为了在对象上执行事件接口的一个便利类，核心函数Excute在指定的对象上执行指定的接口函数，ExecuteHierarchy函数从子一直往上执行指定的接口函数，GetEventHandler函数回去指定对象或它的上级对象上第一个能有指定事件的对象。</p></li>
<li><p><strong>AbstractEventData</strong>,
事件数据的顶层基类，此类定义了一个事件是否使用的标记。</p></li>
<li><p><strong>BaseEventData</strong>,
事件数据的基类，此类定义了关联的EventSystem，BaseInputModule和当前选择的对象。</p></li>
<li><p><strong>AxisEventData</strong>,
输入控制器（手柄之类）或键盘关联的轴事件数据，主要包含了轴的移动向量和移动方向。</p></li>
<li><p><strong>PointerEventData</strong>,
触摸或鼠标事件关联的数据类，此数据类是整个事件系统的核心数据类，包含类如下的数据：</p>
<ol type="1">
<li>pointerId: 指针ID</li>
<li>position: 当前指针位置</li>
<li>delta：最后一次指针移动的偏移量</li>
<li>pressPosition：指针按下时的位置</li>
<li>clickTime：最后一次点击事件，主要用于双击的检查</li>
<li>clickCount：点击次数</li>
<li>scrollDelta：滚轮的偏移量</li>
<li>useDragThreshold：是否使用拖拽阈值，如果不想使用拖拽阈值可以在IInitializePotentialDragHandler.OnInitializePotentialDrag函数里设置为false</li>
<li>dragging：是否在拖拽中</li>
<li>IsPointerMoving(): 指针是否在移动中</li>
<li>IsScrolling(): 滚轮是否在滚动中</li>
<li>button: 当前指针使用的按钮（Left, Right, Middle）</li>
<li>pointerEnter: 当前指针进入的对象（有OnPointerEnter的对象）</li>
<li>pointerPress: 当前指针按下的对象 (有OnPointerDown的对象)</li>
<li>lastPress: 上一次指针按下的对象（不一定有OnPointerDown的对象）</li>
<li>rawPointerPress:
当前指针按下时的对象（不一定有OnPointerDown的对象）</li>
<li>pointerDrag: 当前指针拖拽的对象（有OnDrag的对象）</li>
<li>pointerCurrentRaycast:
当前事件关联的射线击中结果对象(RaycastResult)</li>
<li>pointerPressRaycast:
与指针按下时关联的射线击中结果对象(RaycastResult)</li>
<li>hovered:
保存指针移动时，射线击中的对象。指针进入一个对象或离开一个对象时都会向此字段中添加或移除对象</li>
<li>eligibleForClick:
在指针谈起时，是否有资格进行点击操作（拖拽的时候不执行点击操作）</li>
</ol></li>
<li><p><strong>EventSystem</strong>,
是驱动整个系统更新的入口，EventSystem管理了所有的输入模块但只有当前输入模块有效，我们也可以在场景中添加多个EventSystem但也只有第一个有效。EventSystem记录当前选择的对象和首个选择的对象，可以通过SetSelectedGameObject进行当前选择对象的切换，并且会对应对象发送OnDeselect和OnSelect事件。
核心函数： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动的时候OnEnable中，调用此函数缓存了所有的输入模块，并将没有被激活的输入模块移除掉。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateModules</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetComponents(m_SystemInputModules);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m_SystemInputModules.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_SystemInputModules[i] &amp;&amp; m_SystemInputModules[i].IsActive())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        m_SystemInputModules.RemoveAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心函数，进行事件系统主循环的更新</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 虽然可以有多个事件系统，但保证只有当前的事件系统能够被更新</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此函数遍历所有的输入模块，并调用输入模块的UpdateModule函数，UpdateModule函数主要处理应用程序失去焦点时释放按下的指针，并更新输入模块中记录的当前指针位置</span></span><br><span class="line">    TickModules();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要切换当前输入模块</span></span><br><span class="line">    <span class="keyword">bool</span> changedModule = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m_SystemInputModules.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> module = m_SystemInputModules[i];</span><br><span class="line">        <span class="keyword">if</span> (module.IsModuleSupported() &amp;&amp; module.ShouldActivateModule())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_CurrentInputModule != module)</span><br><span class="line">            &#123;</span><br><span class="line">                ChangeEventModule(module);</span><br><span class="line">                changedModule = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是没有需要切换为当前的输入模块，则直接使用第一个作为输入模块</span></span><br><span class="line">    <span class="keyword">if</span> (m_CurrentInputModule == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m_SystemInputModules.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> module = m_SystemInputModules[i];</span><br><span class="line">            <span class="keyword">if</span> (module.IsModuleSupported())</span><br><span class="line">            &#123;</span><br><span class="line">                ChangeEventModule(module);</span><br><span class="line">                changedModule = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每帧都处理输入模块中的数据数据</span></span><br><span class="line">    <span class="keyword">if</span> (!changedModule &amp;&amp; m_CurrentInputModule != <span class="literal">null</span>)</span><br><span class="line">        m_CurrentInputModule.Process();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前指针的事件数据，发送射线，并返回射线的击中结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaycastAll</span>(<span class="params">PointerEventData eventData, List&lt;RaycastResult&gt; raycastResults</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 清空结果</span></span><br><span class="line">    raycastResults.Clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在RaycasterManager中获取所有获取所有激活的射线器，并调用射线器中的Raycast函数进行击中检查</span></span><br><span class="line">    <span class="keyword">var</span> modules = RaycasterManager.GetRaycasters();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; modules.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> module = modules[i];</span><br><span class="line">        <span class="keyword">if</span> (module == <span class="literal">null</span> || !module.IsActive())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        module.Raycast(eventData, raycastResults);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所射线器击中的对象进行排序，排序规则为：</span></span><br><span class="line">    <span class="comment">// 1. 如果是不同的射线器且都有相机则优先使用相机的深度进行排序，没有相机或相机深度相同时则根据Canvas的sortOrder, 期次根据Canvas的renderOrder</span></span><br><span class="line">    <span class="comment">// 2. 如果射线器相同，则优先根据Canvas的sortingLayer排序,再根据Canvas的sortingOrder排序，再根据Graphic的depth排序，再根据对象的距离排序，最后根据击中结果列表的索引来进行排序</span></span><br><span class="line">    raycastResults.Sort(s_RaycastComparer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="总结">总结</h1>
<p>本文通过对UGUI源码的阅读，了解了整个UI系统的处理流程，其中包括了显示组件，布局系统和事件系统三大主要模块，UGUI还有一些控件比如像ScrollRect,
InputFields,
Button和Slider等，这里就没再继续阅读它们的代码了，因为这些控件都是基于三大模块的组合并额外加入了每个控件的自身逻辑，比如像ScrollRect就在三大模块的基础上加了滚动的处理。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/UI/" rel="tag"><i class="fa fa-tag"></i> UI</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/03/22/Unity/Animation/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/" rel="next" title="骨骼动画">
                  <i class="fa fa-chevron-left"></i> 骨骼动画
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/08/04/Unity/UI/UGUI%E5%9F%BA%E7%A1%80/" rel="prev" title="UGUI基础">
                  UGUI基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础回顾"><span class="nav-number">1.</span> <span class="nav-text">基础回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模型组成"><span class="nav-number">1.1.</span> <span class="nav-text">模型组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型渲染"><span class="nav-number">1.2.</span> <span class="nav-text">模型渲染</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#显示组件渲染"><span class="nav-number">2.</span> <span class="nav-text">显示组件（渲染）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计结构"><span class="nav-number">2.1.</span> <span class="nav-text">设计结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显示组件rawimageimage和text"><span class="nav-number">2.2.</span> <span class="nav-text">显示组件RawImage，Image和Text</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mask实现原理"><span class="nav-number">2.3.</span> <span class="nav-text">Mask实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模板stencil缓冲实现mask"><span class="nav-number">2.3.1.</span> <span class="nav-text">模板(Stencil)缓冲实现Mask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用程序裁剪mask实现rectmask2d"><span class="nav-number">2.3.2.</span> <span class="nav-text">应用程序裁剪Mask实现RectMask2D</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mesh效果"><span class="nav-number">2.4.</span> <span class="nav-text">Mesh效果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#布局系统"><span class="nav-number">3.</span> <span class="nav-text">布局系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#布局基础-recttransform"><span class="nav-number">3.1.</span> <span class="nav-text">布局基础-RectTransform</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布局器"><span class="nav-number">3.2.</span> <span class="nav-text">布局器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#控制自己"><span class="nav-number">3.2.1.</span> <span class="nav-text">控制自己</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制子对象"><span class="nav-number">3.2.2.</span> <span class="nav-text">控制子对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#屏幕适配"><span class="nav-number">3.3.</span> <span class="nav-text">屏幕适配</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件系统"><span class="nav-number">4.</span> <span class="nav-text">事件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#输入模块"><span class="nav-number">4.1.</span> <span class="nav-text">输入模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#射线器"><span class="nav-number">4.2.</span> <span class="nav-text">射线器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件系统-1"><span class="nav-number">4.3.</span> <span class="nav-text">事件系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张卫"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">张卫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/zw514159799" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;zw514159799" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Divad1111?tab=repositories" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Divad1111?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/qilezaitu" title="博客园 &amp;rarr; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;qilezaitu" rel="noopener" target="_blank"><i class="fa fa-fw fa-cnblogs"></i>博客园</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张卫</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">542k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:13</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

  

</body>
</html>
